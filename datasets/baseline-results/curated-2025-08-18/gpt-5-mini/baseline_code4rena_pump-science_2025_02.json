{
  "project": "code4rena_pump-science_2025_02",
  "timestamp": "2025-08-28T22:37:49.784281",
  "files_analyzed": 46,
  "files_skipped": 0,
  "total_findings": 22,
  "findings": [
    {
      "title": "Unchecked token_metadata_program allows arbitrary CPI with PDA signer seeds (privilege escalation / fund theft)",
      "description": "What: The program accepts token_metadata_program as an UncheckedAccount (no program id validation) and then performs a CPI to it (create_metadata_accounts_v3) while passing the bonding_curve PDA signer seeds (mint_auth_signer_seeds). The called program therefore receives a PDA as a signer for that CPI.\n\nWhere: Account declaration in CreateBondingCurve struct: `token_metadata_program: UncheckedAccount<'info>`, and in CreateBondingCurve::intialize_meta() where create_metadata_accounts_v3(...) is invoked (intialize_meta()).\n\nWhy it's a security issue: Because the code does not require that the provided token_metadata_program account is the canonical Metaplex Token Metadata program id (mpl_token_metadata::ID). An attacker can substitute any program id under their control. That malicious program will be invoked with signer authority for the bonding_curve PDA (the same signer seeds are passed). With that signer privilege the malicious program can call other programs (for example the SPL Token program) using invoke_signed to impersonate the bonding_curve PDA and perform privileged actions such as minting tokens, transferring tokens, changing authorities, or otherwise manipulating accounts that expect the PDA to sign. The runtime allows an invoked program to use invoke_signed with arbitrary seeds (the invoked program itself can create signed CPIs) \u2014 so passing signer seeds into a program you do not trust is equivalent to giving it the PDA private key for the duration of the CPI.\n\nPotential impact:\n- Attacker-provided program could mint arbitrary tokens from the mint (increase supply) or transfer tokens out of the bonding_curve token account.\n- Attacker could change mint authorities or freeze authorities to steal control of the mint.\n- Attacker could manipulate or drain any accounts passed into the CPI (mint, bonding_curve_token_account, bonding_curve PDA, etc.).\n- Loss of funds, permanent loss of mint control, or theft of token supply.\n\nVulnerability type: Privilege escalation / arbitrary CPI (insecure program id validation) enabling signer-seed misuse\nSeverity: critical\nConfidence: 0.95\nLocation: CreateBondingCurve struct field `token_metadata_program: UncheckedAccount<'info>` and CreateBondingCurve::intialize_meta() -> call to create_metadata_accounts_v3(...)",
      "vulnerability_type": "other",
      "severity": "medium",
      "confidence": 0.5,
      "location": "unknown",
      "file": "create_bonding_curve.rs",
      "id": "0c81e945c1c50a34",
      "reported_by_model": "gpt-5-mini",
      "status": "proposed"
    },
    {
      "title": "Other program accounts (system_program, associated_token_program, rent) are unchecked and can be substituted by attacker",
      "description": "What: Several accounts passed into CPIs are declared as UncheckedAccount instead of the strongly-typed Program<'info, ...> types or otherwise validated: system_program, associated_token_program, rent (and also token_metadata_program as above). These accounts are then forwarded into the metadata CPI (and possibly other CPIs).\n\nWhere: Account declarations in CreateBondingCurve struct: `system_program: UncheckedAccount<'info>`, `associated_token_program: UncheckedAccount<'info>`, `rent: UncheckedAccount<'info>`; used in intialize_meta() where they are provided to the CPI.\n\nWhy it's a security issue: If an attacker can substitute these program accounts with addresses of malicious programs, those programs will be invoked by the CPI with the supplied accounts. Even if the actual token metadata program is correct, passing a malicious system/associated/rent program could cause the CPI to fail or \u2014 when combined with the unchecked token_metadata_program \u2014 allow further malicious behavior. At minimum, having unvalidated program ids increases attack surface and may allow an attacker to trick the code into invoking a malicious program that can misuse signer privileges or manipulate accounts.\n\nPotential impact:\n- Arbitrary code execution in CPIs leading to theft or corruption of funds or accounts.\n- Denial of Service (CPI failing or malicious program intentionally failing or corrupting state).\n\nVulnerability type: Insecure program id / account validation (arbitrary CPI target)\nSeverity: high\nConfidence: 0.9\nLocation: CreateBondingCurve struct fields `system_program`, `associated_token_program`, `rent`, and usage in CreateBondingCurve::intialize_meta()",
      "vulnerability_type": "other",
      "severity": "medium",
      "confidence": 0.5,
      "location": "unknown",
      "file": "create_bonding_curve.rs",
      "id": "4f7907f9fb954946",
      "reported_by_model": "gpt-5-mini",
      "status": "proposed"
    },
    {
      "title": "Metadata account not validated as canonical metadata PDA for mint (unchecked metadata account)",
      "description": "What: The metadata account is declared as `metadata: UncheckedAccount<'info>` with a comment \"Using seed to validate metadata account\", but no seeds/constraint attribute is present in the accounts struct. The program does not validate that the supplied metadata account matches the expected Metaplex metadata PDA derived from the mint.\n\nWhere: Account declaration in CreateBondingCurve struct: `#[account(mut)] ///CHECK: Using seed to validate metadata account metadata: UncheckedAccount<'info>`, and used in intialize_meta() when passed to create_metadata_accounts_v3.\n\nWhy it's a security issue: Without verifying that the metadata account equals the canonical PDA for (metadata program, mint), a caller could supply an arbitrary account. Depending on the token metadata program behavior and whether the token metadata program id is validated, this can lead to:\n- CPI failure (DoS) if account doesn't match the metadata PDA expected by the metadata program.\n- If combined with a malicious token_metadata_program (see first finding), it allows that program to create or overwrite metadata at an arbitrary address or to manipulate accounts not intended by this instruction.\n\nPotential impact:\n- Transaction/flow DoS if CPIs fail or are misrouted.\n- In conjunction with an unchecked token_metadata_program, allow manipulation of arbitrary accounts (loss of funds or corruption of metadata state).\n\nVulnerability type: Insufficient account validation (PDA/account verification)\nSeverity: medium\nConfidence: 0.80\nLocation: CreateBondingCurve struct field `metadata: UncheckedAccount<'info>` and CreateBondingCurve::intialize_meta()",
      "vulnerability_type": "other",
      "severity": "medium",
      "confidence": 0.5,
      "location": "unknown",
      "file": "create_bonding_curve.rs",
      "id": "4f1c377ff484c73b",
      "reported_by_model": "gpt-5-mini",
      "status": "proposed"
    },
    {
      "title": "Swapped boolean ordering for remaining account flags in CPI builder (is_writable vs is_signer)",
      "description": "What the vulnerability is:\nThere is an inconsistency / accidental swap in the order of the boolean flags for remaining accounts between the CPI builder helper (AddWlCpiBuilder.add_remaining_account / add_remaining_accounts) and the code that constructs AccountMeta entries passed to program::invoke (AddWlCpi::invoke_signed_with_remaining_accounts). The builder API accepts tuples with the shape (account, is_writable, is_signer) but the invocation code interprets the tuple as (account, is_signer, is_writable).\n\nWhere it occurs:\n- AddWlCpiBuilder::add_remaining_account (and add_remaining_accounts) \u2014 pushes tuples using order (account, is_writable, is_signer).\n- AddWlCpi::invoke_signed_with_remaining_accounts \u2014 iterates remaining_accounts and uses remaining_account.1 as is_signer and remaining_account.2 as is_writable when building AccountMeta.\n\nWhy it's a security issue:\nBecause the writable and signer flags are swapped, the resulting Instruction will likely have wrong permissions for the provided remaining accounts. That can cause:\n- Accounts that were intended to be marked writable to instead be marked as signer-only in the instruction metadata, causing the invoked program to require a signature or to fail at runtime (missing required signature) \u2014 leading to denial-of-service (DoS) for valid flows.\n- Accounts that were intended to be signers to be marked writable instead, enabling the invoked program to mutate accounts that should not have been writable under the caller's assumptions. If an attacker supplies an account as a remaining account and the code marks it writable (while the caller thought it was only a signer), the invoked program may be able to modify that account unexpectedly.\n- In general, incorrect meta flags can enable privilege escalation (unauthorized modification of accounts) or transaction failures (DoS).\n\nPotential impact:\n- Denial of service: legitimate CPI calls may fail because an account expected to be a signer is not marked as such (or vice-versa).\n- Unauthorized account modification: an account unintentionally marked writable might be modified by the invoked program, possibly leading to loss/corruption of state or funds depending on the account's purpose.\n- Signature verification bypass or unexpected requirements that break downstream logic.\n\nVulnerability type: Incorrect permission handling / account meta mismatch (leading to possible privilege escalation and DoS)\nSeverity: high\nConfidence: 0.95\nlocation: \"AddWlCpiBuilder::add_remaining_account / add_remaining_accounts (push tuple as (account, is_writable, is_signer)) and AddWlCpi::invoke_signed_with_remaining_accounts (interprets tuple as (account, is_signer, is_writable))\"",
      "vulnerability_type": "other",
      "severity": "medium",
      "confidence": 0.5,
      "location": "unknown",
      "file": "add_wl.rs",
      "id": "db1427235ef6bf2c",
      "reported_by_model": "gpt-5-mini",
      "status": "proposed"
    },
    {
      "title": "Use of unwrap() on serialization results in instruction building (panic -> transaction abort / DoS)",
      "description": "What the vulnerability is:\nThe code uses try_to_vec().unwrap() when serializing the instruction discriminator and args in multiple places (client builder and CPI invocation). If serialization were to fail for any unexpected reason, the unwrap() will cause a panic (abort) rather than returning a recoverable error.\n\nWhere it occurs:\n- AddWl::instruction_with_remaining_accounts: let mut data = AddWlInstructionData::new().try_to_vec().unwrap(); let mut args = args.try_to_vec().unwrap();\n- AddWlCpi::invoke_signed_with_remaining_accounts: let mut data = AddWlInstructionData::new().try_to_vec().unwrap(); let mut args = self.__args.try_to_vec().unwrap();\n\nWhy it's a security issue:\nA panic during instruction construction or CPI invocation will abort the current program execution and revert the transaction state. If an attacker can cause the serializer to fail (for example via malformed input in environments where serialization could fail), this becomes a vector for denial-of-service against the instruction or the parent program performing the CPI. On-chain panics may have broader availability implications depending on how the program is used.\n\nPotential impact:\n- Denial of service: aborted transactions when serialization unexpectedly fails.\n- In the context of CPIs, a panic in the callee could also abort the caller program flow.\n\nVulnerability type: Panic / error handling (DoS)\nSeverity: medium\nConfidence: 0.6\nlocation: \"AddWl::instruction_with_remaining_accounts and AddWlCpi::invoke_signed_with_remaining_accounts \u2014 calls to try_to_vec().unwrap()\"",
      "vulnerability_type": "other",
      "severity": "medium",
      "confidence": 0.5,
      "location": "unknown",
      "file": "add_wl.rs",
      "id": "b0d29264721e475b",
      "reported_by_model": "gpt-5-mini",
      "status": "proposed"
    },
    {
      "title": "No account owner or discriminator verification when deserializing Global",
      "description": "The implementations of Global::from_bytes (fn from_bytes) and TryFrom<AccountInfo> for Global (fn try_from) call Self::deserialize on raw account data without verifying that the account is actually the expected Global account. They do not:\n- Check the account owner (that the account is owned by the expected program id), nor\n- Verify a canonical account discriminator/tag (even though the struct contains a discriminator field, there is no check that the first 8 bytes equal the expected discriminator).\n\nWhere it occurs:\n- Global::from_bytes(data: &[u8]) -> Self::deserialize(&mut data)\n- impl TryFrom<&AccountInfo> for Global, fn try_from(account_info) { let data = &*account_info.data.borrow(); Self::deserialize(&mut data) }\n\nWhy it's a security issue:\nIf higher-level code uses these helpers and then trust fields of the returned Global (such as global_authority, fee_receiver, migration_authority or various fee/reserve parameters) to make authorization or funds movement decisions, an attacker can provide (or point to) an account they control containing crafted data that deserializes into a Global instance. Without owner/discriminator checks the program may accept and act on attacker-controlled values as if they were authoritative. This can lead to unauthorized actions (e.g., funds sent to attacker-controlled fee_receiver or authority transfer), privilege escalation, or protocol manipulation.\n\nPotential impact:\n- Unauthorized transfer of funds (if fee_receiver or authority fields are used to route funds).\n- Bypassing access controls or enforcing arbitrary parameters (fees, allocations, supply values).\n- Complete protocol manipulation if the Global struct drives core logic.\n\nvulnerability_type: \"access control / input validation\"\nseverity: \"critical\"\nconfidence: 0.95\nlocation: \"Global::from_bytes() and impl TryFrom<&AccountInfo> for Global (try_from)\"",
      "vulnerability_type": "other",
      "severity": "medium",
      "confidence": 0.5,
      "location": "unknown",
      "file": "global.rs",
      "id": "76973f921bfca3e3",
      "reported_by_model": "gpt-5-mini",
      "status": "proposed"
    },
    {
      "title": "No account size validation against expected LEN before deserialization",
      "description": "The code defines a constant Global::LEN = 195 (intended serialized length) but neither Global::from_bytes nor TryFrom::try_from verify that account data length matches or is at least the expected size before calling deserialization. They simply pass the raw data slice into the deserializer.\n\nWhere it occurs:\n- Global::from_bytes(data: &[u8])\n- impl TryFrom<&AccountInfo> for Global::try_from\n\nWhy it's a security issue:\nIf the program later allocates or expects accounts to be exactly LEN bytes and uses this LEN elsewhere for access control or writes, mismatches between the actual on-chain account size and the expected LEN can cause unexpected behaviour. Examples:\n- If LEN is underestimated and code elsewhere writes the full struct into an account allocated smaller than required, writes may fail or cause other account writes to be truncated/incorrect.\n- If code accepts smaller accounts and deserialization partially succeeds, subsequent logic may read uninitialized or attacker-controlled data in missing fields.\n\nPotential impact:\n- Data corruption or inconsistent state.\n- Denial of service (failed writes or panics).\n- Exploitation of mismatched assumptions to influence program logic.\n\nvulnerability_type: \"input validation / data validation\"\nseverity: \"high\"\nconfidence: 0.9\nlocation: \"Global::LEN constant and use (or lack thereof) in Global::from_bytes() and TryFrom::try_from()\"",
      "vulnerability_type": "other",
      "severity": "medium",
      "confidence": 0.5,
      "location": "unknown",
      "file": "global.rs",
      "id": "198c0f048095b7db",
      "reported_by_model": "gpt-5-mini",
      "status": "proposed"
    },
    {
      "title": "Potential serialization incompatibility between feature modes (Anchor vs Borsh) without validation",
      "description": "The struct uses conditional compilation to derive AnchorSerialize/AnchorDeserialize when feature \"anchor\" is enabled and BorshSerialize/BorshDeserialize otherwise. The same struct contains an explicit discriminator field (8 bytes). Anchor and Borsh serialization formats may differ in layout or implicit discriminators for Anchor accounts. The code does not validate or assert which serialization format is expected when deserializing raw data.\n\nWhere it occurs:\n- struct Global (derive attributes controlled by cfg(feature = \"anchor\"))\n- Global::from_bytes and TryFrom::try_from always call Self::deserialize on the raw bytes without ensuring the serialization mode matches how the data was written on-chain.\n\nWhy it's a security issue:\nIf a program (or an upgraded program) writes the account data using one serialization mode (Anchor vs plain Borsh) but some clients or validators read it using the other mode, fields may be deserialized incorrectly. This may lead to incorrect authority addresses, fee amounts, or other critical parameters being interpreted and later trusted, enabling attackers to manipulate behavior by crafting data appropriate for the unexpected format.\n\nPotential impact:\n- Misinterpretation of critical parameters (authorities, receivers, amounts).\n- Unauthorized actions or funds diversion due to wrong addresses being read.\n- Hard-to-detect logic errors or DoS due to unexpected values.\n\nvulnerability_type: \"serialization incompatibility / data validation\"\nseverity: \"medium\"\nconfidence: 0.7\nlocation: \"Struct derives (cfg feature anchor vs not) and Global::from_bytes()/TryFrom::try_from()\"",
      "vulnerability_type": "other",
      "severity": "medium",
      "confidence": 0.5,
      "location": "unknown",
      "file": "global.rs",
      "id": "dc69a7d782e32f2f",
      "reported_by_model": "gpt-5-mini",
      "status": "proposed"
    },
    {
      "title": "Authority transfer without acceptance \u2014 new authority not required to sign",
      "description": "What the vulnerability is:\n- The instruction allows the current global authority to set new authority addresses via UncheckedAccount fields (new_authority and new_migration_authority) without requiring the provided new authority to sign or otherwise accept the transfer.\n\nWhere it occurs:\n- handler() in SetParams (the code that builds GlobalAuthorityInput from ctx.accounts.new_authority / new_migration_authority and calls global.update_authority).\n- Specifically: the blocks that compute global_authority: if let Some(new_authority) = ctx.accounts.new_authority.as_ref() { Some(*new_authority.key) } ... and migration_authority similarly, then global.update_authority(...) is called.\n\nWhy it's a security issue:\n- A transfer of administrative authority that does not require the recipient to accept or prove control is a risky operation. While the instruction itself can only be invoked by the current authority signer (so an attacker cannot call it directly without compromising the authority key), a malicious or compromised client UI, social engineering, or a compromised authority key can result in the authority being set to an address the attacker controls or to an address that cannot sign (a PDA or the zero address). The contract provides no safety checks (e.g., requiring the new authority to be a signer or to pre-approve the transfer) to prevent accidental or coerced misconfiguration.\n\nPotential impact:\n- If the current authority (or a compromised UI) sets the authority to a program-derived address (PDA) or another address with no private key, further privileged actions requiring the authority signer may become impossible to perform, resulting in permanent loss of administrative control (DoS). That could lock funds, prevent upgrades/withdrawals, or otherwise cripple protocol functionality. If set to an attacker-controlled key, the attacker gains immediate control over privileged operations and can steal or re-route funds.\n\nVulnerability type: Access control (authority transfer / improper authorization checks)\nSeverity level: high\nConfidence level: 0.95\nLocation: handler() in SetParams (uses ctx.accounts.new_authority / new_migration_authority and calls global.update_authority)",
      "vulnerability_type": "other",
      "severity": "medium",
      "confidence": 0.5,
      "location": "unknown",
      "file": "set_params.rs",
      "id": "16056acd504edc43",
      "reported_by_model": "gpt-5-mini",
      "status": "proposed"
    },
    {
      "title": "UncheckedAccount inputs are not validated (any pubkey accepted) \u2014 allows setting authority to invalid/unsafe addresses",
      "description": "What the vulnerability is:\n- new_authority and new_migration_authority are declared as Option<UncheckedAccount> and there are no additional runtime checks on the supplied account keys (owner program, non-zero, not a PDA, etc.). The code simply reads the public key and assigns it as the new authority.\n\nWhere it occurs:\n- handler() in SetParams when constructing GlobalAuthorityInput from ctx.accounts.new_authority.as_ref() and ctx.accounts.new_migration_authority.as_ref(), and subsequently in global.update_authority.\n\nWhy it's a security issue:\n- Accepting arbitrary public keys without validation lets the current authority set the authority to unexpected addresses: the zero/invalid address, program ids, PDAs that have no signer, or addresses that are not intended to be authority accounts. There is no defensive validation (e.g., reject Pubkey::default(), require the target to be owned by the system program, or require the target to be a signer in this instruction when performing a transfer).\n\nPotential impact:\n- Setting authority to Pubkey::default() or a PDA that cannot sign can permanently lock administrative functions (denial-of-service) and may result in funds or state being irrecoverable. Setting the authority to a program id or other unexpected address could break assumptions elsewhere in the program and allow an attacker (or simply make it impossible) to perform privileged operations. Even if only accidental, such misconfiguration can have catastrophic consequences.\n\nVulnerability type: Improper input validation / access control\nSeverity level: medium\nConfidence level: 0.9\nLocation: handler() in SetParams (reading ctx.accounts.new_authority / new_migration_authority and passing keys into global.update_authority)",
      "vulnerability_type": "other",
      "severity": "medium",
      "confidence": 0.5,
      "location": "unknown",
      "file": "set_params.rs",
      "id": "204497a9f4583d72",
      "reported_by_model": "gpt-5-mini",
      "status": "proposed"
    },
    {
      "title": "Swapped is_writable / is_signer flags for remaining accounts in CPI path",
      "description": "There is a mismatch in the ordering of the boolean flags for remaining accounts between the CPI builder and the CPI invocation.\n\nWhat the vulnerability is:\n- RemoveWlCpiBuilder::add_remaining_account (and add_remaining_accounts) push tuples in the form (AccountInfo, is_writable, is_signer).\n- RemoveWlCpi::invoke_signed_with_remaining_accounts expects remaining_accounts tuples in the form (AccountInfo, <is_signer>, <is_writable>) and constructs AccountMeta with is_signer = tuple.1 and is_writable = tuple.2.\n\nWhere it occurs:\n- RemoveWlCpiBuilder::add_remaining_account / add_remaining_accounts (they push tuples as (account, is_writable, is_signer)).\n- RemoveWlCpi::invoke_signed_with_remaining_accounts (it iterates remaining_accounts and builds AccountMeta with is_signer = remaining_account.1 and is_writable = remaining_account.2).\n\nWhy it's a security issue:\n- Because the two pieces treat the boolean order differently, the produced AccountMeta flags for remaining accounts are swapped relative to the intended flags. This results in the invoked program receiving incorrect signer and writable metadata for these accounts.\n\nPotential impact:\n- Denial of Service: legitimate calls may fail because an account that needs to be marked as signer/writable is not, causing the runtime or invoked program to reject the CPI.\n- Privilege misuse / authorization bypass: an account that was intended to be non-signer might be marked as signer (and vice versa). Depending on how the invoked program enforces authorization, this could enable an attacker to satisfy signer checks with an unintended account or cause logic to accept an account as writable when it shouldn't be.\n- Data corruption or fund loss: if writable flags are incorrect, the invoked program may not be able to mutate required accounts (causing failure) or might treat the wrong accounts as writable and mutate them unexpectedly, leading to corrupted state or funds being moved inappropriately.\n\nAdditional notes:\n- This bug exists in the CPI invocation path and affects any usage that relies on add_remaining_account/add_remaining_accounts for passing extra accounts.\n\nRecommendation (not required but helpful):\n- Make the tuple ordering consistent. Either change the builder to store (AccountInfo, is_signer, is_writable) or change the invocation to interpret the tuple as (AccountInfo, is_writable, is_signer). Prefer explicit types or small struct for remaining-account entries to avoid positional mistakes.",
      "vulnerability_type": "access control / incorrect account meta flags (CPI parameter handling)",
      "severity": "high",
      "confidence": 0.95,
      "location": "RemoveWlCpiBuilder::add_remaining_account / add_remaining_accounts and RemoveWlCpi::invoke_signed_with_remaining_accounts",
      "file": "remove_wl.rs",
      "id": "69cd53b6c5c8fe5d",
      "reported_by_model": "gpt-5-mini",
      "status": "proposed"
    },
    {
      "title": "Insufficient account validation allows freezing/thawing of arbitrary token accounts",
      "description": "What the vulnerability is:\nThe lock_ata() and unlock_ata() methods call the SPL Token program's freeze_account and thaw_account CPIs against bonding_curve_token_account using the provided mint and bonding_curve authority PDA signer seeds, but the code in this file performs no checks that the provided token account actually is the associated (or expected) token account for the provided mint or that it is owned by the SPL Token program.\n\nWhere it occurs:\n- lock_ata() (function body calling token::freeze_account)\n- unlock_ata() (function body calling token::thaw_account)\n\nWhy it's a security issue:\nIf the surrounding call-site (instruction account validation) does not enforce that bonding_curve_token_account is the token account for the given mint and that the bonding_curve PDA is legitimately set as the freeze authority of that mint, an attacker who can supply arbitrary accounts could cause the program's PDA to freeze or thaw token accounts that were not intended (or cause freezes to fail in unexpected ways). This can be used to freeze victims' token accounts (denial-of-service against token transfers for those accounts) or to manipulate token state unexpectedly.\n\nPotential impact:\n- Denial of Service: legitimate token holders may find their token accounts frozen and unable to transfer tokens.\n- Unexpected state changes to token accounts outside the intended scope of the bonding curve (loss of availability or disruption of other protocols/users).\n\nVulnerability type: access control / insufficient account validation\nSeverity: high\nConfidence: 0.80\nLocation: lock_ata() and unlock_ata() functions (freeze_account / thaw_account CPI calls)",
      "vulnerability_type": "other",
      "severity": "medium",
      "confidence": 0.5,
      "location": "unknown",
      "file": "locker.rs",
      "id": "2c3ff0936b7c4aae",
      "reported_by_model": "gpt-5-mini",
      "status": "proposed"
    },
    {
      "title": "Irreversible revocation of mint or freeze authority with no safe-guards",
      "description": "What the vulnerability is:\nThe revoke_mint_authority() and revoke_freeze_authority() functions call token::set_authority with AuthorityType::MintTokens and AuthorityType::FreezeAccount, and pass None as the new authority. That permanently clears the authority on the mint (or the freeze authority stored in the mint) and is irreversible via these same ops.\n\nWhere it occurs:\n- revoke_mint_authority() (token::set_authority with AuthorityType::MintTokens, None)\n- revoke_freeze_authority() (token::set_authority with AuthorityType::FreezeAccount, None)\n\nWhy it's a security issue:\nIf these revocation methods can be invoked by an unauthorized caller (or invoked inadvertently due to lack of higher-level validation), the mint will lose its minting ability and/or freeze authority permanently. There is no mechanism here to recover or rotate those authorities. This can break expected protocol behavior, prevent future minting of tokens, and lock contract functionality.\n\nPotential impact:\n- Permanent denial of functionality: inability to mint future tokens for the mint, inability to change freeze authority later.\n- Loss of protocol functionality and potential economic damage if minting is required for correct operation.\n- If invoked by an attacker, may be used as a cheap DoS or sabotage vector.\n\nVulnerability type: logic / privileged action / lack of safeguards\nSeverity: high\nConfidence: 0.90\nLocation: revoke_mint_authority() and revoke_freeze_authority() functions (token::set_authority calls)",
      "vulnerability_type": "other",
      "severity": "medium",
      "confidence": 0.5,
      "location": "unknown",
      "file": "locker.rs",
      "id": "e3c2c3023afa947d",
      "reported_by_model": "gpt-5-mini",
      "status": "proposed"
    },
    {
      "title": "Signer seeds / PDA usage not verified against bonding_curve account",
      "description": "What the vulnerability is:\nget_signer() derives signer seeds using the provided mint account key and bonding_curve_bump and then these seeds are used to sign CPIs expecting the bonding_curve PDA to be the authority. However the code in this file does not validate that the bonding_curve Account<'info, BondingCurve> passed into the context is actually the PDA that corresponds to those seeds. The functions simply build signer_seeds from the mint and bump and call CPI with that signer.\n\nWhere it occurs:\n- BondingCurveLockerCtx::get_signer()\n- Used in lock_ata(), unlock_ata(), revoke_mint_authority(), revoke_freeze_authority() when creating signer_seeds and calling CPIs\n\nWhy it's a security issue:\nIf the bonding_curve account passed into the instruction does not equal the PDA derived from the supplied mint and bump (for example because account validation at the instruction level is missing or incorrect), then either:\n- The CPI will fail (no signer for the provided current_authority), or\n- Worse, if an attacker can craft inputs so that the PDA derived from the attacker-controlled mint/bump matches a different account that the attacker can influence, the program could be made to sign for an unexpected PDA and perform sensitive ops (freeze/thaw/revoke) on a mint the attacker controls or otherwise manipulate authorities incorrectly.\n\nPotential impact:\n- Failed CPI causing denial of service of the intended operation.\n- If combined with missing or incorrect validation elsewhere, potential authority misuse: enabling calls that affect other mints/accounts controlled by an attacker.\n\nVulnerability type: signer derivation / insufficient PDA/account binding\nSeverity: medium\nConfidence: 0.70\nLocation: get_signer() and all functions that use its result (lock_ata(), unlock_ata(), revoke_mint_authority(), revoke_freeze_authority())",
      "vulnerability_type": "other",
      "severity": "medium",
      "confidence": 0.5,
      "location": "unknown",
      "file": "locker.rs",
      "id": "8059cc177418d671",
      "reported_by_model": "gpt-5-mini",
      "status": "proposed"
    },
    {
      "title": "No explicit check that token_program account is the real SPL Token program",
      "description": "What the vulnerability is:\nThe CPIs use self.token_program.to_account_info() as the program id to call into token::freeze_account, thaw_account, and set_authority. This file itself doesn't validate the program id. If the broader instruction/account constraints are missing or incorrect, a malicious program account could be passed in here, causing the program to call into a malicious token-like contract.\n\nWhere it occurs:\n- All CPI calls in lock_ata(), unlock_ata(), revoke_mint_authority(), revoke_freeze_authority() (the Program< Token > reference is used as the CPI program)\n\nWhy it's a security issue:\nIf an attacker is able to supply a malicious token_program account (i.e., not the real SPL Token program), CPIs could call arbitrary code controlled by the attacker, leading to arbitrary state changes and theft. Anchor's Program<T> type normally enforces the program id, but that validation happens via Anchor account constraints at the instruction level; this file does not itself enforce it.\n\nPotential impact:\n- Arbitrary code execution via CPI to a malicious program leading to loss of funds, theft, or other severe compromises if account validation outside this file is missing or bypassable.\n\nVulnerability type: CPI program validation / external-call trust\nSeverity: high\nConfidence: 0.60\nLocation: All CPI invocations (token::freeze_account, token::thaw_account, token::set_authority) in lock_ata(), unlock_ata(), revoke_mint_authority(), revoke_freeze_authority()",
      "vulnerability_type": "other",
      "severity": "medium",
      "confidence": 0.5,
      "location": "unknown",
      "file": "locker.rs",
      "id": "71017c433fd57cf0",
      "reported_by_model": "gpt-5-mini",
      "status": "proposed"
    },
    {
      "title": "Missing account owner check when deserializing account data",
      "description": "What the vulnerability is:\n- The TryFrom implementation for Whitelist deserializes account data directly from any provided AccountInfo without verifying the account's owner (i.e., program id) or that the account is an expected program account.\n\nWhere it occurs:\n- impl<'a> TryFrom<&solana_program::account_info::AccountInfo<'a>> for Whitelist -> try_from(account_info: &AccountInfo)\n- File: whitelist.rs, in the TryFrom::try_from implementation\n\nWhy it's a security issue:\n- Accepting and interpreting data from an arbitrary account (including attacker-controlled accounts) allows an attacker to craft account data that deserializes to a valid Whitelist struct. If other program logic uses Whitelist::try_from(account_info) as an authorization/authentication step (for example to check that an account is a legitimate whitelist account or to obtain the 'creator' Pubkey for permission checks), an attacker can bypass those checks by providing a malicious account that deserializes to desired values.\n\nPotential impact:\n- Privilege escalation / authentication bypass: an attacker could impersonate a whitelist account, enabling unauthorized actions such as bypassing minting whitelist checks, draining or redirecting funds, or performing privileged protocol operations that rely on the Whitelist data.\n\nVulnerability type: access control / authentication bypass (insufficient account validation)\nSeverity: high\nConfidence: 0.95\nLocation: try_from() function in TryFrom impl (whitelist.rs)",
      "vulnerability_type": "other",
      "severity": "medium",
      "confidence": 0.5,
      "location": "unknown",
      "file": "whitelist.rs",
      "id": "5d8cfd3cec7cc911",
      "reported_by_model": "gpt-5-mini",
      "status": "proposed"
    },
    {
      "title": "No discriminator validation when deserializing Whitelist data",
      "description": "What the vulnerability is:\n- The Whitelist struct contains a discriminator field ([u8; 8]) but the from_bytes and TryFrom deserialization paths do not validate that the first 8 bytes match an expected type discriminator constant. They simply deserialize whatever is in the account data into the struct fields.\n\nWhere it occurs:\n- Whitelist::from_bytes(data: &[u8]) and impl TryFrom<AccountInfo>::try_from(...) both call Self::deserialize(&mut data) without checking the discriminator value.\n\nWhy it's a security issue:\n- Discriminator bytes are commonly used to ensure the account data corresponds to the expected account type. Without checking the discriminator, arbitrary account data (or a different account type that happens to decode) can be accepted as a Whitelist. This enables type confusion or spoofing attacks where an attacker can craft account data that deserializes into a Whitelist with arbitrary 'creator' Pubkey.\n\nPotential impact:\n- Similar to the missing owner check, this can lead to unauthorized access and privilege escalation: downstream logic that trusts the discriminator to confirm the account's type may be bypassed, allowing attackers to impersonate whitelist entries and potentially manipulate protocol flows or approvals.\n\nVulnerability type: improper input validation / type confusion\nSeverity: high\nConfidence: 0.95\nLocation: from_bytes() and try_from() deserialization paths (whitelist.rs)",
      "vulnerability_type": "other",
      "severity": "medium",
      "confidence": 0.5,
      "location": "unknown",
      "file": "whitelist.rs",
      "id": "d887f64ba88084f9",
      "reported_by_model": "gpt-5-mini",
      "status": "proposed"
    },
    {
      "title": "Use of unwrap() on instruction serialization (panic -> DoS)",
      "description": "What: The code serializes the instruction data with try_to_vec().unwrap() (LockPoolInstructionData::new().try_to_vec().unwrap()).\n\nWhere: LockPool::instruction_with_remaining_accounts() and LockPoolCpi::invoke_signed_with_remaining_accounts() (both call try_to_vec().unwrap()).\n\nWhy this is a security issue: unwrap() will panic if serialization fails. When this code executes in an on-chain program (CPI path), a panic aborts the program and fails the transaction. While serialization of a fixed-size small struct is unlikely to fail in practice, using unwrap() in code paths that may run on-chain can cause denial-of-service if some unexpected condition occurs (library change, memory issue, or malicious input triggering a serialization failure).\n\nPotential impact: Panic-induced transaction failure (DoS) for callers using the CPI helper or clients constructing the instruction at runtime in constrained contexts.\n\nVulnerability type: Panic / denial-of-service\nSeverity: low\nConfidence: 0.5\nLocation: LockPool::instruction_with_remaining_accounts() and LockPoolCpi::invoke_signed_with_remaining_accounts() where LockPoolInstructionData::new().try_to_vec().unwrap() is used",
      "vulnerability_type": "other",
      "severity": "medium",
      "confidence": 0.5,
      "location": "unknown",
      "file": "lock_pool.rs",
      "id": "3b2d61ec51dc4ee6",
      "reported_by_model": "gpt-5-mini",
      "status": "proposed"
    },
    {
      "title": "No discriminator/type validation when deserializing account data",
      "description": "What the vulnerability is:\nThe BondingCurve struct contains a discriminator field ([u8; 8]) but the provided deserialization helpers (from_bytes and TryFrom<AccountInfo>) do not validate the discriminator value before returning the parsed struct.\n\nWhere it occurs:\n- BondingCurve::from_bytes(data: &[u8])\n- impl TryFrom<&AccountInfo> for BondingCurve :: try_from(account_info: &AccountInfo)\n\nWhy it's a security issue:\nDeserializing arbitrary account data into a BondingCurve structure without verifying a known discriminator (or other type marker) enables type-confusion attacks. An attacker can craft account data (or supply an account not actually owned/initialized by the expected program) that decodes to a BondingCurve instance even though it is not the intended account type. Subsequent program logic that assumes the parsed struct genuinely represents a valid on-chain BondingCurve account may operate on attacker-controlled values (reserves, supply, start_slot, bump, etc.).\n\nPotential impact:\n- Unauthenticated or attacker-controlled data may be used in business logic, potentially causing incorrect accounting or movement of funds.\n- Logic that trusts fields like real_sol_reserves, real_token_reserves, token_total_supply or bump may be tricked into transferring or unlocking funds, producing loss of funds or incorrect state transitions.\n- Privilege escalation: callers may be able to bypass intended checks if code assumes a valid discriminator.\n\nvulnerability_type: \"type confusion / missing type validation\"\nseverity: \"high\"\nconfidence: 0.9\nlocation: \"BondingCurve::from_bytes and TryFrom<&AccountInfo>::try_from (file: bonding_curve.rs)\"",
      "vulnerability_type": "other",
      "severity": "medium",
      "confidence": 0.5,
      "location": "unknown",
      "file": "bonding_curve.rs",
      "id": "5cb43bd707feff02",
      "reported_by_model": "gpt-5-mini",
      "status": "proposed"
    },
    {
      "title": "No account owner / PDA validation when converting AccountInfo to BondingCurve",
      "description": "What the vulnerability is:\nThe TryFrom<AccountInfo> implementation deserializes the account data directly without checking the account's owner (account_info.owner) or verifying that the account address matches the expected PDA derived from seeds (PREFIX and mint). There is no check that the account is actually owned by the program (crate::PUMP_SCIENCE_ID) or that it is the PDA for the given mint.\n\nWhere it occurs:\n- impl TryFrom<&AccountInfo> for BondingCurve :: try_from(account_info: &AccountInfo)\n\nWhy it's a security issue:\nNot checking account ownership or PDA derivation allows callers to pass arbitrary accounts (including attacker-controlled accounts owned by other programs) that deserialize to a BondingCurve. Code that operates on the returned BondingCurve may assume the account is legitimate and then perform actions (state changes, token transfers, SOL transfers) based on that assumption. This is a common vector that leads to unauthorized access/control of funds or incorrect state transitions.\n\nPotential impact:\n- A malicious account, controlled by an attacker, can be used to trick program logic into approving transfers, unlocking reserves, or altering protocol behavior.\n- Loss of funds if functions later use data from the deserialized struct to compute or authorize transfers.\n- Denial of service or protocol manipulation by supplying crafted values (e.g., bump, start_slot, reserves) that cause incorrect flows.\n\nvulnerability_type: \"access control / missing ownership validation\"\nseverity: \"high\"\nconfidence: 0.9\nlocation: \"TryFrom<&AccountInfo>::try_from (file: bonding_curve.rs)\"",
      "vulnerability_type": "other",
      "severity": "medium",
      "confidence": 0.5,
      "location": "unknown",
      "file": "bonding_curve.rs",
      "id": "32fda6b192917a7b",
      "reported_by_model": "gpt-5-mini",
      "status": "proposed"
    },
    {
      "title": "Signer/Writable flags swapped for remaining_accounts in CPI path",
      "description": "What the vulnerability is:\nThe CPI builder accepts remaining accounts as tuples in the order (AccountInfo, is_writable, is_signer) but the CPI invocation code interprets the tuple as (AccountInfo, is_signer, is_writable). This results in the boolean flags being swapped when constructing AccountMeta for the invoked instruction.\n\nWhere it occurs:\n- InitializeCpiBuilder::add_remaining_account (pushes tuples as (account, is_writable, is_signer))\n- InitializeCpi::invoke_signed_with_remaining_accounts (iterates remaining_accounts and constructs AccountMeta using remaining_account.1 as is_signer and remaining_account.2 as is_writable)\n\nWhy it's a security issue:\nBecause the flags govern critical permissions for CPI invocations, the mismatch can cause the constructed instruction to request signer or writable status incorrectly for supplied accounts. The runtime enforces these flags against the provided AccountInfo objects; mismatches can cause the CPI to fail or to grant/deny write or signer capabilities in ways the caller did not intend.\n\nPotential impact:\n- Denial of Service: legitimate CPI calls may fail due to incorrect signer/writable requirements, causing transaction failures.\n- Incorrect permission model: an account intended to be writable may be marked non-writable (preventing expected state changes), or an account intended to be non-signer may be requested as signer causing failures. In some scenarios, incorrect flags could enable unexpected writable access to accounts (if external caller supplies AccountInfo with different writability), potentially allowing unauthorized state mutation depending on how the target program uses the account.\n\nVulnerability type: Incorrect flag handling / logical bug leading to access-control mismatch\nSeverity: high\nConfidence: 0.95\nLocation: InitializeCpiBuilder::add_remaining_account() and InitializeCpi::invoke_signed_with_remaining_accounts() (mismatch between tuple ordering and usage)",
      "vulnerability_type": "other",
      "severity": "medium",
      "confidence": 0.5,
      "location": "unknown",
      "file": "initialize.rs",
      "id": "6427e66c6a519402",
      "reported_by_model": "gpt-5-mini",
      "status": "proposed"
    },
    {
      "title": "Use of unwrap()/expect for serialization and required fields may panic (DoS risk)",
      "description": "What the vulnerability is:\nThe code uses unwrap() and expect() in multiple places when serializing instruction data and when requiring mandatory builder fields. Examples:\n- Initialize::instruction_with_remaining_accounts: InitializeInstructionData::new().try_to_vec().unwrap(); args.try_to_vec().unwrap();\n- InitializeCpi::invoke_signed_with_remaining_accounts: same try_to_vec().unwrap() calls\n- InitializeBuilder::instruction and CPI builders: numerous .expect(\"... is not set\") calls when required fields are missing\n\nWhere it occurs:\n- Initialize::instruction_with_remaining_accounts (data and args serialization)\n- InitializeCpi::invoke_signed_with_remaining_accounts (data and args serialization)\n- InitializeBuilder::instruction (expect on missing builder fields)\n- InitializeCpiBuilder::invoke_signed (expect on missing builder fields)\n\nWhy it's a security issue:\nOn-chain panics (caused by unwrap/expect) cause the program to return an error and abort the execution. An attacker or malformed input could trigger these unwrap/expect failures (for example, providing invalid data that causes serialization to fail, or causing a code path where required fields are not set). This results in a denial-of-service (DoS) for the instruction.\n\nPotential impact:\n- Denial of Service: causing the program or CPI call to abort and fail transactions.\n- Unexpected program termination leading to inability to perform intended state updates or refunds, potentially locking user funds until callers fix inputs.\n\nVulnerability type: Panic leading to Denial of Service (input validation / error handling issue)\nSeverity: medium\nConfidence: 0.80\nLocation: Multiple places \u2014 Initialize::instruction_with_remaining_accounts(), InitializeCpi::invoke_signed_with_remaining_accounts(), InitializeBuilder::instruction(), InitializeCpiBuilder::invoke_signed() (calls to try_to_vec().unwrap() and Option::expect())",
      "vulnerability_type": "other",
      "severity": "medium",
      "confidence": 0.5,
      "location": "unknown",
      "file": "initialize.rs",
      "id": "4c9501f301819fc4",
      "reported_by_model": "gpt-5-mini",
      "status": "proposed"
    }
  ],
  "token_usage": {
    "input_tokens": 94368,
    "output_tokens": 113538,
    "total_tokens": 207906
  }
}