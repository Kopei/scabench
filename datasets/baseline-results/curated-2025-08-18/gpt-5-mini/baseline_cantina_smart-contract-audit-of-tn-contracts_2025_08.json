{
  "project": "cantina_smart-contract-audit-of-tn-contracts_2025_08",
  "timestamp": "2025-08-29T05:48:21.213621",
  "files_analyzed": 27,
  "files_skipped": 0,
  "total_findings": 8,
  "findings": [
    {
      "title": "Unrestricted public deployment: create3Deploy allows anyone to deploy arbitrary code to deterministic addresses",
      "description": "What: The create3Deploy(...) function is declared public and forwards arbitrary contract init code and a salt to an externally-supplied Create3Deployer instance. (function: create3Deploy)\n\nWhere: create3Deploy(Create3Deployer create3Deployer, bytes memory contractCreationCode, bytes memory constructorArgs, bytes32 salt) \u2014 public function.\n\nWhy it's a security issue: There is no access control or authorization on who can call create3Deploy. An attacker can call this function, provide the canonical Create3Deployer contract (or any Create3Deployer-compatible contract), and deploy arbitrary bytecode at deterministic addresses derived from known salts. The salts used by the system (salts / implSalts) are public and predictable (keccak256 of fixed strings), so an adversary can pre-deploy malicious contracts at the addresses the system expects legitimate components to be, or otherwise occupy namespaced deterministic addresses before the intended deployment.\n\nPotential impact: Unauthorized deployment or front-running of expected system components. This can lead to takeover of expected addresses (causing funds sent to malicious contracts), privilege escalation (malicious implementations for proxy patterns), protocol disruption/DoS, or theft of assets that are routed to the wrong addresses. If the wider protocol assumes only the deployer will ever create those addresses, this lack of protection can cause severe compromise and funds loss.\n\nVulnerability type: Access control / authorization (enables front-running/takeover)\n\nSeverity: critical\n\nConfidence: 0.95\n\nLocation: create3Deploy(...) function in Create3Utils.sol",
      "vulnerability_type": "other",
      "severity": "medium",
      "confidence": 0.5,
      "location": "unknown",
      "file": "Create3Utils.sol",
      "id": "df42f9f5651c942c",
      "reported_by_model": "gpt-5-mini",
      "status": "proposed"
    },
    {
      "title": "Address prediction mismatch: create3Address takes arbitrary sender parameter that can differ from actual deployer",
      "description": "What: create3Address(...) computes the expected deployed address by calling create3Deployer.deployedAddress(contractInitCode, sender, salt) and accepts an arbitrary 'sender' parameter. However, create3Deploy(...) calls create3Deployer.deploy(contractInitCode, salt) without exposing/using a sender parameter; the deployer implementation may use msg.sender (the caller) when computing the actual address. If the 'sender' passed to create3Address does not match the actual sender used at deployment time, the returned expected address will be incorrect.\n\nWhere: create3Address(Create3Deployer create3Deployer, bytes memory contractCreationCode, bytes memory constructorArgs, address sender, bytes32 salt) \u2014 public function.\n\nWhy it's a security issue: Incorrectly predicted addresses can lead callers to assume a contract is deployed at an address when it is not, or to send funds/interact with the wrong address. Attackers can exploit mismatches to trick integrators into sending funds to attacker-controlled addresses or to believe a deployment occurred (or didn't) when the opposite is true. When address prediction is relied upon by other parts of the system (for pre-funding, registration, authorization checks), an incorrect sender parameter can produce wrong results with security consequences.\n\nPotential impact: Misrouting of funds, mistaken trust assumptions, failed deployments being interpreted as successful, and potential theft or loss of funds if callers act on incorrect address predictions.\n\nVulnerability type: Logic error / address prediction mismatch\n\nSeverity: medium\n\nConfidence: 0.80\n\nLocation: create3Address(...) function in Create3Utils.sol",
      "vulnerability_type": "other",
      "severity": "medium",
      "confidence": 0.5,
      "location": "unknown",
      "file": "Create3Utils.sol",
      "id": "756e34e76a9349ae",
      "reported_by_model": "gpt-5-mini",
      "status": "proposed"
    },
    {
      "title": "External call to untrusted Create3Deployer: potential reentrancy or DoS from deployer contract",
      "description": "What: create3Deploy(...) performs an external call to create3Deployer.deploy(...) on an externally-provided contract instance. That call transfers control to an arbitrary contract implementation.\n\nWhere: create3Deploy(Create3Deployer create3Deployer, ...) \u2014 the external call to create3Deployer.deploy.\n\nWhy it's a security issue: Calling an external, potentially untrusted contract can allow that contract to reenter (call back) into the caller contract or its inheritors, or to revert/consume gas and prevent progress. While this Create3Utils implementation does not modify its own state after the external call (so direct reentrancy here is limited), inheriting contracts or call sites might invoke create3Deploy as part of a larger sequence of operations where state is changed after the deploy call \u2014 in such cases a malicious Create3Deployer could reenter and manipulate state invariants. Also, a malicious or buggy deployer could always revert, causing a DoS on any deployment flow that relies on it.\n\nPotential impact: Reentrancy leading to state corruption in calling/inheriting contracts, denial of service of deployment flows, or unexpected revert behavior that breaks higher-level logic and can prevent legitimate deployments.\n\nVulnerability type: Reentrancy / external call to untrusted contract / DoS via revert\n\nSeverity: medium\n\nConfidence: 0.70\n\nLocation: External call create3Deployer.deploy(...) inside create3Deploy(...) function in Create3Utils.sol",
      "vulnerability_type": "other",
      "severity": "medium",
      "confidence": 0.5,
      "location": "unknown",
      "file": "Create3Utils.sol",
      "id": "d1b605962cc37383",
      "reported_by_model": "gpt-5-mini",
      "status": "proposed"
    },
    {
      "title": "Predictable, publicly-exposed salts enable precomputation and pre-deployment",
      "description": "What: The salts and implSalts structs are stored in public state and initialized from keccak256(static strings). Both the salt values and the method to compute deployment addresses are public and deterministic.\n\nWhere: Salts public salts = Salts({ ... }); ImplSalts public implSalts = ImplSalts({ ... });\n\nWhy it's a security issue: The salts are predictable (keccak256 of known identifiers) and the contract exposes them via public getters. This makes it trivial for an attacker to precompute deterministic addresses that the protocol expects to be used for critical components and pre-deploy malicious contracts at those addresses using create3. When combined with the public create3Deploy behavior (no access control), this greatly lowers the effort required to front-run legitimate deployments.\n\nPotential impact: Facilitates the primary attack path (unauthorized pre-deployment/front-running), enabling address takeover, funds theft, or replacement of expected components with malicious implementations.\n\nVulnerability type: Information disclosure / predictable deterministic addresses (enabler for front-running)\n\nSeverity: low to medium\n\nConfidence: 0.80\n\nLocation: salts and implSalts state variables in Create3Utils.sol",
      "vulnerability_type": "other",
      "severity": "medium",
      "confidence": 0.5,
      "location": "unknown",
      "file": "Create3Utils.sol",
      "id": "1c4355f7cbe5ddcc",
      "reported_by_model": "gpt-5-mini",
      "status": "proposed"
    },
    {
      "title": "Reentrancy via unbounded external call in mint()",
      "description": "What the vulnerability is:\nThe mint(address to, uint256 nativeAmount) function (onlyTokenManager) performs an external call to an arbitrary recipient using to.call{ value: nativeAmount }(\"\") before any further internal logic. Because that is an unbounded external call to a caller-controlled contract there is a reentrancy surface: the recipient can execute arbitrary code and call back into this contract during that call.\n\nWhere it occurs: mint(address to, uint256 nativeAmount) \u2014 the low-level external call to `to`.\n\nWhy it's a security issue:\n- External calls to untrusted recipients can allow reentrancy into public/external contract methods. Even if this particular function makes no state updates after the external call, the recipient can reenter other publicly accessible functions (doubleWrap, permitWrap, etc.) and manipulate contract state in ways that may be unexpected by the token manager flow. This can lead to accounting inconsistencies, unexpected token mints/unsettled records, or other state confusion that could be leveraged in complex attacks.\n- If assumptions by the Axelar token manager depend on deterministic contract behaviour (for example ordering of balances/records), reentrancy can cause protocol manipulation.\n\nPotential impact:\n- Unexpected/misordered state changes (records, balances) during bridging flows, leading to potential loss of funds, double-counting or logic races between minting and wrapping flows.\n- Denial of service of bridging if malicious recipient deliberately reverts or consumes gas.\n\nVulnerability type: reentrancy / unsafe external call\nSeverity: medium\nConfidence: 0.85\nlocation: \"mint(address,uint256) \u2014 low-level call to `to`\"}\n,{",
      "vulnerability_type": "other",
      "severity": "medium",
      "confidence": 0.5,
      "location": "unknown",
      "file": "InterchainTEL.sol",
      "id": "e84acd97fef2604e",
      "reported_by_model": "gpt-5-mini",
      "status": "proposed"
    },
    {
      "title": "Missing access control: public genesis/instantiate methods can overwrite target contracts' storage",
      "description": "What the vulnerability is:\n- Many functions in ITSGenesis are declared public and will (via helper functions) copy the storage/state of a freshly simulated deployment into preconfigured \"target\" contract addresses. Examples include instantiateAxelarAmplifierGatewayImpl, instantiateAxelarAmplifierGateway, instantiateTokenManagerDeployer, instantiateInterchainTokenImpl, instantiateInterchainTokenDeployer, instantiateTokenManagerImpl, instantiateTokenHandler, instantiateAxelarGasServiceImpl, instantiateAxelarGasService, instantiateGatewayCaller, instantiateITSImpl, instantiateITS, instantiateITFImpl, instantiateITF, instantiateWTEL, instantiateInterchainTEL, and instantiateInterchainTELTokenManager.\n\nWhere it occurs:\n- The public instantiate* functions throughout the file (e.g. instantiateAxelarAmplifierGateway(address impl), instantiateITS(address impl), instantiateAxelarGasService(address impl), instantiateInterchainTEL(address its_) etc.). Each of these calls copyContractState(...) to write into addresses held in state (gateway, its, gasService, iTEL, iTELTokenManager, etc.).\n\nWhy it's a security issue:\n- copyContractState and associated logic (saveWrittenSlots, vm state diff recording) perform low-level writes that transfer storage values from a simulated deployment contract into the configured target addresses. If these public functions are callable by any externally-owned account, an attacker can trigger simulation with chosen inputs and then copy arbitrary storage values into real production contracts. That can overwrite critical variables such as owner/admin addresses, implementation pointers, token manager links, balances, mint allowances, or other security-critical state in the target contracts.\n\nPotential impact:\n- Full compromise of target contracts: attacker could set themselves as owner/admin, change implementation addresses, enable minting/unlock tokens, or otherwise manipulate protocol-critical state. This can lead to immediate loss of funds, unauthorized minting/transfers, privilege escalation, and protocol takeover.\n\nNotes:\n- The risk is aggravated because several of the target addresses are core components (gateway, its, token managers, gas service, WTEL/iTEL manager) whose corruption can cause systemic failure.\n\n",
      "vulnerability_type": "access control / arbitrary storage write",
      "severity": "critical",
      "confidence": 0.95,
      "location": "instantiateAxelarAmplifierGatewayImpl(), instantiateAxelarAmplifierGateway(), instantiateTokenManagerDeployer(), instantiateInterchainTokenImpl(), instantiateInterchainTokenDeployer(), instantiateTokenManagerImpl(), instantiateTokenHandler(), instantiateAxelarGasServiceImpl(), instantiateAxelarGasService(), instantiateGatewayCaller(), instantiateITSImpl(), instantiateITS(), instantiateITFImpl(), instantiateITF(), instantiateWTEL(), instantiateInterchainTEL(), instantiateInterchainTELTokenManager()",
      "file": "ITSGenesis.sol",
      "id": "edeaf4c3466fc816",
      "reported_by_model": "gpt-5-mini",
      "status": "proposed"
    },
    {
      "title": "Use of Foundry vm cheatcodes (vm.startStateDiffRecording / vm.stopAndReturnStateDiff) in public functions \u2014 environment dependency and DoS risk",
      "description": "What the vulnerability is:\n- Several public functions call Foundry/forge 'vm' cheatcodes (vm.startStateDiffRecording(), vm.stopAndReturnStateDiff()) and then rely on the returned state diffs (e.g. instantiateAxelarAmplifierGateway, instantiateAxelarGasService, instantiateITS, instantiateITF, instantiateInterchainTEL, instantiateInterchainTELTokenManager). The contract imports forge-std/Test.sol to access vm.\n\nWhere it occurs:\n- instantiateAxelarAmplifierGateway(), instantiateAxelarGasService(), instantiateITS(), instantiateITF(), instantiateInterchainTEL(), instantiateInterchainTELTokenManager() (and any other functions that call vm.*).\n\nWhy it's a security issue:\n- The vm cheatcodes are available only in Foundry testing environments. If this contract (or derived contract) is compiled/deployed in a non-test/runtime environment (e.g., mainnet, testnet, other EVM), calls to vm.* may revert, behave unexpectedly, or otherwise break execution. Because the functions are public, an attacker may call the functions and cause reverts/failed executions that could be used to create a denial-of-service pattern for integration scripts or operators that expect these functions to behave or to be idempotent.\n- Additionally, reliance on test-only opcodes in code paths that perform state writes is dangerous: in some environments the calls might silently do nothing or revert unpredictably, producing inconsistent state being copied or partial writes.\n\nPotential impact:\n- Denial of service for operations that rely on these functions succeeding; inconsistent state setup or partial state copy could leave target contracts in a corrupted or unpredictable state. In the worst case, operators might believe genesis/setup has been completed while critical initialization failed.\n\n",
      "vulnerability_type": "environment dependency / denial of service",
      "severity": "medium",
      "confidence": 0.8,
      "location": "vm.startStateDiffRecording()/vm.stopAndReturnStateDiff() calls in instantiateAxelarAmplifierGateway(), instantiateAxelarGasService(), instantiateITS(), instantiateITF(), instantiateInterchainTEL(), instantiateInterchainTELTokenManager()",
      "file": "ITSGenesis.sol",
      "id": "52b888265fbddf0c",
      "reported_by_model": "gpt-5-mini",
      "status": "proposed"
    },
    {
      "title": "Incorrect balance validation before sending funds (under-check of total outgoing amount)",
      "description": "What it is:\n- The function distributeStakeReward(uint256 rewardAmount) validates the contract balance against rewardAmount only, but then attempts to send rewardAmount + msg.value to the recipient.\n\nWhere it occurs:\n- distributeStakeReward(...) function (distributeStakeReward, around its main balance check and send logic).\n\nWhy it's a security issue:\n- The contract checks: bal = address(this).balance; require(bal >= rewardAmount) but later computes totalAmount = rewardAmount + msg.value and sends totalAmount. Because msg.value is already included in address(this).balance, the intended intent is unclear; however the check should ensure the contract has at least totalAmount available. In certain states (for example when the contract's pre-call balance X is less than rewardAmount but X + msg.value >= rewardAmount) the check will pass while totalAmount > bal, causing the low-level call to attempt to send more Ether than the contract actually holds. The call will then fail and the function will revert with RewardDistributionFailure. This mismatch is a logical bug.\n\nPotential impact:\n- Denial-of-service during reward distribution: legitimate calls can revert unexpectedly causing stake reward flows to fail. If the caller (stakeManager) expects this call to succeed as part of a larger atomic flow, it can cause higher-level operations to fail. It also opens the door to subtle logic errors where funds and msg.value interplay lead to unexpected reverts.\n\nvulnerability_type: \"logic/validation error (balance check)\"\nseverity: \"high\"\nconfidence: 0.95,\nlocation: \"distributeStakeReward(address,uint256) function (balance check and send logic)\"  \n  } ,\n  {\n    \"title\": \"Contract can receive Ether via self-destruct despite receive() restricting direct sends\",\n    \"description\": \"What it is:\\n- The contract declares a receive() payable function gated by onlyStakeManager, which prevents normal transfers/calls with value from non-stakeManager addresses. However, an arbitrary account can still force Ether into the contract using selfdestruct on another contract (selfdestruct bypasses receive/fallback guards and directly increases balance).\\n\\nWhere it occurs:\\n- receive() external payable onlyStakeManager { } (receive handler) and general contract balance semantics.\\n\\nWhy it's a security issue:\\n- The code and NatSpec comments indicate the contract expects only the stakeManager to provide funds, and that received TEL is effectively burned except when issued by governance. Because selfdestruct can force ETH into the contract from any party, an attacker can unexpectedly change the contract balance without invoking receive(). That can cause unexpected behavior in distribution logic (including triggering the balance-validation bug above), change how much funds are available for distributions, or otherwise alter accounting assumptions in off-chain systems that assume only stakeManager deposits funds.\\n\\nPotential impact:\\n- An attacker could force arbitrary Ether into the contract causing logic mismatches or enabling other protocol actors (e.g., stakeManager) to distribute unexpected amounts. This could be used to create confusion, griefing, or unexpected payouts (if other components misuse the balance). Also breaks the stated assumption that only governance/stakeManager can fund the contract.\\n\nvulnerability_type: \"funds forcible transfer (selfdestruct) / invariants breach\"\nseverity: \"medium\"\nconfidence: 0.9,\nlocation: \"receive() payable (acceptance semantics) and contract-level balance assumptions\"\n  } ,\n  {\n    \"title\": \"No check against zero address for stakeManager (constructor allows disabling access control)\",\n    \"description\": \"What it is:\\n- The constructor stores the provided stakeManager_ address in an immutable variable but does not validate it (e.g., disallow address(0)). If stakeManager_ is set to the zero address, the onlyStakeManager modifier will effectively block legitimate calls because no EOA can be msg.sender == address(0).\\n\\nWhere it occurs:\\n- constructor(address stakeManager_) and onlyStakeManager modifier (assignment and check).\\n\\nWhy it's a security issue:\\n- If the contract is deployed with stakeManager set to address(0) (accidentally or maliciously by a deployer), all functions protected by onlyStakeManager (distributeStakeReward and receive) become unusable because no one can satisfy the modifier. This results in a permanent denial-of-service of reward distribution and prevents authorized deposits via the receive() path.\\n\\nPotential impact:\\n- Permanent loss of functionality: issued rewards cannot be distributed, and funds already in the contract could be stuck indefinitely (no code exposes a path to withdraw funds except distributeStakeReward which is gated). This could result in funds effectively being locked/burned.\n\nvulnerability_type: \"access control misconfiguration / initialization validation omission\"\nseverity: \"medium\"\nconfidence: 0.8,\nlocation: \"constructor(address) and onlyStakeManager modifier (initialization & access control)\"\n  } ,\n  {\n    \"title\": \"Use of low-level call to recipient without protections (external call with value) enables downstream failures and potential protocol-level reentrancy/interaction risks\",\n    \"description\": \"What it is:\\n- distributeStakeReward forwards value to an arbitrary recipient using recipient.call{ value: totalAmount }(\"\") with no gas stipend limit, no checks on recipient, and no reentrancy-safe patterns (even though this contract itself has minimal state).\\n\\nWhere it occurs:\\n- distributeStakeReward(...) when executing recipient.call{ value: totalAmount }(\"\").\\n\\nWhy it's a security issue:\\n- Sending Ether to an arbitrary recipient gives the recipient control over execution (they receive all remaining gas) and allows them to execute arbitrary code during the call. While this contract has no mutable state that is updated after the call, the recipient may interact with other contracts in the system (including the stakeManager or other protocol contracts) within that callback. This can enable complex cross-contract interactions that might be exploited at the protocol level or cause higher-level flows involving stakeManager to be manipulated. Additionally, if the recipient reverts, the whole call reverts (RewardDistributionFailure) and causes the stakeManager operation that invoked this function to fail; an attacker could craft recipients to intentionally revert and grief stakeManager flows if they can influence recipient addresses used by stakeManager.\\n\nPotential impact:\\n- Denial-of-service at the protocol level (if a chosen recipient always reverts), unintended cross-contract interactions that manipulate protocol state external to Issuance, and surface for complex reentrancy-like attacks involving other contracts. While reentrancy into Issuance itself is limited by access control, calls to external contracts during value transfer remain a risk to the broader system.\n\nvulnerability_type: \"external call / unsafe funds transfer (potential reentrancy & protocol interaction)\"\nseverity: \"medium\"\nconfidence: 0.7,\nlocation: \"distributeStakeReward(address,uint256) when performing recipient.call{ value: totalAmount }(\"\")\"\n  } ]  }MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.",
      "vulnerability_type": "other",
      "severity": "medium",
      "confidence": 0.5,
      "location": "unknown",
      "file": "Issuance.sol",
      "id": "86c45b42b2cd9aae",
      "reported_by_model": "gpt-5-mini",
      "status": "proposed"
    }
  ],
  "token_usage": {
    "input_tokens": 84218,
    "output_tokens": 66022,
    "total_tokens": 150240
  }
}