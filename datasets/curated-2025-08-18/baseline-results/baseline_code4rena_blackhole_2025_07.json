{
  "project": "code4rena_blackhole_2025_07",
  "timestamp": "2025-09-01T22:33:01.456346",
  "files_analyzed": 67,
  "files_skipped": 0,
  "total_findings": 121,
  "findings": [
    {
      "title": "Division-by-zero in balanceOf and deductAmount enables denial of service",
      "description": "The contract performs divisions by values that can be zero. Specifically: (1) In balanceOf(), it divides by totalDeposits when computing a user's share. If totalDeposits is 0 (e.g., before any deposits), this call reverts. (2) In deductAmount(), it computes _depositerLiquidity = liquidity / 2, then divides by _depositerLiquidity to compute userAmount. If liquidity is 0 (e.g., before _addLiquidityAndDistribute is called), this division reverts. These unchecked divisions allow a denial of service: balanceOf will revert pre-deposit, and deductAmount can be made to revert if the Gauge calls it before liquidity is set, potentially disrupting gauge interactions and any flows depending on these calls.",
      "vulnerability_type": "denial of service",
      "severity": "medium",
      "confidence": 0.85,
      "location": "balanceOf() and deductAmount() functions",
      "file": "GenesisPool.sol",
      "id": "9b20d7da90349c51",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Unsafe ERC20 approvals without resetting to zero can revert or leave lingering allowances",
      "description": "The contract uses safeApprove with potentially non-zero existing allowances and does not reset allowances back to zero after use. Many ERC20 tokens require setting allowance to 0 before updating to a new non-zero value, causing transactions to revert. Additionally, if the spender (router, bribe, or gauge) does not consume the full approved amount immediately, the leftover allowance remains and can be used later by that spender to pull tokens unexpectedly (especially dangerous if the external contract is malicious or later compromised). Affected locations: transferIncentives() approves external_bribe for the full incentive amount; _approveTokens() approves the router for allocated token amounts; _addLiquidityAndDistribute() approves the gauge for the LP tokens. This can lead to failed calls on tokens with non-standard allowance semantics and potential token drain risks if external spenders are untrusted.",
      "vulnerability_type": "insecure approval",
      "severity": "medium",
      "confidence": 0.8,
      "location": "transferIncentives(), _approveTokens(), _addLiquidityAndDistribute()",
      "file": "GenesisPool.sol",
      "id": "a0d6e5e3aa7d0a87",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Initialization allows zero or non-contract address to be registered as an auction",
      "description": "The initialize function does not validate the _auction parameter. Unlike addAuction and replaceAuction, it does not check for address(0) or that the address has code. This allows setting address(0) or an EOA as a valid auction during initialization. If other system components rely on isAuction for access control or validation (e.g., trusting any address flagged true as an authorized auction), this can enable bypasses (accepting an invalid auction), misconfiguration, or denial-of-service scenarios. For example, marking address(0) as a valid auction could allow passing zero where only 'authorized auctions' are expected if external checks only rely on isAuction without separately enforcing nonzero/contract. Occurs in: initialize(address _auction).",
      "vulnerability_type": "improper input validation / access control",
      "severity": "high",
      "confidence": 0.7,
      "location": "initialize(address _auction)",
      "file": "AuctionFactory.sol",
      "id": "743917320c1a1598",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Contract can be taken over if initialize is not called promptly (upgradeable ownership takeover)",
      "description": "The initialize function is public and can be called by anyone once per proxy/instance. If deployment scripts fail to call initialize immediately (e.g., deploying the implementation directly or leaving a proxy uninitialized), an attacker can front-run and call initialize to set themselves as the owner, gaining full control over add/replace/remove of auctions. While this is a standard upgradable pattern requirement, it represents a real risk if deployment is misconfigured or delayed. Occurs in: initialize(address _auction) and overall deployment process.",
      "vulnerability_type": "improper initialization / ownership takeover",
      "severity": "medium",
      "confidence": 0.6,
      "location": "initialize(address _auction) and deployment sequence",
      "file": "AuctionFactory.sol",
      "id": "3dabf0c441ae6d0e",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Untrusted token metadata calls can cause denial of service",
      "description": "The functions getPairBribe and _getNextEpochRewards call external token metadata functions symbol() and decimals() on arbitrary token addresses returned by the bribe contract. Malicious or non-standard ERC20 tokens can revert, return extremely large data, or consume excessive gas when these functions are called. Because these calls are made without safeguards, any such token can cause these read functions to revert, effectively denying service to users or integrators relying on this API. This occurs in getPairBribe() and _getNextEpochRewards(), when iterating tokens from IBribeAPI(_bribe).bribeTokens(i) and then calling IERC20(_token).symbol() and IERC20(_token).decimals(). Impact: frontends or off-chain systems calling these view functions may fail to retrieve rewards info for pairs that include a malicious token; on-chain callers would also revert, leading to DoS of dependent workflows.",
      "vulnerability_type": "denial of service",
      "severity": "medium",
      "confidence": 0.8,
      "location": "_getNextEpochRewards() and getPairBribe()",
      "file": "RewardAPI.sol",
      "id": "4f2fafeef4426c3a",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Initializer not disabled on implementation allows unintended ownership of implementation contract",
      "description": "The contract is upgradeable (inherits Initializable) but does not disable initializers in the implementation. The initialize function is public and gated only by the initializer modifier, which prevents multiple initializations on the same address but does not prevent anyone from initializing the implementation contract itself if it is deployed. An attacker can call initialize on the implementation and set themselves as owner. While this may not affect a correctly configured proxy instance, it can cause issues if the implementation is ever interacted with directly, referenced by other systems, or used in an upgrade pattern that inspects implementation state. Best practice is to disable initializers in the implementation constructor using _disableInitializers().",
      "vulnerability_type": "access control",
      "severity": "low",
      "confidence": 0.7,
      "location": "initialize() and constructor()",
      "file": "RewardAPI.sol",
      "id": "5057ab6c92d488c0",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Accounting mismatch for deflationary/malicious ERC20 in notifyRewardAmount can cause reward underfunding and claim DoS",
      "description": "The contract accounts rewards using the input parameter `reward` in `notifyRewardAmount` but does not verify the actual tokens received. For fee-on-transfer/deflationary or malicious tokens, `safeTransferFrom` may result in fewer tokens being deposited than the `reward` value credited to `tokenRewardsPerEpoch`. Later, `getReward` attempts to transfer the full accounted amount to users, which can exceed the contract's real balance and revert. A single such token can block claims for that token and, depending on how `gaugeManager` batches tokens, potentially revert the entire claim call.\n- Where: `notifyRewardAmount(address _rewardsToken, uint256 reward)` and `getReward(uint256 tokenId, address[] memory tokens)`\n- Why it's a security issue: An attacker can call `notifyRewardAmount` with a deflationary token (or a token whose `transferFrom` takes a fee), causing the contract to over-account rewards relative to the actual token balance. Future claims revert when trying to transfer more than the actual balance.\n- Potential impact: Denial of service for claiming rewards of the affected token; users may be unable to claim owed rewards; system-wide claim DoS if the `gaugeManager` includes the failing token in a batch.",
      "vulnerability_type": "token accounting / fee-on-transfer handling",
      "severity": "high",
      "confidence": 0.85,
      "location": "notifyRewardAmount(), getReward()",
      "file": "Bribes.sol",
      "id": "8fb7fa9a72e33c45",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Unbounded loop over epochs in earned() can lead to gas-based denial of service for stale positions",
      "description": "The `earned` function iterates over each week from `epochStart(lastEarn[_rewardToken][tokenId])` up to the current epoch, summing rewards per epoch. If `lastEarn` is very old (or zero) and the token has historical checkpoints, the number of iterations can be large, potentially causing `getReward` to run out of gas and revert.\n- Where: `earned(uint256 tokenId, address _rewardToken)` looping over `numEpochs` and called within `getReward`.\n- Why it's a security issue: The cost of claims grows linearly with the number of epochs since last claim. For stale positions, this can exceed block gas limits, preventing users from ever claiming (DoS).\n- Potential impact: Permanent denial of service for claiming rewards for long-inactive token IDs unless separate off-chain or contract-side mechanisms are used to chunk claims.",
      "vulnerability_type": "denial of service (unbounded iteration)",
      "severity": "medium",
      "confidence": 0.75,
      "location": "earned()",
      "file": "Bribes.sol",
      "id": "a3e44573ca152632",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Admin can arbitrarily seize reward tokens, potentially corrupting accounting and blocking claims",
      "description": "The contract allows the `owner` or `bribeFactory` to withdraw arbitrary ERC20 tokens from the contract at any time via `emergencyRecoverERC20`, without adjusting epoch accounting, and via `recoverERC20AndUpdateData`, which adjusts only the next epoch entry and may not align with how rewards were accrued. This can leave `tokenRewardsPerEpoch` overstated relative to actual balances, causing `getReward` to revert when attempting transfers.\n- Where: `emergencyRecoverERC20(address tokenAddress, uint256 tokenAmount)`, `recoverERC20AndUpdateData(address tokenAddress, uint256 tokenAmount)`\n- Why it's a security issue: A privileged actor can remove user-owed rewards and corrupt accounting, leading to loss of funds for users and denial of service on future claims. Even if not malicious, misconfiguration can create underfunded epochs.\n- Potential impact: Loss of funds due to admin seizure; data corruption; claim DoS for affected tokens/epochs.",
      "vulnerability_type": "centralization/privileged operations",
      "severity": "medium",
      "confidence": 0.8,
      "location": "emergencyRecoverERC20(), recoverERC20AndUpdateData()",
      "file": "Bribes.sol",
      "id": "80aa5db1ab222f8b",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Outputs sent to zero address due to ignored `to` parameter and unset `receiver` in swaps",
      "description": "In the core swap function `_swap(...)`, the contract ignores the external `to` parameter and instead uses `routes[i].receiver` as the recipient for each hop. In all wrapper functions that call `_swap` (e.g., `swapExactTokensForTokensSimple`, `swapExactTokensForTokens`, `swapExactETHForTokens`, `swapExactTokensForETH`, `UNSAFE_swapExactTokensForTokens`), the `route.receiver` field is not set by the contract; for `swapExactTokensForTokensSimple`, it is explicitly left uninitialized. As a result, `routes[i].receiver` defaults to the zero address. The volatile-path branch calls `pair.swap(..., routes[i].receiver, ...)` and the concentrated-path branch sets `recipient: routes[i].receiver` in the Algebra router call. This sends output tokens to address(0), effectively burning them or making swaps fail/revert later. Where it occurs: - `_swap(uint[] memory amounts, route[] memory routes, address _to)`: uses `routes[i].receiver` instead of `_to` for both volatile and concentrated swaps. - `swapExactTokensForTokensSimple(...)`: constructs a `route` without setting `receiver`. - Also affects `swapExactTokensForTokens`, `swapExactETHForTokens`, `swapExactTokensForETH`, and `UNSAFE_swapExactTokensForTokens` because `_swap` ignores the passed `to` parameter entirely. Why it's a security issue: Users expect the `to` parameter to be the recipient of the final output. Because `_swap` ignores `to`, and because `receiver` is often unset, outputs are directed to the zero address, causing irreversible loss of funds or transaction reverts (e.g., attempting to withdraw WETH that the contract never received after a swap). Potential impact: - Critical loss of user funds where swap outputs are irrecoverably sent to address(0). - Transactions failing due to insufficient balances post-swap (e.g., WETH withdraw after swap).",
      "vulnerability_type": "logic error / funds loss",
      "severity": "critical",
      "confidence": 0.95,
      "location": "_swap(), swapExactTokensForTokensSimple(), swapExactTokensForTokens(), swapExactETHForTokens(), swapExactTokensForETH(), UNSAFE_swapExactTokensForTokens()",
      "file": "RouterV2.sol",
      "id": "afc8842cfb76f4b7",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Privileged owner can redirect approvals and funds via mutable external router/quoter addresses",
      "description": "The contract allows the `owner` to arbitrarily set critical external dependencies used during swaps: `swapRouter`, `algebraFactory`, `quoterV2`, and `algebraPoolAPIStorage` via `setSwapRouter`, `setAlgebraFactory`, `setQuoterV2`, and `setAlgebraPoolAPI`. During concentrated liquidity swaps, the contract transfers user tokens to itself and then approves `swapRouter` to spend them before calling `ISwapRouter.exactInputSingle`. If the owner points `swapRouter` to a malicious contract, it can drain the approved tokens or misroute funds. Where it occurs: - `setSwapRouter(address _swapRouter)`, `setAlgebraFactory(...)`, `setQuoterV2(...)`, `setAlgebraPoolAPI(...)` (owner-only setters). - Token approvals and calls in `_swap()` concentrated branch: it grants allowance to `swapRouter` and calls `ISwapRouter.exactInputSingle`. Why it's a security issue: This centralizes trust in the owner; they can redirect approvals and swap flows to an untrusted/malicious address, leading to theft of user tokens during swapping. Potential impact: - Theft of user funds during swap calls that use concentrated routes (e.g., `swapExactTokensForTokensSimple` with `concentrated=true`, `swapExactTokensForTokens`, `swapExactETHForTokens`, `swapExactTokensForETH`). - Manipulation of quoted amounts (via `quoterV2`) causing users to accept unfavorable trades.",
      "vulnerability_type": "access control / centralization risk",
      "severity": "high",
      "confidence": 0.85,
      "location": "setSwapRouter(), setAlgebraFactory(), setQuoterV2(), setAlgebraPoolAPI(); approvals and calls in _swap() concentrated-path",
      "file": "RouterV2.sol",
      "id": "d0d3bad292b9a7ce",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Withdrawal uses transfer() causing potential denial of service and fund lock for contract wallets",
      "description": "The withdraw(uint256 wad) function sends AVAX using address.transfer(), which forwards only 2300 gas to the recipient. If msg.sender is a contract whose receive/fallback requires more than 2300 gas or reverts (e.g., proxy, multisig, or smart wallet with logic in receive), the transfer will revert and the entire withdraw call reverts after balances have been updated. Because state is updated before the transfer, the function reverts and no state change persists, but the user is effectively unable to withdraw to their own address, leading to practical loss-of-funds for those users. This is a known issue with WETH9-style implementations. Using call{value: wad} with proper reentrancy protection is the recommended alternative.\nWhere: withdraw() function.\nWhy it's a security issue: Legitimate users holding WAVAX in contract wallets may be unable to withdraw their AVAX, creating a denial of service/loss of access to funds.\nPotential impact: Holders that are contracts with non-trivial receive/fallback functions cannot withdraw; funds become practically locked unless a new function (e.g., withdrawTo using call) is introduced.",
      "vulnerability_type": "denial of service (gas stipend/transfer)",
      "severity": "high",
      "confidence": 0.9,
      "location": "withdraw(uint256 wad) function",
      "file": "WAVAX.sol",
      "id": "4e798d0e6dba3e8d",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Approval race condition allows spender to spend more than intended",
      "description": "The approve(address spender, uint256 value) function directly sets allowance without mitigating the well-known ERC-20 approval race. If the owner changes an existing non-zero allowance to another non-zero value, a spender can front-run the change by spending the old allowance and then also spend from the newly set allowance, leading to spending more than the owner intended. Recommended mitigations include requiring allowance to be set to zero before setting a new non-zero value, or providing increaseAllowance/decreaseAllowance functions.\nWhere: approve() function.\nWhy it's a security issue: Can enable over-spending through front-running, leading to unexpected loss of tokens by the approver.\nPotential impact: Loss of tokens by users who update allowances from one non-zero value to another while a malicious spender monitors and front-runs.",
      "vulnerability_type": "allowance race (approval front-running)",
      "severity": "medium",
      "confidence": 0.95,
      "location": "approve(address spender, uint256 value) function",
      "file": "WAVAX.sol",
      "id": "2350e89e64220ca2",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Forcible AVAX (selfdestruct) can desynchronize totalSupply from balances",
      "description": "AVAX can be forcibly sent to the contract via selfdestruct or coinbase block rewards, bypassing deposit(). totalSupply() returns address(this).balance, while user balances are only updated in deposit(). This can lead to totalSupply() exceeding the sum of all balances and to unaccounted AVAX permanently locked in the contract with no corresponding tokens. While this does not allow theft, it can disrupt integrations that rely on invariant assumptions between totalSupply and balances.\nWhere: totalSupply() view uses address(this).balance; deposit() is the only place that updates balances.\nWhy it's a security issue: Creates accounting inconsistencies and potential integration issues; an attacker can grief by forcing AVAX into the contract.\nPotential impact: Permanent locking of AVAX without corresponding tokens; protocols relying on totalSupply invariants may malfunction or misprice.",
      "vulnerability_type": "protocol manipulation / accounting inconsistency via forced ether",
      "severity": "low",
      "confidence": 0.85,
      "location": "totalSupply() and deposit() interaction",
      "file": "WAVAX.sol",
      "id": "3fe8d02226c72b29",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Privilege escalation via setPermissionsRegistry allows GAUGE_ADMIN to gain GOVERNANCE powers",
      "description": "The function setPermissionsRegistry is restricted only by the GaugeAdmin modifier, allowing any address with the GAUGE_ADMIN role to replace the permissions registry contract. Because all privileged checks (GaugeAdmin and Governance) query IPermissionsRegistry(permissionRegistry).hasRole(...), a GAUGE_ADMIN can point permissionRegistry to a malicious implementation that returns true for hasRole(\"GOVERNANCE\", msg.sender). This enables the GAUGE_ADMIN to execute Governance-only functions such as killGauge and reviveGauge, among others, effectively bypassing intended role separation.\n\nWhere: setPermissionsRegistry() function.\nWhy it's a security issue: It breaks separation of duties and enables unauthorized access to Governance-restricted actions.\nPotential impact: Unauthorized killing/reviving of gauges, manipulation of protocol parameters guarded by Governance, and other privileged actions restricted to Governance.",
      "vulnerability_type": "access control / privilege escalation",
      "severity": "high",
      "confidence": 0.9,
      "location": "setPermissionsRegistry(address _permissionRegistry)",
      "file": "GaugeManager.sol",
      "id": "5743bd4b1f0739ae",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Shadowed variable forces bonusRewardToken to zero in _createGauge (DoS for bonus reward feature)",
      "description": "Inside _createGauge, a new local variable named bonusRewardToken is declared and assigned to itself: `address bonusRewardToken = bonusRewardToken;`. This shadows the function parameter and leaves the local variable uninitialized (zero), causing the value passed to IGaugeFactoryCL.createGauge to always be address(0). As a result, createGaugeWithBonusReward cannot actually pass a non-zero bonus reward token. Depending on the gauge factory\u2019s expectations, this can either silently disable bonus rewards or cause a revert, denying creation of CL gauges with bonus rewards.\n\nWhere: _createGauge(address _pool, uint256 _gaugeType, address bonusRewardToken), in the line declaring `address bonusRewardToken = bonusRewardToken;` and in the CL branch passing this value to IGaugeFactoryCL.createGauge.\nWhy it's a security issue: It can break intended protocol behavior and potentially cause denial of service for creating CL gauges with bonus rewards.\nPotential impact: Inability to deploy CL gauges with bonus rewards or unintended zero bonus token configured.",
      "vulnerability_type": "logic bug / parameter shadowing leading to DoS",
      "severity": "low",
      "confidence": 0.8,
      "location": "_createGauge(...) local variable assignment and subsequent IGaugeFactoryCL.createGauge(...) call",
      "file": "GaugeManager.sol",
      "id": "9fee35b7d17cbf3f",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Incorrect defeat condition lets large abstain votes prevent defeat, potentially causing governance DoS",
      "description": "The custom defeat logic in _voteDefeated allows a proposal to avoid being marked as defeated when abstainVotes are high, even if forVotes are not greater than againstVotes. Specifically, _voteDefeated returns true only if againstVotes > forVotes AND againstVotes > abstainVotes. This deviates from the standard OpenZeppelin GovernorCountingSimple behavior, where a proposal that fails to meet quorum or fails the for > against condition is considered defeated. Location: _voteDefeated(uint256) function. Why it's a security issue: An attacker (or any voting bloc) can accumulate or induce large abstain votes to ensure that againstVotes are not strictly greater than abstainVotes, thereby preventing the proposal from being marked 'defeated' even though it clearly did not pass (forVotes <= againstVotes). Depending on how L2Governor uses _voteDefeated/_voteSucceeded to compute the final proposal state, this can lead to proposals that are neither succeeded nor defeated, potentially remaining in an indeterminate state after the voting period. Potential impact: Denial of service or protocol manipulation of governance flow\u2014attackers can prevent clear rejection of proposals by pumping abstain votes, potentially blocking lifecycle progression (e.g., preventing queue/cancel flows tied to finalized states, clogging proposal queues, or otherwise disrupting governance state transitions).",
      "vulnerability_type": "logic/validation error",
      "severity": "medium",
      "confidence": 0.6,
      "location": "_voteDefeated(uint256 proposalId) function",
      "file": "L2GovernorCountingSimple.sol",
      "id": "2137fb655ee93aa5",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Execution allowed for Defeated and Expired proposals",
      "description": "The execute function permits execution when a proposal's state is Succeeded, Defeated, or Expired. This allows proposals that failed to pass or did not meet quorum to still be executed, undermining governance. Specifically, in execute(), the require condition accepts ProposalState.Defeated and ProposalState.Expired, then proceeds to mark the proposal as executed and calls _execute on arbitrary targets and values. This effectively enables unauthorized protocol changes even when token holders voted against them or quorum was not met.\n\nWhere: execute() function. The check `status == ProposalState.Succeeded || status == ProposalState.Defeated || status == ProposalState.Expired` occurs before setting executed and invoking _execute.\n\nWhy it's a security issue: Governance guarantees are broken; proposals that do not pass can be executed. This leads to unauthorized access/privilege escalation via governance.\n\nPotential impact: Attackers could pass and execute any action through a proposal that gets defeated or fails quorum, leading to loss of funds, arbitrary parameter changes, token seizures, or protocol takeover.",
      "vulnerability_type": "access control / governance logic flaw",
      "severity": "critical",
      "confidence": 0.98,
      "location": "execute() function",
      "file": "Governor.sol",
      "id": "8fc9c4a50c091cd6",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Quorum not snapshotted; manipulable during/after voting",
      "description": "The quorum function ignores the provided blockTimestamp and uses token.getsmNFTPastTotalSupply() with no timestamp argument. Consequently, quorum is not tied to the proposal\u2019s snapshot time and can vary with the current total supply. An attacker can mint/burn/change supply during or after the voting period to reduce or inflate quorum, manipulating whether _quorumReached returns true when state() is evaluated.\n\nWhere: L2GovernorVotesQuorumFraction.quorum(uint256) uses `token.getsmNFTPastTotalSupply()` without using the blockTimestamp parameter. state() relies on quorum(proposalSnapshot(proposalId)), but the parameter is effectively ignored.\n\nWhy it's a security issue: Quorum should be determined at a fixed snapshot to prevent manipulation. Without this, an attacker can game quorum to pass or fail proposals arbitrarily.\n\nPotential impact: Protocol manipulation of proposal outcomes; unauthorized execution of proposals that should not meet quorum, or preventing legitimate proposals by inflating supply.",
      "vulnerability_type": "protocol manipulation / incorrect snapshot",
      "severity": "high",
      "confidence": 0.9,
      "location": "L2GovernorVotesQuorumFraction.quorum(uint256 blockTimestamp)",
      "file": "Governor.sol",
      "id": "0dea5d95c91c333f",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Proposer threshold check uses block number instead of timestamp",
      "description": "In _proposal(), the proposer threshold check calls getVotes(_msgSender(), block.number - 1). However, this governor and the voting token interface use timestamps for snapshots, not block numbers. Passing a block number where a timestamp is expected can return incorrect voting power (typically 0 if the timestamp lookup fails), making it impossible for eligible proposers to create proposals when a non-zero threshold is configured.\n\nWhere: L2Governor._proposal() uses `getVotes(_msgSender(), block.number - 1)` for the threshold check.\n\nWhy it's a security issue: If proposalThreshold() is overridden to be > 0, legitimate proposers may be denied service (DoS) due to incorrect vote snapshot lookup, while the intent was to use the timestamp-based snapshot system.\n\nPotential impact: Denial of service for proposal creation; governance paralysis if threshold is set and no one can meet it due to the bug.",
      "vulnerability_type": "logic error leading to DoS",
      "severity": "medium",
      "confidence": 0.85,
      "location": "_proposal() function (proposer threshold check)",
      "file": "Governor.sol",
      "id": "483504b3f082534f",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Centralized, unlimited minting via minter role",
      "description": "The contract allows the designated minter to mint an arbitrary amount of tokens to any address at any time using mint(). The minter can also change the minter address using setMinter() without any time delay or multi-sig requirement. While initialMint() is limited by the initialMinted boolean to a one-time 500M mint, the separate mint() function has no cap. If the minter's key is compromised or is malicious, they can mint unlimited tokens, leading to severe dilution and potential draining of liquidity pools and protocols integrating this token.\n- Where: setMinter(address _minter), initialMint(address _recipient), mint(address account, uint amount)\n- Why it's a security issue: A single privileged role can arbitrarily inflate supply. Compromise or misuse leads to loss of value for holders and downstream protocols.\n- Potential impact: Loss of funds via dilution; manipulation of markets and protocol accounting; draining AMMs by minting and dumping.",
      "vulnerability_type": "access control / centralization risk",
      "severity": "high",
      "confidence": 0.95,
      "location": "setMinter(), initialMint(), mint()",
      "file": "Black.sol",
      "id": "08393415c7edf6e9",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Allowance front-running (ERC20 approve race condition)",
      "description": "The approve() implementation is susceptible to the well-known ERC20 allowance race condition. If an owner changes a non-zero allowance to another non-zero value, a spender can front-run the transaction and spend the old allowance before the change, potentially allowing them to use both the old and the new allowance in combination.\n- Where: approve(address _spender, uint _value); spending paths: transferFrom() and burnFrom()\n- Why it's a security issue: Spenders can exploit timing to spend more than intended by the owner.\n- Potential impact: Unauthorized token spending beyond the owner's intent.",
      "vulnerability_type": "allowance race / approval front-running",
      "severity": "medium",
      "confidence": 0.9,
      "location": "approve(), transferFrom(), burnFrom()",
      "file": "Black.sol",
      "id": "0f526f3fcde0c99a",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Minting and transferring to the zero address allowed",
      "description": "The contract allows _mint() to mint to address(0) and _transfer() to transfer to address(0), effectively burning tokens. While burning may be intended, allowing mint to the zero address can permanently increase totalSupply without distributing tokens, and allowing transfers to the zero address can lead to accidental loss of funds if called unintentionally by users or integrations. Many ERC20 implementations explicitly forbid zero-address recipients for safety.\n- Where: _mint(address _to, uint _amount), _transfer(address _from, address _to, uint _value)\n- Why it's a security issue: Can lead to irreversible token loss or supply accounting anomalies for integrators relying on standard behavior.\n- Potential impact: User fund loss due to accidental burns; potential protocol integration issues relying on non-zero recipients.",
      "vulnerability_type": "input validation",
      "severity": "low",
      "confidence": 0.7,
      "location": "_mint(), _transfer()",
      "file": "Black.sol",
      "id": "eb7c627822616a8b",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Owner can arbitrarily burn tokens from any address (confiscation risk)",
      "description": "The burn function allows the owner to burn tokens from any account without that account's consent or allowance. It directly calls _burn(account, amount) on the specified account. This occurs in burn(address account, uint256 amount). This is a security issue because it enables the privileged owner to seize/destroy user funds, leading to loss of funds for token holders. Potential impact includes unilateral removal of user balances (provided the target account has sufficient balance), which can be abused or exploited if the owner key is compromised.",
      "vulnerability_type": "access control / privilege abuse",
      "severity": "high",
      "confidence": 0.95,
      "location": "burn(address,uint256) function",
      "file": "CustomToken.sol",
      "id": "75c4ca88f536230f",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Unbounded minting by owner enables unlimited supply inflation",
      "description": "The mint function permits the owner to mint an arbitrary amount of tokens to any address by calling _mint without any cap or governance constraints. This occurs in mint(address account, uint256 amount). This is a security issue because it enables unlimited inflation, which can severely dilute existing holders and manipulate token economics. If the owner is malicious or compromised, they can mint excessive tokens and dump them, causing economic loss to users and protocol manipulation.",
      "vulnerability_type": "centralization / economic manipulation",
      "severity": "high",
      "confidence": 0.8,
      "location": "mint(address,uint256) function",
      "file": "CustomToken.sol",
      "id": "521435110213d12c",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Underflow and infinite loop condition in getAmountsIn causes revert (DoS)",
      "description": "The reverse iteration in getAmountsIn uses an unsigned loop with condition 'i >= 0' and decrements 'i--': 'for (uint i = routes.length-1; i >= 0; i--)'. For uint, 'i >= 0' is always true. After processing i = 0, the subsequent 'i--' underflows in Solidity 0.8.x and reverts. This makes getAmountsIn unusable for any non-empty routes, causing a denial of service for any contract or user relying on this function for path quote calculation.",
      "vulnerability_type": "arithmetic underflow / denial of service",
      "severity": "high",
      "confidence": 0.95,
      "location": "getAmountsIn() function, reverse for-loop 'for (uint i = routes.length-1; i >= 0; i--)'",
      "file": "TradeHelper.sol",
      "id": "e40cd2453856fd20",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Untrusted token decimals() can cause overflow/reverts in getAmountInStable (DoS for malicious tokens)",
      "description": "getAmountInStable calls IERC20(token).decimals() for both tokenIn and tokenOut, then computes 10**decimals. A malicious or non-standard token can: (1) return an excessively large decimals value causing 10**decimals to overflow and revert in Solidity 0.8.x, or (2) revert on decimals() altogether. This leads to persistent reverts for paths involving such tokens, enabling a denial-of-service on quoting for those pairs if integrated without safeguards. While many tokens use 18 decimals, relying on decimals() without bounds or fallbacks is unsafe when interacting with arbitrary tokens.",
      "vulnerability_type": "external call to untrusted token / input validation leading to DoS",
      "severity": "medium",
      "confidence": 0.7,
      "location": "getAmountInStable() function, lines computing 'uint decimalsIn = 10**IERC20(tokenIn).decimals();' and 'uint decimalsOut = 10**IERC20(tokenOut).decimals();'",
      "file": "TradeHelper.sol",
      "id": "5d6f7b6f67a9dd3d",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Potential denial of service from non-standard or deflationary reward tokens",
      "description": "The contract assumes rewardToken behaves as a standard ERC20. In onReward(), the contract transfers the full computed pending amount to the recipient. If rewardToken is deflationary (fee-on-transfer) or otherwise non-standard (e.g., reverts or returns false inconsistently), accounting will not match actual transferred amounts. Over time this can deplete the contract balance faster than expected and eventually cause safeTransfer to revert, blocking onReward() calls for all users and potentially disrupting the gauge\u2019s operations.\nWhere: onReward() function \u2013 the line performing rewardToken.safeTransfer(to, pending); also related to setDistributionRate() which computes rewardPerSecond from balanceOf without considering transfer fees.\nWhy: A revert in safeTransfer will revert onReward(), preventing users from receiving rewards and potentially blocking gauge flows if onReward is part of a larger transaction.\nImpact: Denial of service for rewards distribution; users may be unable to claim or receive rewards and protocol flows depending on onReward may fail.",
      "vulnerability_type": "denial_of_service / token compatibility",
      "severity": "medium",
      "confidence": 0.7,
      "location": "onReward() and setDistributionRate()",
      "file": "GaugeExtraRewarder.sol",
      "id": "d4700500b7c23d5d",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Admin can withdraw reward tokens, reducing or halting emissions",
      "description": "The owner can withdraw reward tokens via recoverERC20(). While there is a cap when emissions are active (rps > 0 and lastDistributedTime > block.timestamp), the owner can still withdraw up to all undistributed rewards mid-period by reducing rewardPerSecond, and can withdraw the entire reward balance once emissions are over or set to zero. This centralizes control over rewards and can lead to unexpected loss of rewards for users.\nWhere: recoverERC20() and setDistributionRate().\nWhy: recoverERC20() allows sweeping tokens; for rewardToken, it only limits withdrawal during an active period to notDistributed and then lowers rewardPerSecond accordingly. Outside that condition (e.g., rps == 0 or after the period), the owner can withdraw all reward tokens.\nImpact: Loss or reduction of expected rewards for users; protocol manipulation by admin.",
      "vulnerability_type": "centralization risk / admin privilege misuse",
      "severity": "medium",
      "confidence": 0.9,
      "location": "recoverERC20() and setDistributionRate()",
      "file": "GaugeExtraRewarder.sol",
      "id": "bc965c60378e8e1b",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "External call to LP token balanceOf may enable griefing or reentrancy if LP token is malicious",
      "description": "The contract calls IERC20(IGauge(GAUGE).TOKEN()).balanceOf(GAUGE) inside updatePool() and _pendingReward() without any guard. If the LP token at GAUGE.TOKEN() is malicious, balanceOf could revert (blocking updates and views) or attempt reentrancy into this contract. onlyGauge protects onReward from arbitrary callers, and admin-only functions are restricted, but a malicious token can still cause DoS by reverting balanceOf, affecting reward updates and pending views.\nWhere: updatePool() and _pendingReward() when reading lpSupply via TOKEN().balanceOf(GAUGE).\nWhy: Untrusted external calls can revert or reenter; although privilege checks limit damage, a revert causes denial of service for pool updates and pending views.\nImpact: Denial of service (updates and pendingReward computations can revert), degraded UX and potential protocol disruption if GAUGE.TOKEN is not trusted.",
      "vulnerability_type": "denial_of_service / untrusted external call",
      "severity": "low",
      "confidence": 0.6,
      "location": "updatePool() and _pendingReward()",
      "file": "GaugeExtraRewarder.sol",
      "id": "e6f77a2aa807d6b3",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Incorrect reserve accounting can permanently disable owner reserves",
      "description": "In reserveNFTs, the contract increments reservedAmount by the requested _amount after attempting to mint, but the loop may mint fewer tokens when totalSupply() is close to MAX_SUPPLY. This misaccounting occurs because the function only checks reservedAmount.add(_amount) <= MAX_RESERVE and then conditionally mints inside the loop with if (totalSupply() < MAX_SUPPLY), but still does reservedAmount = reservedAmount.add(_amount) regardless of how many were actually minted. As a result, reservedAmount can exceed the count of actually minted reserved NFTs, and can reach MAX_RESERVE prematurely, preventing further legitimate reserves by the owner. This creates a denial of service for the reserve functionality.\n- Where: reserveNFTs(address _to, uint256 _amount)\n- Why it's a security issue: It enables a DoS against a core admin function by consuming the reserve allowance without actually minting the corresponding number of tokens.\n- Potential impact: The owner may be unable to reserve the intended number of tokens later, impacting distribution plans and potentially business logic.",
      "vulnerability_type": "denial of service",
      "severity": "low",
      "confidence": 0.9,
      "location": "reserveNFTs() function",
      "file": "Thenian.sol",
      "id": "3731d99a24a6a1da",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Hardcoded, non-upgradeable withdrawal address risks irreversible fund loss",
      "description": "The withdraw function sends the entire ETH balance to a hardcoded multiSig address and there is no way to update this address. If the hardcoded address is incorrect, becomes compromised, or access to it is lost, funds in the contract can become irretrievable. Additionally, this design concentrates control and introduces operational risk.\n- Where: withdraw(), address public multiSig = 0x7d70ee3774325C51e021Af1f7987C214d2CAA184\n- Why it's a security issue: Misconfiguration or loss of access to the hardcoded address can permanently lock or misdirect funds.\n- Potential impact: Loss of funds due to inability to change the payout address or recovery in case of errors/compromise.",
      "vulnerability_type": "trust/centralization risk",
      "severity": "medium",
      "confidence": 0.7,
      "location": "withdraw() function and multiSig address declaration",
      "file": "Thenian.sol",
      "id": "484663380ccc0752",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Owner can arbitrarily burn tokens from any account",
      "description": "The burn function allows the owner to burn tokens from any specified account without that account's consent or allowance. This occurs in burn(address account, uint256 amount), where _burn(account, amount) is called under onlyOwner without access checks on the target account. This is a security issue because if the owner's key is compromised or the owner acts maliciously, user funds can be destroyed without recourse. Potential impact includes irreversible loss of user funds and trust, as any holder's balance can be reduced to zero.",
      "vulnerability_type": "access control / centralization risk",
      "severity": "high",
      "confidence": 0.95,
      "location": "burn(address account, uint256 amount) function",
      "file": "Fan.sol",
      "id": "5237088d6a9f25d8",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Unlimited minting by owner enables supply inflation and value dilution",
      "description": "The mint function allows the owner to mint an arbitrary amount of tokens to any address with no cap or governance constraints. This occurs in mint(address account, uint256 amount), protected only by onlyOwner. While this may be intentional, it creates a centralization risk where the owner (or a compromised owner key) can mint unlimited tokens, diluting supply, manipulating markets, or draining liquidity pools by minting and dumping. Potential impact includes severe economic manipulation, loss of value for existing holders, and potential draining of paired assets in AMM pools.",
      "vulnerability_type": "access control / centralization risk",
      "severity": "high",
      "confidence": 0.95,
      "location": "mint(address account, uint256 amount) function",
      "file": "Fan.sol",
      "id": "03abfd4bcbfeb9a0",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Unrestricted gauge creation allows malicious gauges and protocol manipulation",
      "description": "The createGauge function is externally callable by anyone without any access control. It deploys a new GaugeCL with arbitrary parameters provided by the caller and records it in the factory's gauges list. Location: createGauge(...), GaugeFactoryCL.sol. Why it's an issue: Attackers can create and register arbitrary/malicious gauges that appear as factory-created, potentially misleading integrators/UIs or end users to interact with unsafe gauges (e.g., with attacker-controlled bribe/distribution addresses). Potential impact: Users may deposit funds into attacker-created gauges leading to loss of funds; governance/operations that rely on the factory's gauge list can be polluted or manipulated.",
      "vulnerability_type": "access control",
      "severity": "high",
      "confidence": 0.7,
      "location": "createGauge(...) function",
      "file": "GaugeFactoryCL.sol",
      "id": "5fbd24288cce598c",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Approval to attacker-controlled spender enables theft of tokens later sent to the factory",
      "description": "createEternalFarming approves the _algebraEternalFarming address (fully controlled by the caller of createGauge) to spend reward tokens from this factory: IERC20(_rewardToken).safeApprove(_algebraEternalFarming, 1e10). Location: createEternalFarming(...), GaugeFactoryCL.sol. Why it's an issue: The factory grants allowance to an arbitrary address supplied by an untrusted caller. If any amount of _rewardToken is ever sent/airdropped to the factory (common for ERC20s), the approved attacker-controlled contract can transferFrom and drain up to the approved amount. This approval persists across calls. Potential impact: Loss of any ERC20 tokens held by the factory for the approved token-spender pair (up to 1e10 units per approval).",
      "vulnerability_type": "improper authorization/allowance management",
      "severity": "high",
      "confidence": 0.85,
      "location": "createEternalFarming(...) function",
      "file": "GaugeFactoryCL.sol",
      "id": "b31885567fabe731",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "safeApprove without resetting to zero causes persistent DoS for repeated gauge creation",
      "description": "safeApprove is used to set a non-zero allowance without ever resetting to zero: IERC20(_rewardToken).safeApprove(_algebraEternalFarming, reward). OpenZeppelin's SafeERC20.safeApprove reverts if the current allowance is not zero and the new allowance is non-zero. Location: createEternalFarming(...), GaugeFactoryCL.sol. Why it's an issue: The first call for a given (_rewardToken, _algebraEternalFarming) pair will succeed, but any subsequent attempt to create another gauge using the same reward token and the same eternal farming contract will revert, blocking legitimate operations. Because createGauge is permissionless, an attacker can preemptively call it with the legit parameters to set the allowance and permanently DoS further creations for that pair (the contract has no function to reset allowances to zero). Potential impact: Denial of service for future legitimate gauge/farming creations using the same token and farming contract until a new factory is deployed or allowances are manually cleared via an upgrade.",
      "vulnerability_type": "denial of service",
      "severity": "medium",
      "confidence": 0.8,
      "location": "createEternalFarming(...) function",
      "file": "GaugeFactoryCL.sol",
      "id": "54a9dc3c574b3ada",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Constructor allows setting a non-contract or zero permissionRegistry, bricking all privileged functions",
      "description": "The constructor accepts an arbitrary address for permissionRegistry without validating it is a non-zero contract address. All state-changing functions are protected by Governance/GovernanceOrGenesisManager modifiers that call hasRole on permissionRegistry. If the constructor is given an EOA or address(0), subsequent calls to any protected function will revert because external calls to non-contract addresses (or to addresses without the hasRole function) fail, effectively causing a permanent denial of service. Where it occurs: constructor(address _permissionRegistry) line near deployment; modifiers Governance and GovernanceOrGenesisManager are used throughout to gate functions like setPermissionsRegistry, whitelistToken(s), blacklistToken(s), whitelistConnector(s), blacklistConnector, whitelistNFT, blacklistNFT, setBucketType, updateTokenVolatilityBucket. Why it's a security issue: A misconfigured deployment can irreversibly lock the contract, preventing governance from ever managing whitelists, connectors, or updating the registry to a correct address (since setPermissionsRegistry itself is gated by the same failing check). Potential impact: Permanent DoS of all governance-managed functionality, inability to recover by updating the registry.",
      "vulnerability_type": "denial of service",
      "severity": "medium",
      "confidence": 0.85,
      "location": "constructor(address _permissionRegistry); Governance/GovernanceOrGenesisManager modifiers used by multiple functions",
      "file": "TokenHandler.sol",
      "id": "dbff9b2e0c7f63c2",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "setPermissionsRegistry can set an incompatible contract, causing subsequent access checks to revert",
      "description": "While setPermissionsRegistry checks that the new address is a contract and not zero, it does not validate interface compatibility (i.e., that the contract implements hasRole). If governance mistakenly sets permissionRegistry to a contract without the expected function selector, all future Governance/GovernanceOrGenesisManager checks will revert (external call to a contract that does not implement hasRole reverts), locking governance functions. Where it occurs: setPermissionsRegistry(address _permissionRegistry). Why it's a security issue: A misconfiguration by governance (e.g., pointing to the wrong contract) can brick the system; since the same failing access control is required to fix it, the system becomes unrecoverable without external intervention (e.g., chain fork or admin key outside this contract). Potential impact: Denial of service of all privileged operations after misconfiguration.",
      "vulnerability_type": "denial of service / access control misconfiguration",
      "severity": "medium",
      "confidence": 0.75,
      "location": "setPermissionsRegistry() function",
      "file": "TokenHandler.sol",
      "id": "bbcae1b6028baf6f",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Reentrancy/inconsistent state in createPair allows duplicate pair deployment",
      "description": "createPair() makes an external call to pairGenerator.createPair() before updating the factory's internal mappings (getPair, isPair) and arrays (allPairs). If the pairGenerator contract (or the pair's constructor/hooks it triggers) can reenter PairFactory.createPair() for the same token pair and stable flag, the reentrant call will pass the getPair[...] == address(0) check and deploy a second pair for the same (token0, token1, stable). After both calls return, the mapping may end up pointing to only one of the deployed pairs, while the other remains in allPairs and isPair. This state inconsistency can lead to users or integrators interacting with an unintended/rogue pair because isPair[pair] is true and it appears in allPairs, even though getPair points elsewhere.\n\nWhere: createPair(address tokenA, address tokenB, bool stable). The issue is the external call to IPairGenerator(pairGenerator).createPair(...) occurring before updating getPair[...] and isPair.\n\nWhy it's a security issue: An attacker controlling or influencing pairGenerator (or exploiting any callback in the pair creation flow) could cause duplicate pairs or race conditions. Integrations that rely on isPair or allPairs (instead of getPair) could be tricked into using the unintended pair, enabling protocol manipulation, potential fund loss, or liquidity fragmentation.\n\nPotential impact: Deployment of multiple pairs for the same token pair; users interacting with incorrect pairs; protocol state corruption and potential loss of funds through misrouted liquidity or swaps.",
      "vulnerability_type": "reentrancy/state inconsistency",
      "severity": "high",
      "confidence": 0.78,
      "location": "createPair() function; external call to pairGenerator before state updates",
      "file": "PairFactory.sol",
      "id": "2fab79bff4c37c92",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "setGenesisStatus can mark non-pair addresses as genesis",
      "description": "setGenesisStatus(address _pair, bool status) does not validate that _pair is an actually created pair (isPair[_pair] == true). In contrast, setIsGenesis() (onlyManager) enforces that the address is a valid pair. Allowing genesisManager or feeManager to set genesis status on arbitrary addresses undermines data integrity. If other contracts grant special privileges, fee discounts, or altered behavior based on getIsGenesis(_pair), an authorized manager could mark an arbitrary address as genesis and potentially exploit those privileges even if the address is not a legitimate pair.\n\nWhere: setGenesisStatus(address _pair, bool status). No check for isPair[_pair].\n\nWhy it's a security issue: Downstream contracts typically assume genesis status applies only to valid pairs. This missing validation can enable privilege escalation or protocol manipulation if genesis status confers special treatment.\n\nPotential impact: Unauthorized privilege escalation for arbitrary addresses; protocol rules relying on genesis status can be bypassed or abused.",
      "vulnerability_type": "access control/data integrity",
      "severity": "medium",
      "confidence": 0.72,
      "location": "setGenesisStatus() function",
      "file": "PairFactory.sol",
      "id": "cd29f660481ac480",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Pause mechanism ineffective; createPair not gated by isPaused",
      "description": "The contract exposes a pause flag (isPaused) and a setter setPause(), but critical functions like createPair() do not check isPaused. In emergencies, the owner cannot halt pair creation via the intended pause mechanism, reducing the ability to mitigate active exploits or abuse through the factory.\n\nWhere: createPair() function lacks a require(!isPaused, ...) check; isPaused is otherwise unused.\n\nWhy it's a security issue: Operational safety mechanism is non-functional. During incidents, inability to pause can allow continued deployment of malicious or spoofed pairs, complicating incident response and risking further user harm.\n\nPotential impact: Inability to stop malicious pair creation, facilitating ongoing attack or phishing via newly created pairs.",
      "vulnerability_type": "missing pause enforcement",
      "severity": "low",
      "confidence": 0.7,
      "location": "createPair() function",
      "file": "PairFactory.sol",
      "id": "0328475c0f8c5e96",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Call to zero-address internal bribe causes hard revert in reward query",
      "description": "In _pairReward and _addInternalBribeRewards, the contract always calls IBribeAPI(internal_bribe).earned(...) without checking whether internal_bribe is the zero address. If a gauge has no internal bribe (internal_bribe == address(0)), the interface call to address(0) will revert, causing a denial of service for getAllPairRewards and any path that reaches _pairReward. This occurs in _pairReward(...) where internal_bribe is read and passed into _addInternalBribeRewards, and in _addInternalBribeRewards(...) where earned(...) is invoked unconditionally.\nWhy it's a security issue: A single misconfigured or legitimate gauge without an internal bribe can make reward retrieval revert for all users calling the view endpoint, effectively a read-DoS for UIs and integrators.\nPotential impact: Denial of service of reward introspection endpoints.",
      "vulnerability_type": "denial of service",
      "severity": "medium",
      "confidence": 0.95,
      "location": "_pairReward(address _pair, uint256 id, address _gauge) and _addInternalBribeRewards(Reward[] memory, InternalBribeInputs)",
      "file": "veNFTAPI.sol",
      "id": "053a87fb276108cc",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Using ERC721 ownerOf on non-existent token IDs causes DoS in getAllNFT",
      "description": "getAllNFT iterates arbitrary token IDs and calls ve.ownerOf(i), then checks if the returned owner is address(0). However, per ERC721, ownerOf MUST revert for non-existent token IDs rather than return address(0). Thus, when the loop encounters a non-minted ID, the function will revert. The same assumption appears in getNFTFromId (which will revert if the id does not exist).\nWhy it's a security issue: Any caller can trigger a revert by choosing ranges containing non-existent IDs, breaking read access for frontends or off-chain services.\nPotential impact: Denial of service of read endpoint.",
      "vulnerability_type": "denial of service",
      "severity": "medium",
      "confidence": 0.9,
      "location": "getAllNFT(uint256 _amounts, uint256 _offset); getNFTFromId(uint256 id)",
      "file": "veNFTAPI.sol",
      "id": "ecaf9b35e986e579",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Fixed-size temporary array can overflow in getAVMNFTFromAddress",
      "description": "getAVMNFTFromAddress allocates veNFT[] temp = new veNFT[](1000) and increments a count without bounding it. If the user owns more than 1000 matching AVM locks across all AVMs, temp[count] writes past the allocated size and the call reverts.\nWhy it's a security issue: Users with many locks will be unable to query their data, causing a DoS of the view function for those users and any integrator querying them.\nPotential impact: Denial of service for users with many AVM locks.",
      "vulnerability_type": "denial of service",
      "severity": "medium",
      "confidence": 0.95,
      "location": "getAVMNFTFromAddress(address _user)",
      "file": "veNFTAPI.sol",
      "id": "f8674a749f7c09f5",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Assuming poolForGauge always returns a valid pair can cause revert",
      "description": "In _getRewardsForNft, the contract fetches poolAddress = gaugeManager.poolForGauge(gaugeFactory.gauges(i)) and passes it to _pairReward. _pairReward immediately casts _pair to IPair and calls token0()/token1() with no validation. If poolForGauge returns address(0) or a non-pair, these calls will revert.\nWhy it's a security issue: A single misconfigured gauge or an unset mapping can break reward retrieval for all users calling getAllPairRewards.\nPotential impact: Denial of service of reward introspection endpoints.",
      "vulnerability_type": "denial of service",
      "severity": "medium",
      "confidence": 0.85,
      "location": "_getRewardsForNft(uint nftId) and _pairReward(address _pair, uint256 id, address _gauge)",
      "file": "veNFTAPI.sol",
      "id": "97245e2908b2d645",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Untrusted ERC20 metadata calls (symbol/decimals) can revert and DoS view functions",
      "description": "The contract directly calls IERC20(token).symbol() and IERC20(token).decimals() in _createReward and _getNFTFromId without guarding against non-standard or malicious tokens that revert, are extremely gas heavy, or return unexpected types. Many tokens implement non-standard metadata and can revert on these calls.\nWhy it's a security issue: A malicious or non-standard token in a bribe or pair can cause read functions to revert, breaking UIs/integrations.\nPotential impact: Denial of service of view functions that touch such tokens.",
      "vulnerability_type": "denial of service",
      "severity": "low",
      "confidence": 0.8,
      "location": "_createReward(...); _getNFTFromId(uint256 id, address _owner)",
      "file": "veNFTAPI.sol",
      "id": "9a089662293cf57b",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Payable exactInput function can lock ETH permanently",
      "description": "The function exactInput is declared payable but contains no logic to handle or refund ETH and has no path to unwrap/deposit or withdraw it. Any ETH sent with the call will remain stuck in the contract since the contract lacks a receive/fallback or any withdrawal mechanism. This occurs in exactInput(IRouterV3.ExactInputParams memory params). It's a security issue because users or integrators might mistakenly send ETH expecting a swap (as suggested by the interface comments) and lose funds that cannot be recovered. Potential impact: permanent loss of ETH sent to the function.",
      "vulnerability_type": "funds lock / improper payable handling",
      "severity": "medium",
      "confidence": 0.9,
      "location": "exactInput() function",
      "file": "GlobalRouter.sol",
      "id": "89e8e8f36b95e09c",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Critical trust in external tradeHelper allows token redirection",
      "description": "The router fully trusts the external tradeHelper to compute pair addresses and sorting without any validation. In swapExactTokensForTokens, it transfers tokens directly to the address returned by tradeHelper.pairFor(...) and then calls swap on the same returned address in _swap. If the tradeHelper is malicious, compromised, or incorrectly configured at deployment, it can return attacker-controlled addresses. This would cause _safeTransferFrom to move user tokens to an arbitrary address and IBaseV1Pair(...).swap to be invoked on a malicious contract that can steal funds or behave unexpectedly. There is no verification that the returned address is a genuine pair (e.g., via a known factory or code hash) nor a sanity check with a trusted factory. Impact: theft of user funds and complete manipulation of swap flows.",
      "vulnerability_type": "external dependency trust / access control",
      "severity": "high",
      "confidence": 0.7,
      "location": "swapExactTokensForTokens() and _swap() functions (use of tradeHelper.pairFor and sortTokens)",
      "file": "GlobalRouter.sol",
      "id": "de3d024245c4227e",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Potential overflow in stable-curve math can brick swaps (DoS)",
      "description": "The stable pool pricing functions perform multiple chained multiplications on potentially large reserve values without intermediate scaling safeguards. In Solidity 0.8.x, arithmetic overflows revert. In pools with large reserves or tokens with large decimals, the following functions can overflow and cause swaps and quotes to revert, effectively bricking the pool: _f(), _d(), _get_y(), and _k() when stable == true. This results in a denial of service for trading and quoting once reserves reach values that cause overflows.\n- Where: _f(), _d(), _get_y(), _k() (stable branch), and any function that uses them: _getAmountOut(), swap(), getAmountOut(), current(), sample()/prices()/quote() for stable pairs.\n- Why: Expressions like (_x * _x) / 1e18 and combinations thereof can overflow uint256 before division when _x and/or _y are large due to high reserves and 1e18 scaling.\n- Impact: Swaps and price queries revert for affected stable pairs, causing protocol-level DoS for that pair.",
      "vulnerability_type": "denial of service",
      "severity": "high",
      "confidence": 0.7,
      "location": "_f(), _d(), _get_y(), _k() (stable curve), and callers (swap, getAmountOut, current, sample/quote/prices)",
      "file": "Pair.sol",
      "id": "5f8ad4b4e9e16ee0",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Observation-based price query can revert in early lifecycle (array underflow/zero division)",
      "description": "The TWAP view function current() assumes at least two observations or that the last observation\u2019s timestamp is different from the current block. If called in the same block as deployment/initialization when only one observation exists, the code attempts to access observations[observations.length-2], which underflows and reverts. Additionally, when sampling in current(), division by timeElapsed occurs without checking that timeElapsed > 0.\n- Where: current() around the logic that replaces the last observation with observations[observations.length-2] when block.timestamp == lastObservation.timestamp.\n- Why: Accessing index length-2 when length == 1 underflows; division by timeElapsed with timeElapsed == 0 reverts.\n- Impact: Off-chain or on-chain integrations calling current() immediately after deployment or within the same block as the last observation may experience unexpected reverts (read DoS) hindering price reads.",
      "vulnerability_type": "denial of service",
      "severity": "low",
      "confidence": 0.75,
      "location": "current() function (observation handling and timeElapsed division)",
      "file": "Pair.sol",
      "id": "b594ddd091eeb787",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Exponentiation of token decimals can overflow and revert during deployment",
      "description": "The constructor computes decimals0 and decimals1 as 10**IERC20(token).decimals(). If a paired token reports an unusually large decimals value (e.g., malicious or non-standard ERC20), 10**decimals will overflow and revert in Solidity 0.8.x. This can prevent pair deployment/initialization or cause unexpected constructor failure.\n- Where: constructor: decimals0 = 10**IERC20(_token0).decimals(); decimals1 = 10**IERC20(_token1).decimals();\n- Why: Unbounded exponentiation on untrusted token decimals can overflow uint256.\n- Impact: Denial of service at deployment time for pairs with tokens reporting extreme decimals; the pool cannot be created.",
      "vulnerability_type": "denial of service",
      "severity": "low",
      "confidence": 0.8,
      "location": "constructor (decimals0/decimals1 calculations)",
      "file": "Pair.sol",
      "id": "7de13656449cb9a6",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Denial of service via untrusted token metadata/balance calls",
      "description": "The contract makes external calls to arbitrary token contracts returned by tokenHandler without any error handling. In getWhiteListedTokens() and getConnectorTokens(), it calls decimals() and symbol() on each token; in getTokenBalances(), it calls balanceOf() for each provided token. If any token is non-standard or malicious and reverts on these calls (e.g., tokens that don't implement these optional metadata functions or intentionally revert/return huge data), the entire function reverts, causing a denial of service for these read APIs. This occurs in getWhiteListedTokens(), getConnectorTokens(), and getTokenBalances() where IERC20(token).decimals(), IERC20(token).symbol(), and IERC20(token).balanceOf(_user) are invoked in loops. Impact: a single problematic token in tokenHandler.whiteListedTokens()/connectorTokens() or in the input list can block the ability of frontends, off-chain services, or on-chain integrators to retrieve data through these functions; large/hostile return data can also cause excessive gas/memory usage leading to out-of-gas failures.",
      "vulnerability_type": "denial of service",
      "severity": "medium",
      "confidence": 0.86,
      "location": "getWhiteListedTokens(), getConnectorTokens(), getTokenBalances()",
      "file": "TokenAPI.sol",
      "id": "7059faf8415e500a",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Unprotected initialization allows arbitrary tokenHandler to be set if not initialized",
      "description": "The initialize(address _tokenHandler) function is public and can be called by anyone for the first (and only) time due to the initializer modifier. If this contract instance (proxy) is deployed and not initialized immediately, an attacker can front-run initialization and set tokenHandler to a malicious address, effectively taking control over the data source and potentially causing persistent DoS (by returning huge arrays or reverting) or misleading data. While no funds are held by this contract, this is still unauthorized configuration control and can disrupt dependent systems. This occurs in initialize(...), which lacks access control beyond the initializer guard.",
      "vulnerability_type": "access control",
      "severity": "low",
      "confidence": 0.7,
      "location": "initialize(address _tokenHandler)",
      "file": "TokenAPI.sol",
      "id": "6237478ccebfac9b",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Missing existence check in releaseLock allows arbitrary removal and state corruption",
      "description": "The releaseLock function does not verify that the provided _tokenId actually exists in the locks array before performing the swap-and-pop removal. It reads the index from tokenIdIndex[_tokenId] without verifying that locks[index].tokenId == _tokenId. Since mappings default to 0, passing a non-existent _tokenId will set index to 0, causing the function to overwrite and remove the wrong element (the element at index 0 gets overwritten by the last element and effectively removed), while leaving a stale tokenIdIndex entry for the removed token. This corrupts the internal bookkeeping and can result in approving and releasing the wrong NFT. Impact: - Data corruption of locks and tokenIdIndex - Inadvertent approval of the wrong tokenId to the manager - Potential loss of user NFT due to incorrect release - Subsequent calls (lockOwner, releaseLock) may operate on unintended locks. Occurs in: releaseLock(uint256 _tokenId).",
      "vulnerability_type": "data integrity / logic flaw",
      "severity": "high",
      "confidence": 0.9,
      "location": "releaseLock(uint256 _tokenId)",
      "file": "AutoVotingEscrow.sol",
      "id": "6aba037c014eadc7",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "lockOwner may return incorrect owner for non-existent tokenId",
      "description": "lockOwner reads index = tokenIdIndex[_tokenId] and only checks index < locks.length, but does not verify that locks[index].tokenId == _tokenId. For a non-existent _tokenId, tokenIdIndex returns 0 by default, and if locks.length > 0, the function will return locks[0].owner, leaking incorrect ownership information and masking the absence of the token. This also contributes to silent state misuse after the corruption described in releaseLock. Occurs in: lockOwner(uint256 _tokenId). Impact: - Incorrect owner information returned - Can mislead off-chain and on-chain consumers and contribute to further erroneous operations.",
      "vulnerability_type": "data integrity / logic flaw",
      "severity": "medium",
      "confidence": 0.85,
      "location": "lockOwner(uint256 _tokenId)",
      "file": "AutoVotingEscrow.sol",
      "id": "be5237d635749f45",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "acceptLock allows duplicate tokenIds leading to inconsistent state",
      "description": "acceptLock does not check whether a _tokenId is already tracked. Pushing the same _tokenId multiple times will create duplicate entries in locks while overwriting tokenIdIndex[_tokenId] with the latest index. This breaks the invariant that tokenIdIndex maps uniquely to a single position and can cause releaseLock to remove or approve the wrong entry, or make some duplicates unreachable by index. Occurs in: acceptLock(address _owner, uint256 _tokenId). Impact: - Inconsistent state between locks and tokenIdIndex - Potential removal/approval of unintended lock during releaseLock - Increased risk of DoS or corruption when performing batch operations.",
      "vulnerability_type": "data integrity / logic flaw",
      "severity": "medium",
      "confidence": 0.8,
      "location": "acceptLock(address _owner, uint256 _tokenId)",
      "file": "AutoVotingEscrow.sol",
      "id": "ad4211c5d671b931",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Missing zero-address checks for bribe contracts causes DoS in read functions",
      "description": "The helper _getBribes() retrieves bribe contract addresses via gaugeManager.external_bribes() and gaugeManager.internal_bribes() and then unconditionally calls _getNextEpochRewards() with those addresses. If either bribe address is the zero address (or a non-contract), _getNextEpochRewards() will attempt to call IBribeAPI methods on that address. High-level external calls to an address with no code return empty data, which then causes decoding to revert (e.g., rewardsListLength() returning empty). This reverts the entire view call chain (e.g., getAllPoolInfo/getPoolInfo) leading to denial of service for API consumers.",
      "vulnerability_type": "denial of service",
      "severity": "medium",
      "confidence": 0.82,
      "location": "_getBribes() and _getNextEpochRewards()",
      "file": "AlgebraPoolAPI.sol",
      "id": "8a1d4507c132c6a1",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Untrusted ERC20 metadata/balance calls can revert and DoS aggregator views",
      "description": "The contract calls symbol(), decimals(), and balanceOf() on arbitrary token addresses obtained from pools or bribe lists without safety wrappers. Many tokens are non-standard and may revert on metadata calls or not implement them at all. Any such revert will bubble up and revert the entire read, causing denial of service for API endpoints. Affected paths: _poolAddressToInfo() calls IERC20(token0).symbol()/decimals and IERC20(token1).symbol()/decimals; getAllPositionsInfo() calls symbol()/decimals() for both tokens and balanceOf(_user); _getNextEpochRewards() calls IERC20(_token).symbol()/decimals() for each bribe token. If any token is non-compliant or malicious, these calls can revert.",
      "vulnerability_type": "denial of service",
      "severity": "low",
      "confidence": 0.78,
      "location": "_poolAddressToInfo(), getAllPositionsInfo(), _getNextEpochRewards()",
      "file": "AlgebraPoolAPI.sol",
      "id": "a93c2082c875f042",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Unchecked underflow in prevPreEpoch can wrap to a huge timestamp",
      "description": "The function prevPreEpoch subtracts NO_GENESIS_DEPOSIT_WINDOW (600) from epochStart(timestamp) inside an unchecked block. If timestamp is within the very first epoch (i.e., timestamp < WEEK = 1800), then epochStart(timestamp) == 0, and 0 - 600 underflows to a very large uint256 value. Location: prevPreEpoch(uint256), lines 72-75. This is a security issue because calling code that relies on prevPreEpoch to define a time window (e.g., to allow/deny deposits in a pre-epoch window) can be manipulated into mis-evaluating comparisons. For example, checks like now >= prevPreEpoch(...) may always be false for normal timestamps, causing denial of service, or comparisons like prevPreEpoch(...) <= x may unexpectedly pass if x overflows logic elsewhere. Impact: logical time-window bypass or denial of service in any consumer that performs comparisons with this returned value.",
      "vulnerability_type": "integer underflow / arithmetic wraparound",
      "severity": "medium",
      "confidence": 0.85,
      "location": "prevPreEpoch(uint256) function, lines 72-75",
      "file": "BlackTimeLibrary.sol",
      "id": "345aa47bf4a82a81",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Unchecked underflow in isLastEpoch may misclassify time window when endTime < WEEK",
      "description": "The function isLastEpoch computes endTime - WEEK inside an unchecked block and compares it to timestamp. If endTime < WEEK (e.g., zero or very small), endTime - WEEK underflows to a huge uint256. Location: isLastEpoch(uint256,uint256), lines 64-67. This can cause incorrect results: the intended check for timestamp in [endTime - WEEK, endTime) becomes almost certainly false (or otherwise incorrect), breaking access control or gating logic based on last-epoch checks. Potential impact: denial of service (actions incorrectly blocked) or logic bypass depending on how the result is used by consuming contracts.",
      "vulnerability_type": "integer underflow / arithmetic wraparound",
      "severity": "low",
      "confidence": 0.7,
      "location": "isLastEpoch(uint256,uint256) function, lines 64-67",
      "file": "BlackTimeLibrary.sol",
      "id": "ce1ae78e8629a02b",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Integer truncation when forwarding rewards to AlgebraEternalFarming can lock/strand funds",
      "description": "In notifyRewardAmount, the function forwards the reward amount to AlgebraEternalFarming via addRewards using a uint128 cast: algebraEternalFarming.addRewards(incentivekey, uint128(reward), 0). If reward exceeds 2^128-1, the value will be truncated, causing only the lower 128 bits to be forwarded while the full reward amount was transferred to this contract and approved. This discrepancy can strand the excess tokens in the Gauge contract, leading to accounting mismatches and potential permanent loss of rewards to stakers until manual recovery.\n\n- Where: notifyRewardAmount(), call to addRewards with uint128(reward)\n- Why it's a security issue: Truncation on downcast silently reduces the forwarded amount; excess tokens remain stuck in the contract and are not distributed as intended.\n- Potential impact: Loss of funds distribution (excess rewards not sent to farming), stranded tokens in contract, reward schedule disruption.",
      "vulnerability_type": "integer truncation",
      "severity": "medium",
      "confidence": 0.85,
      "location": "notifyRewardAmount() function, uint128(reward) argument to addRewards",
      "file": "GaugeCL.sol",
      "id": "05376642a14674d3",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Ineffective zero-address check allows setting internal_bribe to address(0), causing DoS in fee distribution",
      "description": "The setInternalBribe function uses require(_int >= address(0), \"zero\"); which always passes because any address is >= address(0). This allows setting internal_bribe to the zero address. Later, claimFees calls IBribe(internal_bribe).notifyRewardAmount(...), which will revert if internal_bribe is address(0). This can permanently block fee distribution and trap fee tokens in the contract until the bribe address is corrected.\n\n- Where: setInternalBribe(), require(_int >= address(0), \"zero\"); and subsequent use in _claimFees()/claimFees()\n- Why it's a security issue: Misvalidation enables an invalid configuration that breaks core functionality.\n- Potential impact: Denial of service of fee distribution; tokens may remain stuck in the Gauge, requiring owner intervention to restore.",
      "vulnerability_type": "improper input validation",
      "severity": "low",
      "confidence": 0.95,
      "location": "setInternalBribe() function; impact in claimFees()/_claimFees()",
      "file": "GaugeCL.sol",
      "id": "44e9c72dbb21a80c",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "setRouter allows only zero address and can brick pool launches",
      "description": "The setRouter function uses an inverted zero-address check: require(_router == address(0), \"ZA\"); followed by router = _router. This logic only allows setting the router to the zero address and prevents updating it to any valid non-zero router. If the owner calls this function, it will set the router to address(0), and future launches via _launchPool will call IGenesisPool.launch(router, MATURITY_TIME) with a zero router. Depending on IGenesisPool implementation, this can break or revert launches, causing denial of service for the protocol's core flow and potentially locking funds or preventing liquidity provisioning.\nWhere: setRouter(address _router) function.\nWhy it's a security issue: A privileged account (owner) can unintentionally or maliciously set a critical dependency to an invalid address and the contract provides no way to correct it, leading to persistent DoS of pool launch operations.\nPotential impact: - Inability to launch pools (DoS)\n- Funds stuck in genesis pools if launch is required to progress states or distribute assets\n- Protocol governance cannot fix router via this function due to the inverted check",
      "vulnerability_type": "access control / logic error leading to denial of service",
      "severity": "high",
      "confidence": 0.92,
      "location": "setRouter() function",
      "file": "GenesisPoolManager.sol",
      "id": "c3e4022f54ebcb40",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Unbounded iteration over liveNativeTokens can cause epoch flip DoS",
      "description": "Both checkAtEpochFlip and checkBeforeEpochFlip iterate over the entire liveNativeTokens array in a single transaction, making external calls per element (e.g., to IGenesisPool, pairFactory, tokenHandler, gaugeManager). As liveNativeTokens grows, these loops can exceed block gas limits, causing these maintenance functions to revert and preventing epoch-related transitions. Since only epochController can call them, a large array (legitimate or adversarially grown via approvals) can permanently prevent state transitions tied to epoch flips.\nWhere: checkAtEpochFlip() and checkBeforeEpochFlip() functions.\nWhy it's a security issue: Unbounded loops over dynamic arrays that can grow without caps enable gas-based denial of service, blocking critical protocol operations at epoch boundaries.\nPotential impact: - Denial of service for epoch flips\n- Pools stuck in PRE_LISTING/PRE_LAUNCH states\n- Protocol unable to progress to launch/disqualify pools, potentially trapping user funds or delaying distributions",
      "vulnerability_type": "denial of service (unbounded iteration)",
      "severity": "medium",
      "confidence": 0.7,
      "location": "checkAtEpochFlip(), checkBeforeEpochFlip()",
      "file": "GenesisPoolManager.sol",
      "id": "a60c720ae442b56e",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Denial-of-service in getGenesisPool due to zeroed pool entries",
      "description": "The removeGenesisPool functions set entries in genesisPools[nativeToken] to the zero address without adjusting the array length. The getGenesisPool function then unconditionally calls poolStatus() on the last element if length > 0. When the last element has been zeroed, this results in a call to IGenesisPool(address(0)).poolStatus(), which reverts. This occurs in getGenesisPool (when it accesses the last element and calls poolStatus) and is triggered by removeGenesisPool(address) and removeGenesisPool(address,uint256) zeroing entries. As a result, any external call to getGenesisPool for that nativeToken will revert, and createGenesisPool will also revert because it requires getGenesisPool(nativeToken) == address(0) and evaluates getGenesisPool, causing a revert first. Impact: persistent DoS for read functions and pool creation after a zeroing operation, breaking integrations and preventing new pools from being created until a non-zero last element exists.",
      "vulnerability_type": "denial of service",
      "severity": "medium",
      "confidence": 0.9,
      "location": "getGenesisPool() view function; triggered by removeGenesisPool(address) and removeGenesisPool(address,uint256)",
      "file": "GenesisPoolFactory.sol",
      "id": "13fff116084e131a",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Upgradeable implementation can be maliciously initialized",
      "description": "The contract follows the upgradeable pattern (OwnableUpgradeable, initialize()), but the constructor is empty and does not call _disableInitializers(). If the implementation contract (not the proxy) is deployed and left uninitialized, any actor can call initialize and set themselves as owner and genesisManager. While typical deployments interact via a proxy, leaving the implementation uninitialized is a known risk: a compromised or misused implementation instance could hold funds (now or after upgrades) or be mistakenly interacted with by integrations, enabling unauthorized control. Best practice is to disable initializers in the implementation constructor to prevent takeover.",
      "vulnerability_type": "access control / upgradeability misconfiguration",
      "severity": "low",
      "confidence": 0.7,
      "location": "constructor() and initialize(address) functions",
      "file": "GenesisPoolFactory.sol",
      "id": "c911b7c0c5878ac4",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Unrestricted token recovery allows admin to drain reward (BLACK) tokens",
      "description": "The recoverERC20 function allows an owner to transfer out the entire balance of any ERC20 token held by the contract, including the season's reward token (BLACK). This contradicts the comment that it \"Cannot be called to withdraw emissions tokens\" and enables an authorized owner to rug the reward pool after finalize(), preventing users from claiming or staking rewards and causing loss of funds. Where: recoverERC20(address tokenAddress_), near end of file. Why: There is no restriction preventing recovery of the core rewards token (address(token)). Impact: Admin can drain BLACK from this contract at any time, breaking the protocol\u2019s accounting (season.remaining_reward_amount will no longer match actual token balance), leading to failed claims/locks and loss of user funds.",
      "vulnerability_type": "access control",
      "severity": "high",
      "confidence": 0.9,
      "location": "recoverERC20(address tokenAddress_) function",
      "file": "BlackClaims.sol",
      "id": "89c2753ff6832aa8",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Potential division-by-zero in amount calculation functions",
      "description": "The functions getNativeTokenAmount and getFundingTokenAmount perform division using values returned from IGenesisPool(msg.sender).getAllocationInfo() without validating that the denominators are non-zero. Specifically:\n- getNativeTokenAmount divides by tokenAllocation.proposedFundingAmount\n- getFundingTokenAmount divides by tokenAllocation.proposedNativeAmount\nIf either denominator is zero (due to misconfiguration or malicious pool settings), these calls will revert, causing a denial of service for callers relying on these functions. Impact: Pools or integrators using this auction strategy can be bricked or experience unexpected reverts if allocation parameters are zero.",
      "vulnerability_type": "arithmetic error / input validation",
      "severity": "medium",
      "confidence": 0.7,
      "location": "getNativeTokenAmount(uint256), getFundingTokenAmount(uint256)",
      "file": "FixedAuction.sol",
      "id": "1d5664a1fa1a9912",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Implementation contract not locked against initialization",
      "description": "The upgradeable contract exposes an initialize() function guarded by initializer, but the implementation/logic contract constructor does not call _disableInitializers() (OpenZeppelin pattern). This allows anyone to call initialize() on the implementation contract itself, acquiring ownership of the implementation. While this contract currently has no owner-gated state-changing functions, leaving the implementation initializable is a known upgradeability risk and can have security implications if the implementation is ever used incorrectly or extended in future upgrades.\nImpact: Potential takeover of the implementation contract\u2019s ownership, which could be abused in certain deployment patterns or future code changes.",
      "vulnerability_type": "upgradeability / initialization",
      "severity": "low",
      "confidence": 0.8,
      "location": "constructor() and initialize()",
      "file": "FixedAuction.sol",
      "id": "530503e6388f1387",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Unchecked ERC20 transfer return values can cause silent failures and accounting desync",
      "description": "The contract calls ERC20.transfer without checking the return value. If the token returns false (non-reverting failure), the transfer will silently fail, but internal accounting (token_last_balance) is still decremented, resulting in funds remaining stuck in the contract while claims are reported as successful. This occurs in claim() and claim_many() when transferring rewards to the NFT owner, and in withdrawERC20() when the owner withdraws tokens. Because token_last_balance is reduced despite a failed transfer, subsequent checkpointing may treat the leftover tokens as new rewards or the owner could later withdraw them via withdrawERC20, leading to loss for claimants.\n- Where: claim() and claim_many() (calls to IERC20(token).transfer), withdrawERC20() (calls to IERC20(_token).transfer)\n- Why: ERC20 standard allows returning false; not checking it breaks assumptions that transfers succeeded.\n- Impact: Users may not receive due rewards while internal counters assume they did; rewards can be stranded or siphoned later, causing loss of funds and protocol accounting corruption.",
      "vulnerability_type": "token handling / unchecked ERC20 return value",
      "severity": "high",
      "confidence": 0.9,
      "location": "claim(), claim_many(), withdrawERC20()",
      "file": "RewardsDistributor.sol",
      "id": "da527f494c971273",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Misdirected payouts in claim_many for AVM-managed NFTs",
      "description": "In claim_many(), when a lock has expired and is not permanent, rewards are transferred to IVotingEscrow(_voting_escrow).ownerOf(_tokenId). Unlike claim(), there is no special handling for AVM-managed token IDs to send rewards to the original owner via avm.getOriginalOwner(_tokenId). This inconsistency causes rewards for AVM-managed NFTs to be sent to the AVM holder/contract instead of the intended original owner.\n- Where: claim_many() expired-lock branch uses ownerOf(_tokenId) directly; claim() handles AVM via avm.tokenIdToAVMId() and getOriginalOwner().\n- Why: Missing AVM owner resolution in claim_many.\n- Impact: Loss of funds for users whose NFTs are managed by the AVM, as their rewards can be captured by the manager/holder instead of the original owner.",
      "vulnerability_type": "logic error / incorrect recipient",
      "severity": "high",
      "confidence": 0.95,
      "location": "claim_many()",
      "file": "RewardsDistributor.sol",
      "id": "a0ddbc7b7cff2a8e",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Owner can withdraw reward tokens arbitrarily",
      "description": "The owner can withdraw any ERC20 token from the contract via withdrawERC20(), including the reward token used for emissions (token). There is no restriction or timelock. This allows the owner (or a compromised owner key) to rug the rewards, causing user losses and breaking the emissions schedule.\n- Where: withdrawERC20(address _token) allows withdrawing any token.\n- Why: No restriction preventing withdrawal of the reward token or limiting amounts.\n- Impact: Loss of funds and protocol manipulation via arbitrary draining of reward balances.",
      "vulnerability_type": "access control / centralization risk",
      "severity": "high",
      "confidence": 0.85,
      "location": "withdrawERC20()",
      "file": "RewardsDistributor.sol",
      "id": "771cf0918e37d4fe",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Accounting drift with fee-on-transfer or deflationary tokens",
      "description": "The contract assumes transfers move exactly the requested amount and updates token_last_balance by subtracting amount sent. With fee-on-transfer/deflationary tokens, the actual balance reduction is less than amount, but token_last_balance is still decreased by the full amount. This causes token_balance - token_last_balance in _checkpoint_token() to overestimate newly available rewards, effectively double-counting fees as distributable. Eventually, claims can attempt to distribute more than actual balance, leading to failed transfers and stuck rewards.\n- Where: claim() and claim_many() decrement token_last_balance by amount; _checkpoint_token() computes to_distribute as balanceOf(this) - token_last_balance.\n- Why: No accounting for transfer fees or non-1:1 transfers.\n- Impact: Over-distribution accounting, failed payouts (DoS on claim paths), and stranded funds.",
      "vulnerability_type": "token handling / accounting error",
      "severity": "medium",
      "confidence": 0.8,
      "location": "claim(), claim_many(), _checkpoint_token()",
      "file": "RewardsDistributor.sol",
      "id": "74de002a066305d0",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Arithmetic overflow on int128 bias/slope math can revert and cause Denial of Service",
      "description": "Several functions perform arithmetic on int128 fields (bias and slope) and, under Solidity 0.8.x, any overflow/underflow will revert the call. Specifically, products like slope * deltaTime are cast to int128 and then subtracted from bias. If slope or the time delta are large enough, the multiplication or subtraction can overflow int128 and revert. This affects:\n- balanceOfNFT: last_point.bias -= last_point.slope * int128(int256(_t) - int256(last_point.ts));\n- balanceOfAtNFT: upoint.bias -= upoint.slope * int128(int256(block_time - upoint.ts));\n- _supply_at (used by totalSupplyAt and totalSupplyAtT): last_point.bias -= last_point.slope * int128(int256(t_i - last_point.ts));\nWhy it's a security issue: A revert in these view functions can break on-chain integrations that depend on them (e.g., governance adapters tallying voting power or other contracts reading total supply/weights). In particular, _supply_at operates on global state (aggregate slope), so an attacker who can push the aggregate slope near int128 limits (e.g., by creating very large locks if not capped) could cause totalSupplyAt/totalSupplyAtT to revert for everyone at certain timestamps, leading to a read-level DoS for protocols relying on these values.\nPotential impact: System-wide inability to read voting power or total supply at certain times, breaking governance, fee distribution, or any mechanism that consumes these values.",
      "vulnerability_type": "arithmetic overflow / denial of service",
      "severity": "high",
      "confidence": 0.7,
      "location": "balanceOfNFT(), balanceOfAtNFT(), _supply_at(), totalSupplyAt(), totalSupplyAtT()",
      "file": "VotingBalanceLogic.sol",
      "id": "7ccbf263ec8f895d",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Use of assert for user-controlled input can cause hard revert (panic) and gas griefing",
      "description": "The functions balanceOfAtNFT and totalSupplyAt use assert(_block <= block.number). Using assert for input validation triggers a Panic on failure and consumes all remaining gas, rather than providing a controlled revert. If these functions are callable through other contracts or used within multi-call flows, a malicious caller can supply a future block number to force a panic revert and potentially grief integrations relying on catching standard reverts.\nWhy it's a security issue: Although primarily a correctness/UX issue in isolation, using assert here can be abused to cause harder-to-handle failures and maximize gas loss for integrators when the input is not trusted or forwarded.\nPotential impact: Denial of service/griefing of read flows or transactions that aggregate view calls; harder error handling due to Panic instead of standard revert.",
      "vulnerability_type": "improper input validation / denial of service",
      "severity": "low",
      "confidence": 0.8,
      "location": "balanceOfAtNFT() and totalSupplyAt() input validation",
      "file": "VotingBalanceLogic.sol",
      "id": "7c66f6f844089100",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Initializer front\u2011running risk (proxy could be initialized by attacker if not set atomically)",
      "description": "The initialize function can be called by anyone until it is executed once. If the proxy deployer fails to initialize the proxy in the same transaction as deployment, an attacker could front\u2011run and call initialize, setting arbitrary genesisManager and genesisPoolFactory addresses. While this contract is an API (view-only) and does not move funds, poisoning these addresses can cause consumers of this contract to read attacker-controlled data, potentially leading to incorrect decisions by integrators or breaking dependent workflows.\n- Where: initialize() function\n- Why it's a security issue: Improperly initialized upgradeable contracts can be claimed by attackers. Here it allows an attacker to set core references (manager/factory) permanently.\n- Potential impact: On-chain and off-chain consumers relying on this API may fetch incorrect pool data or suffer DoS if attacker-provided addresses revert or return huge datasets.",
      "vulnerability_type": "access control / improper initialization",
      "severity": "low",
      "confidence": 0.55,
      "location": "initialize(address _genesisManager, address _genesisPoolFactory)",
      "file": "GenesisPoolAPI.sol",
      "id": "c0e1907a2071006b",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Potential denial of service due to unbounded external iteration over manager/factory returned arrays",
      "description": "The contract iterates over arrays returned by external contracts (manager/factory) without enforcing upper bounds beyond the _amounts parameter or overall token/pool counts returned by those external contracts. If genesisManager or genesisPoolFactory (or the tokens/pools they reference) return very large arrays, these view functions can run out of gas and become unusable on-chain.\n- Where: getAllGenesisPools() iterates over genesisManager.getLiveNaitveTokens(); getAllUserRelatedGenesisPools() iterates over genesisManager.getAllNaitveTokens() and genesisPoolFactory.getGenesisPools(nativeToken).\n- Why it's a security issue: A malicious or compromised manager/factory can cause these functions to always revert due to out-of-gas, resulting in DoS for on-chain callers and potentially off-chain systems relying on eth_call.\n- Potential impact: Denial of service for data retrieval, preventing other contracts or frontends from consuming API data.",
      "vulnerability_type": "denial of service",
      "severity": "medium",
      "confidence": 0.7,
      "location": "getAllGenesisPools(address _user, uint _amounts, uint _offset); getAllUserRelatedGenesisPools(address _user)",
      "file": "GenesisPoolAPI.sol",
      "id": "ac4ff5b6dfdd37da",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Trusting external token/pool contracts for view calls can cause DoS (non\u2011standard or malicious tokens/pools)",
      "description": "The contract calls external view functions on arbitrary token and pool addresses provided by external sources or user input (e.g., IERC20.decimals(), IGenesisPool.*). Non\u2011standard ERC20 tokens may not implement decimals() or may revert, and malicious contracts could revert intentionally. This can cause the API methods to revert, denying service to callers.\n- Where: multiple places including _getGenesisPool(), getAllGenesisPools(), getAllUserRelatedGenesisPools() when calling IERC20(nativeToken).decimals(), IERC20(fundingToken).decimals(), and various IGenesisPool getters.\n- Why it's a security issue: External untrusted contracts can force these view calls to revert or consume excessive gas, breaking data retrieval.\n- Potential impact: Denial of service for API functions, breaking integrations relying on these calls.",
      "vulnerability_type": "denial of service",
      "severity": "low",
      "confidence": 0.8,
      "location": "_getGenesisPool(address _user, address genesisPool); getAllGenesisPools(...); getAllUserRelatedGenesisPools(...)",
      "file": "GenesisPoolAPI.sol",
      "id": "3dd8ff8c7b6df87c",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Incompatible vote snapshot parameter leads to governance DoS",
      "description": "The _getVotes function calls token.getPastVotes(account, blockTimestamp) passing a block timestamp instead of a block number. OpenZeppelin's IVotes (and standard ERC20Votes/ERC721Votes) expect the second parameter to be a historical block number. Supplying a timestamp will typically violate the precondition require(blockNumber < block.number) in standard implementations (e.g., ERC20Votes), causing a revert such as \"block not yet mined\". This would break vote weight retrieval for proposals and voting, effectively halting governance operations. If the token happens to implement a timestamp-based variant under the same IVotes interface, this silent mismatch could also enable subtle logic issues. Location: _getVotes function in L2GovernorVotes, parameter named blockTimestamp.",
      "vulnerability_type": "denial of service / logic incompatibility",
      "severity": "high",
      "confidence": 0.8,
      "location": "_getVotes(address account, uint256 blockTimestamp, bytes) function",
      "file": "L2GovernorVotes.sol",
      "id": "5e919bc8bacb8d1c",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Signed-to-unsigned cast allows bypass of minimum balance check",
      "description": "In enableAutoVoting, the contract checks a veNFT\u2019s locked amount using a signed-to-unsigned cast: require(uint256(int256(votingEscrow.locked(tokenId).amount)) >= minBalanceForAutovoting, \"IB\"). If locked(tokenId).amount is negative (e.g., expired or otherwise represented as a negative int), casting a negative int256 to uint256 will wrap to a very large positive value in Solidity 0.8.x (explicit conversions do not revert). This will incorrectly satisfy the >= minBalanceForAutovoting check, allowing autovoting to be enabled for ineligible locks. This occurs in enableAutoVoting(), at the require that checks the min balance. Security impact: an attacker can enable autovoting for zero/expired locks, occupying AVM capacity, skewing internal accounting/assumptions, and potentially manipulating voting operations or causing denial of service by filling AVMs with ineligible tokens. Where: enableAutoVoting() function, the line with uint256(int256(votingEscrow.locked(tokenId).amount)) >= minBalanceForAutovoting.",
      "vulnerability_type": "type conversion / validation bug",
      "severity": "high",
      "confidence": 0.95,
      "location": "enableAutoVoting() function, min-balance require using uint256(int256(...))",
      "file": "AutoVotingEscrowManager.sol",
      "id": "4155f83d20a692b5",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Reentrancy via external helper calls during state mutation",
      "description": "The library performs external calls to helper functions (ownerOfFn, ownerToNFTokenCountFn, tokenOfOwnerByIndex) inside loops while it is actively mutating storage (creating/updating checkpoints and pushing/popping tokenIds). This occurs in moveTokenDelegates() and _moveAllDelegates(). Because Solidity's 'view' is not enforced at runtime, a malicious implementation of these function pointers can reenter the calling contract and invoke library functions again (or other sensitive logic) while the Data storage is in an inconsistent, partially-updated state. This can lead to corrupted checkpoints, bypass of MAX_DELEGATES enforcement, or other logic manipulation depending on the caller's contract. Potential impact includes privilege escalation, data corruption of vote records, or locking operations via crafted reentrancy flows.",
      "vulnerability_type": "reentrancy",
      "severity": "high",
      "confidence": 0.75,
      "location": "External calls inside state-mutating loops in moveTokenDelegates() and _moveAllDelegates(); calls to ownerOfFn, ownerToNFTokenCountFn, tokenOfOwnerByIndex",
      "file": "VotingDelegationLib.sol",
      "id": "90044c72b9a68e8c",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Duplicate tokenIds can be inserted into delegate checkpoints",
      "description": "The library appends tokenIds to a delegate's current checkpoint without verifying that the tokenId is not already present. In moveTokenDelegates(), when updating dstRep in the same block (i.e., not creating a new checkpoint), the code unconditionally pushes _tokenId to dstRepNew. Repeated invocations within the same block with the same parameters can insert the same tokenId multiple times. Similarly, in _moveAllDelegates(), the code pushes all owner's tokens to dstRep without deduplication, which can also create duplicates in the current checkpoint when called multiple times in the same block (or if some of those tokens were already present from prior actions). This can corrupt vote accounting if downstream logic counts entries, enabling vote inflation/protocol manipulation, and can also bloat arrays toward MAX_DELEGATES prematurely.",
      "vulnerability_type": "data corruption / protocol manipulation",
      "severity": "high",
      "confidence": 0.7,
      "location": "dstRep update logic in moveTokenDelegates() (unconditional dstRepNew.push(_tokenId)); owner aggregation in _moveAllDelegates() (loop pushing tokenOfOwnerByIndex without deduplication)",
      "file": "VotingDelegationLib.sol",
      "id": "b1b3e11d456b3a98",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Potential DoS via untrusted helper functions reverting or consuming excessive gas",
      "description": "The library relies on external function pointers (ownerOfFn, ownerToNFTokenCountFn, tokenOfOwnerByIndex) for core logic inside loops. If these point to untrusted contracts (or are upgradable), an attacker can force reverts or heavy computation during these calls, causing delegation operations to revert or run out of gas. This can block updates to checkpoints (denial of service) for affected representatives or globally, depending on how the host contract wires these helpers.",
      "vulnerability_type": "denial of service",
      "severity": "medium",
      "confidence": 0.6,
      "location": "External calls in moveTokenDelegates() and _moveAllDelegates() to ownerOfFn, ownerToNFTokenCountFn, tokenOfOwnerByIndex",
      "file": "VotingDelegationLib.sol",
      "id": "ad73bf112cbe01be",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Unchecked underflow in isLastEpoch can corrupt time-window logic",
      "description": "The function isLastEpoch performs endTime - WEEK inside an unchecked block. If endTime < WEEK (e.g., endTime is 0 or a small value), this subtraction underflows and wraps to a huge uint256 value. This makes the comparison (endTime - WEEK) <= timestamp incorrect, potentially always false for normal timestamps. Location: isLastEpoch(uint256 timestamp, uint256 endTime). Why it's a security issue: If calling contracts rely on this function to enforce the final-epoch window for actions (e.g., unlocking, voting, or deposits), an underflow can disable or misplace these checks, enabling unauthorized timing of operations or denial of legitimate ones. Potential impact: Bypass or denial of time-based access controls, leading to protocol manipulation or funds flow outside intended windows.",
      "vulnerability_type": "integer underflow / time calculation error",
      "severity": "medium",
      "confidence": 0.75,
      "location": "isLastEpoch() function",
      "file": "BlackTimeLibrary.sol",
      "id": "f23669e4a34f9056",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Unchecked underflow in prevPreEpoch may return gigantic timestamps",
      "description": "prevPreEpoch returns epochStart(timestamp) - NO_GENESIS_DEPOSIT_WINDOW in an unchecked block. If epochStart(timestamp) < NO_GENESIS_DEPOSIT_WINDOW (e.g., when timestamp is 0 or very small), the subtraction underflows to a very large uint256. Location: prevPreEpoch(uint256 timestamp). Why it's a security issue: If external code passes arbitrary or user-controlled timestamps (including 0) and uses this result to gate deposit windows (e.g., 'genesis' periods), underflow can produce nonsensical far-future times, breaking window enforcement and enabling denial of service or bypass of intended timing rules. Potential impact: Disabling or misplacing deposit windows, allowing premature/late deposits or blocking legitimate ones.",
      "vulnerability_type": "integer underflow / time calculation error",
      "severity": "medium",
      "confidence": 0.65,
      "location": "prevPreEpoch() function",
      "file": "BlackTimeLibrary.sol",
      "id": "2a927e7684613b3e",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Misconfigured WEEK constant (set to 1 day) weakens all epoch-based timing",
      "description": "The constant WEEK is defined as 86400 (1 day) while function semantics and comments imply a 7-day week (e.g., isLastHour references '7 days' in a comment). Location: uint256 internal constant WEEK = 86400. Why it's a security issue: All epoch calculations (epochStart, epochNext, vote windows, lock duration multiples) are based on WEEK. Using 1 day instead of 7 days drastically shortens epochs, voting windows, and any time-locked behavior derived from this library. Potential impact: Time locks and voting periods intended to last weeks could be reduced to days, enabling accelerated withdrawals/unlocks, faster voting cycles, or other privilege escalations relative to protocol expectations.",
      "vulnerability_type": "logic/parameter misconfiguration affecting time-based access control",
      "severity": "high",
      "confidence": 0.7,
      "location": "WEEK constant definition",
      "file": "BlackTimeLibrary.sol",
      "id": "9a727607458e8b49",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Reentrancy risk in withdrawStakingFees due to state update after external token transfer",
      "description": "The withdrawStakingFees function performs external calls to token contracts via _safeTransfer before updating the local accounting (toStake0/toStake1 set to 0). Specifically, when toStake0 > 0 or toStake1 > 0, it calls token.transfer(recipient, amount) and only after a successful call sets the corresponding toStake variable to 0. Because _safeTransfer interacts with an external contract (token0/token1), a malicious or ERC777-like token can invoke callbacks into the Pair contract, which (depending on Pair's implementation) could re-enter this PairFees.withdrawStakingFees before the state is cleared, causing the same amounts to be transferred multiple times if the contract holds sufficient token balance. Location: withdrawStakingFees() function, calls to _safeTransfer occur before zeroing state. This is a security issue because it can enable double-withdrawal of staking fees through reentrancy via the authorized caller (pair), leading to loss of funds stored in this contract. Impact: Potential draining of token0/token1 balances beyond intended single payout per withdrawal call.",
      "vulnerability_type": "reentrancy",
      "severity": "high",
      "confidence": 0.6,
      "location": "withdrawStakingFees() function",
      "file": "PairFees.sol",
      "id": "d6b291d75c4e68b7",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Arithmetic underflow/DoS in calculate_rebase enables halting of emissions",
      "description": "The calculate_rebase function computes circulatingBlack = blackSupply - veBlackSupply, where veBlackSupply = balanceOf(ve) + smNFTBalance + superMassiveBonus and blackSupply = totalSupply + superMassiveBonus. Because smNFTBalance is added only to veBlackSupply (not to totalSupply), veBlackSupply can exceed blackSupply whenever smNFTBalance > (totalSupply - balanceOf(ve)). In particular, if most tokens are locked in ve (balanceOf(ve) \u2248 totalSupply) and smNFTBalance > 0, circulatingBlack underflows and reverts under Solidity 0.8's checked arithmetic. This causes calculate_rebase to revert, which makes update_period revert as well, halting weekly emissions. Additionally, if blackSupply is 0 (e.g., initial supply not minted via _initialize), calculate_rebase will divide by zero, also causing a revert. Where: calculate_rebase() and its invocation in update_period(). Why: The smNFTBalance term is asymmetrically included only on the 've' side, making veBlackSupply potentially larger than the augmented total supply, and division by zero is possible at bootstrap. Impact: Any party can DoS emissions by locking sufficient tokens into ve such that (totalSupply - balanceOf(ve)) < smNFTBalance, or by misconfiguring initial supply (division by zero), leading to denial of service of the protocol\u2019s emission schedule.",
      "vulnerability_type": "arithmetic underflow / denial of service",
      "severity": "high",
      "confidence": 0.85,
      "location": "calculate_rebase() function; called from update_period()",
      "file": "MinterUpgradeable.sol",
      "id": "cd74a1fd693c319f",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Uninitialized upgradeable contract allows ownership takeover",
      "description": "The initialize() function is public and sets the owner via __Ownable_init(), guarded only by the initializer modifier. If the proxy/implementation is deployed and not initialized immediately by a trusted party, any external account can call initialize() first and set themselves as the owner. Location: initialize() function. Why it's a security issue: Ownership can be hijacked, enabling the attacker to control any future onlyOwner operations, block legitimate initialization, or interfere with protocol logic relying on ownership. Potential impact: Unauthorized ownership, ability to perform privileged actions in future upgrades or extended versions, denial of proper initialization by the intended deployer.",
      "vulnerability_type": "access control / improper initialization",
      "severity": "high",
      "confidence": 0.85,
      "location": "initialize() function",
      "file": "VeArtProxyUpgradeable.sol",
      "id": "7be6676668b171e4",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Unprotected initializer allows ownership takeover (upgradeable pattern misuse)",
      "description": "The contract inherits OwnableUpgradeable and relies on an initializer instead of a constructor. The initialize(address) function is public and uses the initializer modifier, but the constructor is empty and does not lock the implementation. If this contract is deployed as an implementation (common in proxy setups) and left uninitialized, any attacker can call initialize first and become the owner. As owner, the attacker can set a malicious permissions registry via setRegistry and invoke all onlyAllowed admin functions directly (since onlyAllowed also permits the owner), enabling arbitrary control over gauges (e.g., changing rewarders, distribution, emergency modes). This is a well-known upgradeable pattern risk when the implementation is not initialized or not protected.\n\nWhere: initialize(address _permissionRegistry)\nWhy: Public initializer can be called by anyone on an uninitialized instance; owner role grants full admin capabilities.\nImpact: Full administrative takeover leading to protocol manipulation, fund redirection via malicious rewarders/distribution, and denial of service by toggling emergency modes.",
      "vulnerability_type": "access control / improper initialization",
      "severity": "critical",
      "confidence": 0.9,
      "location": "initialize() function",
      "file": "GaugeFactory.sol",
      "id": "2540d9a34b565eae",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Unrestricted gauge creation can pollute factory registry with untrusted gauges",
      "description": "The createGauge function is externally callable by anyone and appends the newly created GaugeV2 to the factory\u2019s __gauges array and updates last_gauge. If other protocol components implicitly trust gauges created by this factory (e.g., iterate or whitelist based on factory records), a malicious user can create arbitrary gauges with attacker-controlled parameters (_rewardToken, _distribution, bribes, etc.) and have them listed by the factory. This could lead to users or downstream contracts interacting with untrusted/malicious gauges, potentially enabling fund siphoning, reward manipulation, or governance confusion.\n\nWhere: createGauge(address _rewardToken, address _ve, address _token, address _distribution, address _internal_bribe, address _external_bribe, bool _isPair, address _genesisManager)\nWhy: No access control or validation; factory-curated list can be polluted by anyone.\nImpact: Protocol manipulation and possible loss of funds if downstream logic assumes factory-listed gauges are trusted/approved.",
      "vulnerability_type": "access control / unauthorized resource creation",
      "severity": "high",
      "confidence": 0.65,
      "location": "createGauge() function",
      "file": "GaugeFactory.sol",
      "id": "8d375bc3c6807873",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Incorrect array element replaced in removeRole causes data corruption and potential privilege confusion",
      "description": "In removeRole(), when cleaning up each user's role list after a role is removed globally, the code assigns the element at index k of _addressToRoles[rta[i]] to _roles[_roles.length - 1] (the last element of the global roles array) and then pops the user's array. This replaces the user's removed role with an unrelated global role, leaving the user with an unintended role in their per-address role list. Specifically, inside removeRole: _addressToRoles[rta[i]][k] = _roles[_roles.length -1]; _addressToRoles[rta[i]].pop(); This should instead replace with the last element of the user's own roles array: _addressToRoles[rta[i]][k] = _addressToRoles[rta[i]][_addressToRoles[rta[i]].length -1]; This bug leads to: (1) Data corruption in addressToRole() view results, potentially showing users as having powerful roles they were never granted; (2) An admin cannot clean up the incorrect role using removeRoleFrom, because that function requires hasRole[_role][c] == true, which remains false for the spuriously assigned role, causing 'not assigned' revert; hence a denial-of-admin-cleanup; (3) Downstream systems or off-chain automation relying on addressToRole() may erroneously grant access based on the corrupted view.",
      "vulnerability_type": "data corruption / privilege confusion",
      "severity": "high",
      "confidence": 0.9,
      "location": "removeRole(string role) function, inner cleanup loop updating _addressToRoles[...]",
      "file": "PermissionsRegistry.sol",
      "id": "743e98a4835d8271",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Unbounded loops in removeRole can cause gas-based denial of service for role removal",
      "description": "removeRole() iterates over the entire _roles array to find the target role and, more critically, over all addresses assigned to that role (rta = _roleToAddresses[bytes(role)]) and then over each user's roles array to remove the role. If many addresses are assigned or users have large role lists, the transaction can exceed the block gas limit, making it impossible to remove a role on-chain. This locks the registry into retaining obsolete roles or makes emergency cleanup infeasible.",
      "vulnerability_type": "denial of service (gas exhaustion)",
      "severity": "medium",
      "confidence": 0.7,
      "location": "removeRole(string role) function, loops over _roleToAddresses[role] and each user's roles",
      "file": "PermissionsRegistry.sol",
      "id": "e39ac02cbaa543e2",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Stale role-to-address mapping entries after role removal",
      "description": "In removeRole(), while hasRole[role][addr] is set to false for each address, the _roleToAddresses[role] storage array itself is never updated or cleared (the code copies it into memory and does not modify the storage array). As a result, roleToAddresses(role) will continue to return addresses for a removed role, and for active roles it will continue to list users who no longer have hasRole set. This inconsistency can mislead off-chain systems or any consumer relying on roleToAddresses for authorization or operational decisions, potentially leading to unauthorized actions or operational mistakes.",
      "vulnerability_type": "data inconsistency",
      "severity": "low",
      "confidence": 0.75,
      "location": "removeRole(string role) function, handling of _roleToAddresses[role]",
      "file": "PermissionsRegistry.sol",
      "id": "bf26f4ad9556b95f",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Missing zero-address recipient check allows veNFT to be burned and funds permanently locked",
      "description": "The internal transfer function does not prevent transfers to the zero address. In _transferFrom(), there is no require(_to != address(0)) check. As a result, any approved operator or owner can transfer a veNFT to address(0), which effectively \"burns\" the NFT by clearing ownership mappings without invoking the contract's controlled _burn() flow. Where: _transferFrom() function. Why it's a security issue: Transferring to the zero address removes ownership (idToOwner[tokenId] is set to address(0)) and clears approvals, but it does not clear the locked balance or adjust supply via the proper withdrawal path. The underlying ERC20 tokens remain locked in the contract with no way for anyone to call withdraw(), as _isApprovedOrOwner() will fail for a token with no owner. Potential impact: Permanent denial of service and effective loss of funds for the NFT holder. An approved operator (including a mistakenly approved address or compromised operator) can irreversibly brick the NFT and the underlying locked tokens by transferring to the zero address.",
      "vulnerability_type": "access control / improper validation",
      "severity": "critical",
      "confidence": 0.95,
      "location": "_transferFrom(address _from, address _to, uint _tokenId, address _sender)",
      "file": "VotingEscrow.sol",
      "id": "d61e87cc359bb80f",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Incorrect nested loop bounds and missing length checks in addRewardsToBribes cause reverts/DoS",
      "description": "The addRewardsToBribes function iterates over __bribes with index i, but the inner loop uses _token.length (outer array length) as its bound and then indexes _token[i][k]. This has two issues: (1) If _token.length < __bribes.length, accessing _token[i] will index out of bounds and revert. (2) Even when _token.length == __bribes.length, using _token.length for k instead of _token[i].length will revert whenever an inner token list is shorter than the outer array length. These bugs make the function fragile and can cause a complete transaction revert, preventing batch operations and effectively causing a denial of service for this administrative action. Additionally, if inner arrays are longer than the outer array length, some intended tokens will not be added, leading to inconsistent configuration.",
      "vulnerability_type": "denial of service / input validation bug",
      "severity": "medium",
      "confidence": 0.85,
      "location": "addRewardsToBribes(address[][] _token, address[] __bribes)",
      "file": "BribeFactoryV3.sol",
      "id": "b9c83f65a3cebc29",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "recoverERC20AndUpdateData calls the wrong function, risking accounting desynchronization",
      "description": "The recoverERC20AndUpdateData function is intended to recover tokens from bribe contracts and update internal accounting. However, it currently calls IBribe.emergencyRecoverERC20 for each bribe instead of IBribe.recoverERC20AndUpdateData. This likely skips necessary state updates in the bribe contracts, potentially corrupting reward/accounting data. Impact can include mis-accounted balances, over/under distribution of rewards, or future operations failing due to inconsistent state. While the function is onlyOwner-gated, this is still a security-relevant logic flaw that can lead to data corruption and downstream fund distribution errors.",
      "vulnerability_type": "logic error / data corruption",
      "severity": "medium",
      "confidence": 0.7,
      "location": "recoverERC20AndUpdateData(address[] _bribe, address[] _tokens, uint[] _amounts)",
      "file": "BribeFactoryV3.sol",
      "id": "4cdbcc43b0523953",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Accounting mismatch if TOKEN is fee-on-transfer or non-standard ERC20",
      "description": "The contract credits user balances and totalSupply based on the requested deposit/transfer amounts without verifying the actual tokens received. In _deposit, balances and _totalSupply are incremented before calling TOKEN.safeTransferFrom(account, address(this), amount). If TOKEN is fee-on-transfer or otherwise non-standard (returns success but transfers less), the contract will over-credit user shares relative to tokens held. Similarly, depositsForGenesis increases _totalSupply by _totalAmount before pulling tokens from genesisPool, with no check that the contract received the full amount. This can lead to insolvency: withdrawals/emergencyWithdraws may revert (DoS) due to insufficient underlying tokens, or allow value extraction if other logic assumes full backing. Locations: _deposit (around the call to TOKEN.safeTransferFrom), _depositsForGenesis (around the call to TOKEN.safeTransferFrom). Impact: Potential loss of funds or denial of service if the underlying token is non-compliant or malicious.",
      "vulnerability_type": "asset accounting/assumption on ERC20 compliance",
      "severity": "medium",
      "confidence": 0.65,
      "location": "_deposit() internal, lines near TOKEN.safeTransferFrom; _depositsForGenesis() internal, lines near TOKEN.safeTransferFrom",
      "file": "GaugeV2.sol",
      "id": "be9abb38daed2fd4",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Owner can brick fee-claiming by setting internal_bribe to zero or invalid address",
      "description": "The setter setInternalBribe uses require(_int >= address(0), \"ZA\"), which always passes for any address and does not prevent setting the bribe address to address(0) or a non-contract. In _claimFees, the contract approves tokens to internal_bribe and then calls IBribe(internal_bribe).notifyRewardAmount(...). If internal_bribe is zero or not a contract, claimFees will revert, causing a denial of service for fee distribution. While the owner is a trusted role, this misconfiguration enables inadvertent or malicious DoS of fee forwarding. Locations: setInternalBribe, _claimFees.",
      "vulnerability_type": "access control/misconfiguration leading to DoS",
      "severity": "low",
      "confidence": 0.85,
      "location": "setInternalBribe() function; _claimFees() function",
      "file": "GaugeV2.sol",
      "id": "7c1029f3de78058a",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Broken clock() and CLOCK_MODE() freeze governance lifecycle (permanent Pending state)",
      "description": "The overrides for clock() and CLOCK_MODE() are implemented with empty bodies, returning default values (0 and an empty string). In EIP-6372-compatible governors (timestamp-based), clock() defines the current timepoint and is used to compute proposal snapshot and deadline. Returning 0 means the current timepoint never advances. As a result, proposals will remain in the Pending state indefinitely because the current clock never reaches the snapshot time, making voting impossible and effectively bricking governance. This also interacts with cancel(), which requires the proposal to be Pending, allowing cancel to succeed but preventing any normal progression.\n- Where: clock() function and CLOCK_MODE() function\n- Why it's a security issue: It causes a denial of service against the governance process (no proposal can move to Active or Succeeded), preventing protocol changes and potentially freezing critical administrative actions that require governance.\n- Potential impact: Complete governance DoS; protocol cannot pass proposals or execute actions.",
      "vulnerability_type": "denial of service / logical flaw (EIP-6372 timekeeper)",
      "severity": "critical",
      "confidence": 0.9,
      "location": "clock() and CLOCK_MODE() overrides",
      "file": "BlackGovernor.sol",
      "id": "05c4a35bd864b622",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Quorum uses mutable current supply instead of historical snapshot, enabling governance manipulation",
      "description": "The quorum() override ignores the provided timepoint parameter and computes quorum using token.getsmNFTPastTotalSupply() with no time argument. Unless getsmNFTPastTotalSupply() internally returns a historical value for a specific timepoint, this likely reflects the current/mutable supply rather than the snapshot at the proposal's reference time. Quorum must be computed against a past, immutable checkpoint to prevent changing quorum mid-vote. Using a mutable total supply allows an attacker to mint/burn/lock tokens during the voting period to arbitrarily raise or lower quorum, enabling vote manipulation or griefing.\n- Where: quorum(uint256 blockTimestamp) function override\n- Why it's a security issue: Allows post-proposal manipulation of quorum requirements, breaking the safety assumptions of snapshot-based voting.\n- Potential impact: Attackers can prevent proposals from reaching quorum (by inflating supply) or make it easier to pass proposals (by deflating supply), leading to protocol manipulation or governance capture.",
      "vulnerability_type": "protocol manipulation / improper snapshot usage",
      "severity": "high",
      "confidence": 0.7,
      "location": "quorum(uint256) function override",
      "file": "BlackGovernor.sol",
      "id": "a02e446270456d0a",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Execution allowed for Defeated or Expired proposals",
      "description": "The execute function permits execution when a proposal's state is Succeeded, Defeated, or Expired. This means proposals that failed to pass governance (Defeated) or have expired can still execute arbitrary calls. Where: execute() function. Why it's a security issue: Governance is bypassed because failed proposals can still perform their intended actions, enabling unauthorized parameter changes, fund transfers, or arbitrary external calls. Potential impact: Loss of funds, unauthorized upgrades/parameter changes, or protocol takeover via execution of a malicious proposal that did not receive sufficient votes.",
      "vulnerability_type": "access control / logic flaw",
      "severity": "critical",
      "confidence": 0.95,
      "location": "execute() function",
      "file": "L2Governor.sol",
      "id": "7121de06327d2918",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Proposal threshold check uses block number instead of timestamp",
      "description": "The propose function checks the proposer\u2019s voting power using getVotes(_msgSender(), block.number - 1), but this Governor uses timestamp-based vote snapshots elsewhere (e.g., _getVotes(account, blockTimestamp, params) and proposal.voteStart as a timestamp). Passing a block number where a timestamp is expected can produce an extremely old point in time (seconds \u2248 20,000,000), which will likely return 0 voting power with typical time-based checkpoints. Where: propose() function, proposer threshold check. Why it's a security issue: If a non-zero proposalThreshold() is used by an extending module, legitimate proposers may be unable to propose (DoS) because their voting power at the mismatched timestamp resolves to 0. Potential impact: Denial of service for proposal creation when proposalThreshold > 0; governance can be stalled or restricted unintentionally.",
      "vulnerability_type": "denial of service (logic error)",
      "severity": "medium",
      "confidence": 0.7,
      "location": "propose() function (proposer votes threshold check)",
      "file": "L2Governor.sol",
      "id": "0d86d7ef6b35e79e",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Unrestricted pair creation enables unauthorized pairs and misleading PairCreated events",
      "description": "The createPair function is externally callable by anyone and uses msg.sender as the factory parameter when deploying a new Pair via CREATE2. There is no access control or validation that the caller is an authorized factory. As a result, any address can deploy a Pair for arbitrary token0, token1, and stable values with themselves set as the factory and emit a PairCreated event. Location: createPair(address,address,bool) function. Why it's an issue: If downstream systems (indexers, UIs, or even contracts) rely on PairCreated events from this generator as a trust signal for official pairs, attackers can spam or preemptively create deceptive pairs for real tokens, potentially routing users or integrations to unauthorized pairs where the attacker controls the factory-level privileges within the Pair contract (e.g., fee settings). Potential impact: protocol manipulation, user funds routed to attacker-controlled pairs, confusion or phishing via seemingly legitimate events. The issue does not directly drain funds from this contract but can lead to loss of funds for users/integrations that trust these events.",
      "vulnerability_type": "access control / event spoofing",
      "severity": "medium",
      "confidence": 0.6,
      "location": "createPair() function",
      "file": "PairGenerator.sol",
      "id": "fdf58e7ff22945a5",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "pairCodeHash omits constructor arguments, risking incorrect address precomputation by integrations",
      "description": "The pairCodeHash function returns keccak256(type(Pair).creationCode), which excludes constructor arguments (factory, token0, token1, stable). However, CREATE2 derives the deployed address from keccak256 of the full init code, which includes constructor arguments. Where: pairCodeHash() function. Why it's an issue: Integrations that assume this hash can be used in a standard CREATE2 formula to precompute pair addresses will derive incorrect addresses, potentially misrouting interactions or funds if they act on these computed addresses rather than on-chain lookups. Potential impact: denial of service or fund loss for integrations that incorrectly rely on this value for deterministic address computation.",
      "vulnerability_type": "integration risk / incorrect CREATE2 preimage",
      "severity": "low",
      "confidence": 0.55,
      "location": "pairCodeHash() function",
      "file": "PairGenerator.sol",
      "id": "17edc2f6c5fff2cd",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Critical dependencies not validated (zero/EOA addresses) leading to silent no-ops and DoS",
      "description": "The contract does not validate that critical external dependency addresses (minter, gaugeManager, genesisManager, permissionsRegistry) are non-zero contract addresses. In initialize(), _minter, _gaugeManager, and _permissionsRegistry are set without any checks. The setters only check for non-zero but not that the target is a contract. Where it occurs: initialize() sets minter/gaugeManager/permissionsRegistry without checks; setGaugeManager/setMinter/setGenesisManager only require != address(0); performUpkeep() calls genesisManager.checkAtEpochFlip() and IGaugeManager(gaugeManager).distributeAll()/distributeFees() without verifying those are contracts; performPreUpkeep() calls genesisManager.checkBeforeEpochFlip(); checkUpkeep() calls IMinter(minter).check(); checkUpPrekeep() calls genesisManager.check(). Why it's a security issue: If any of these addresses are unset (zero) or set to an EOA/non-contract, external calls with no return values (e.g., checkAtEpochFlip, checkBeforeEpochFlip, distributeAll, distributeFees) will succeed at the EVM level but do nothing, causing silent operational failure where automation runs appear successful but protocol logic never executes. Calls expecting return values (IMinter.check and genesisManager.check) will revert when targeting an address with no code, causing Denial of Service for keepers. Potential impact: - Silent failure to flip epochs and distribute rewards/fees (protocol manipulation/operational failure) - Denial of service of upkeep checks/perform due to revert on decode from empty return - Inconsistent system state, potential loss of rewards distribution over time. Recommended fix: validate in initialize and setters that the addresses are non-zero and are contracts (e.g., using OpenZeppelin AddressUpgradeable.isContract), and initialize genesisManager as part of initialize.",
      "vulnerability_type": "improper initialization / external call to non-contract",
      "severity": "high",
      "confidence": 0.9,
      "location": "initialize(), setMinter(), setGaugeManager(), setGenesisManager(), checkUpkeep(), checkUpPrekeep(), performUpkeep(), performPreUpkeep()",
      "file": "EpochController.sol",
      "id": "3b1a619bab7bcc1c",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Genesis manager not initialized in initialize() can brick pre-upkeep and break epoch flow",
      "description": "The initialize() function does not set the genesisManager, yet multiple functions assume it is set. Where it occurs: initialize() omits genesisManager; checkUpPrekeep() calls genesisManager.check(); performPreUpkeep() calls genesisManager.checkBeforeEpochFlip(); performUpkeep() calls genesisManager.checkAtEpochFlip(). Why it's a security issue: If the owner forgets to call setGenesisManager() after initialization, or calls it with an EOA, the following occurs: - checkUpPrekeep() will revert when decoding a bool from an external call to an address with no code, causing a DoS for pre-upkeep checks; - performUpkeep() and performPreUpkeep() can become silent no-ops for the genesis step (calls to functions with no return values on a non-contract succeed but do nothing), leaving epochs unflipped and distributions possibly skipped. Potential impact: Denial of service for Chainlink Automation pre-checks and malfunction of epoch transitions, leading to stuck state or missed distributions.",
      "vulnerability_type": "improper initialization / denial of service",
      "severity": "medium",
      "confidence": 0.85,
      "location": "initialize(), checkUpPrekeep(), performPreUpkeep(), performUpkeep()",
      "file": "EpochController.sol",
      "id": "566cefe2179f39db",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Unchecked underflow in prevPreEpoch can wrap to very large timestamp",
      "description": "The function prevPreEpoch computes epochStart(timestamp) - NO_GENESIS_DEPOSIT_WINDOW inside an unchecked block. When timestamp < WEEK (1800), epochStart(timestamp) returns 0, and subtracting NO_GENESIS_DEPOSIT_WINDOW (600) underflows, wrapping to a very large uint256 value. This can propagate a bogus 'pre-epoch' time far in the future. If this value is later used for access control windows (e.g., gating deposits/operations before an epoch), it could cause logic to mis-evaluate, potentially denying intended operations or enabling them at unintended times.\n- Where: prevPreEpoch(uint256 timestamp)\n- Why it's a security issue: Arithmetic underflow yields a wrapped high value instead of a safe lower bound, corrupting time-window logic.\n- Potential impact: Denial of service of time-gated actions or enabling actions outside intended windows; downstream protocols relying on this value may malfunction.",
      "vulnerability_type": "integer underflow/overflow",
      "severity": "medium",
      "confidence": 0.8,
      "location": "prevPreEpoch() function",
      "file": "BlackTimeLibrary.sol",
      "id": "c3ac3c8064ca97bd",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Unchecked underflow in isLastEpoch leads to incorrect evaluation for small endTime",
      "description": "The function isLastEpoch returns (endTime - WEEK <= timestamp) && (timestamp < endTime) within an unchecked block. If endTime < WEEK (1800), endTime - WEEK underflows to a very large value, making the first condition almost always false (since a huge number is unlikely <= a normal timestamp). This causes isLastEpoch to return false even when timestamp is within the intended final epoch window.\n- Where: isLastEpoch(uint256 timestamp, uint256 endTime)\n- Why it's a security issue: Time-based logic can be permanently disabled for small endTime values, breaking state transitions that depend on recognizing the final epoch.\n- Potential impact: Denial of service for operations expected to be permitted in the last epoch (e.g., finalizing epochs, unlocking, or executing last-phase logic).",
      "vulnerability_type": "integer underflow/overflow",
      "severity": "medium",
      "confidence": 0.8,
      "location": "isLastEpoch() function",
      "file": "BlackTimeLibrary.sol",
      "id": "3a429e1f86348ee6",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Potential overflow in epochNext/epochVoteEnd/currPreEpoch for extreme timestamps",
      "description": "Several functions add WEEK and then subtract small windows inside unchecked blocks (e.g., timestamp - (timestamp % WEEK) + WEEK, and then - NO_VOTING_WINDOW). If an attacker can supply or influence an abnormally large timestamp value near uint256 max, the addition can overflow, wrapping to a small number and corrupting the computed epoch boundaries.\n- Where: epochNext(uint256 timestamp), epochVoteEnd(uint256 timestamp), currPreEpoch(uint256 timestamp)\n- Why it's a security issue: Wrapped values can cause epoch boundary miscalculations, potentially allowing or denying time-gated operations at unintended times.\n- Potential impact: Protocol manipulation of time windows, enabling unauthorized timing of votes/deposits or causing denial of service for legitimate operations.",
      "vulnerability_type": "integer underflow/overflow",
      "severity": "low",
      "confidence": 0.6,
      "location": "epochNext(), epochVoteEnd(), currPreEpoch() functions",
      "file": "BlackTimeLibrary.sol",
      "id": "0f73883499c9d55b",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Denial of service if quorumDenominator is overridden to 0",
      "description": "The contract allows overriding quorumDenominator(), which defaults to 100. If a child contract overrides quorumDenominator() to return 0, the quorum() function will perform a division by zero: (token.getPastTotalSupply(blockTimestamp) * quorumNumerator()) / quorumDenominator(). This will revert, causing any call that computes quorum (proposal creation/validation flows typically depend on quorum()) to fail, effectively bricking governance. This occurs in quorum() and depends on how quorumDenominator() is implemented in descendants.",
      "vulnerability_type": "denial of service / input validation",
      "severity": "medium",
      "confidence": 0.7,
      "location": "quorum(uint256 blockTimestamp) function; dependency on overrideable quorumDenominator()",
      "file": "L2GovernorVotesQuorumFraction.sol",
      "id": "259078403dbdb23f",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Potential overflow in quorum calculation can brick governance if denominator/numerator are set too large",
      "description": "quorum() computes (totalSupply * quorumNumerator) / quorumDenominator. In Solidity ^0.8.0, multiplication overflow reverts. If a descendant overrides quorumDenominator() to a very large constant and governance sets a very large quorum numerator (still <= denominator), the intermediate multiplication token.getPastTotalSupply(blockTimestamp) * quorumNumerator() can overflow and revert, causing quorum() to fail and potentially bricking governance operations that rely on it. This is a realistic footgun when customizing the denominator. A safer pattern is to use checked math (e.g., OpenZeppelin Math.mulDiv) or rearrange as (totalSupply / denominator) * numerator when appropriate, or enforce upper bounds on the numerator so that totalSupply * numerator never exceeds uint256 max.",
      "vulnerability_type": "integer overflow leading to denial of service",
      "severity": "low",
      "confidence": 0.6,
      "location": "quorum(uint256 blockTimestamp) function; influenced by quorumDenominator() override and updateQuorumNumerator()",
      "file": "L2GovernorVotesQuorumFraction.sol",
      "id": "ab9a96efd5072d41",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Incorrect memory offset when reading input bytes causes corrupted Base64 output",
      "description": "In the encode(bytes) function's assembly block, the code reads input bytes with mload(add(data, i)). For dynamic bytes in Solidity, the first 32 bytes at address 'data' store the length, and the actual payload starts at 'data + 32'. Failing to add this 32-byte offset means the function reads from the length word and misaligned memory for most iterations. As a result, the 3-byte chunks used for Base64 encoding are incorrect, producing corrupted Base64 strings. This occurs in the encode function at the line using 'let input := and(mload(add(data, i)), 0xffffff)'. This is a security issue because any logic relying on correct Base64 encoding (e.g., token metadata, data URIs, off-chain verification workflows) will operate on malformed data, potentially leading to data corruption, broken integrations, and denial of service in downstream systems expecting valid Base64. Impact: All outputs from this library are wrong; consumers may reject the data, cache invalid artifacts, or make decisions based on corrupted content.",
      "vulnerability_type": "data corruption / logic bug (memory addressing)",
      "severity": "medium",
      "confidence": 0.95,
      "location": "encode() assembly block, 'mload(add(data, i))' should be 'mload(add(data, add(32, i)))'",
      "file": "Base64.sol",
      "id": "b65b79070a9a6b80",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Unbounded iteration in getAmountOut can cause on-chain DoS via gas exhaustion",
      "description": "The getAmountOut function iterates over all pools from both the basic AMM factory (pairFactory.allPairsLength()) and the concentrated liquidity factory (algebraFactory.allPairsLength()) to search for 1\u20133 hop routes. There is no upper bound or sanity check on totBasicPairs + totConcentratedPairs in these nested loops. An attacker (or a misconfigured factory) can cause these counts to be very large, making getAmountOut consume excessive gas and revert. If another on-chain contract relies on this function during a transaction, it can be forced to fail (denial of service). This occurs in getAmountOut() and the nested helpers it invokes (_getSwapRoutesFromTwoHop, _getPoolSwapRoutesFromThreeHop). While the function does not modify state or move funds, it is externally callable and intended for routing/pathfinding, and unbounded iteration represents a practical DoS vector on-chain.",
      "vulnerability_type": "denial of service",
      "severity": "medium",
      "confidence": 0.8,
      "location": "getAmountOut() and nested loops over pairFactory.allPairsLength() and algebraFactory.allPairsLength()",
      "file": "BlackholePairAPIV2.sol",
      "id": "d52a9b6c8bc8076e",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Use of ERC20 optional metadata functions without safeguards can DoS view endpoints",
      "description": "Several view pathways call ERC20 optional metadata functions (symbol(), decimals()) directly on arbitrary token addresses without try/catch or fallbacks. Non-standard or malicious ERC20 tokens can revert or be extremely gas-heavy in these calls, causing the entire read to revert and denying service to frontends or integrators that depend on these views. This affects _pairAddressToInfo (via IERC20(token_0).symbol()/decimals() and IERC20(token_1).symbol()/decimals()), _getNextEpochRewards (IERC20(_token).symbol()/decimals()), getPair, and getAllPair which aggregate these results. Although this does not lead to fund loss, it can make the API unusable for pairs involving such tokens.",
      "vulnerability_type": "denial of service",
      "severity": "low",
      "confidence": 0.85,
      "location": "_pairAddressToInfo(), _getNextEpochRewards(), getPair(), getAllPair()",
      "file": "BlackholePairAPIV2.sol",
      "id": "84f9285816cf7695",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Call to zero address for internal bribe rewards can revert",
      "description": "In _pairReward(), the contract reads the internal bribe address from gaugeManager.internal_bribes(_gauge) and passes it unconditionally into _addInternalBribeRewards(). Inside _addInternalBribeRewards(), it calls IBribeAPI(bribe_address).earned(...) twice without checking if bribe_address is address(0). If a gauge has no internal bribe (bribe_address == 0), these external calls will revert, causing getAllPairRewards() to fail for all users. This results in a denial of service of the read API for NFTs whose gauges lack internal bribes.",
      "vulnerability_type": "denial of service",
      "severity": "medium",
      "confidence": 0.85,
      "location": "_pairReward() and _addInternalBribeRewards()",
      "file": "veNFTAPIV1.sol",
      "id": "de530d95ca35fe00",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "getAllNFT uses ownerOf on non-existent token IDs causing revert",
      "description": "getAllNFT() iterates over an arbitrary id range and calls ve.ownerOf(i) for each id, assuming a non-existent token will return address(0). However, ERC721 ownerOf MUST revert when the token does not exist. If the provided range includes non-existent token IDs (common when IDs are non-sequential or burned), the function will revert, preventing retrieval of any data. This enables a denial of service for the read endpoint with certain offsets/amounts.",
      "vulnerability_type": "denial of service",
      "severity": "medium",
      "confidence": 0.8,
      "location": "getAllNFT()",
      "file": "veNFTAPIV1.sol",
      "id": "d769449862f53161",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Uninitialized AVM reference can break read functions",
      "description": "getAVMNFTFromAddress() unconditionally calls avm.getAVMs(). If avm has not been set via setAVM(), it is the zero address and the external call will revert. getAllPairRewards() always calls getAVMNFTFromAddress() first, so any use before initialization (or after being set to a bad address) will cause the entire getAllPairRewards() to revert for all users.",
      "vulnerability_type": "denial of service / misconfiguration",
      "severity": "medium",
      "confidence": 0.75,
      "location": "getAVMNFTFromAddress(), getAllPairRewards()",
      "file": "veNFTAPIV1.sol",
      "id": "e5c15a0198946482",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Fixed-size temporary array in getAVMNFTFromAddress can overflow and revert",
      "description": "getAVMNFTFromAddress() stores matches in a fixed-size memory array of length 1000 (veNFT[] temp = new veNFT[](1000)). If a user owns more than 1000 AVM locks across all AVMs, writing beyond index 999 will trigger a runtime panic and revert. This allows a user with many locks to DoS this read endpoint (and by extension getAllPairRewards()).",
      "vulnerability_type": "denial of service",
      "severity": "low",
      "confidence": 0.7,
      "location": "getAVMNFTFromAddress()",
      "file": "veNFTAPIV1.sol",
      "id": "90f9b5d9cb3f009c",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Unbounded external calls to token metadata can revert and break reads",
      "description": "_createReward() fetches token symbol and decimals via IERC20(token).symbol() and .decimals(). Some tokens may revert, be non-standard, or be malicious, causing the call to revert. Since these are executed for each reward in _pairReward() and ultimately in getAllPairRewards(), a single non-conforming token can cause a complete failure of the read path.",
      "vulnerability_type": "denial of service",
      "severity": "low",
      "confidence": 0.65,
      "location": "_createReward() (called by _pairReward() -> getAllPairRewards())",
      "file": "veNFTAPIV1.sol",
      "id": "ef79f1a3c21b1820",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    }
  ],
  "token_usage": {
    "input_tokens": 156742,
    "output_tokens": 158664,
    "total_tokens": 315406
  }
}