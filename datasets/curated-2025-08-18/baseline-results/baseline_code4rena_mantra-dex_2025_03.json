{
  "project": "code4rena_mantra-dex_2025_03",
  "timestamp": "2025-09-02T04:53:13.917353",
  "files_analyzed": 66,
  "files_skipped": 0,
  "total_findings": 78,
  "findings": [
    {
      "title": "Incompatible/fee-on-transfer tokens can drain pool value",
      "description": "The contract assumes ERC20 tokens are standard and non-deflationary, but it computes pricing/minting before actually receiving tokens and never verifies that the contract received the exact _dx or _amounts. In add_liquidity(), the invariant and mint_amount are computed using the user-supplied _amounts and the current balances, before any transfers occur. If a coin is fee-on-transfer/deflationary, the contract will actually receive less than the assumed amount but still mint LP tokens as if the full amount was received, diluting existing LPs and/or creating a deficit. Similarly, in exchange() and exchange_underlying(), the output dy is computed optimistically using the supplied _dx, prior to transferFrom. If the input token is deflationary, the contract will receive less than _dx but still pay out dy, directly extracting value from the pool. In exchange_underlying(), the contract also deposits the underlying into Aave after computing dy; a deflationary underlying means less aTokens credited than assumed, while dy underlying is still withdrawn and sent to the user. These issues occur in: add_liquidity() (entire function: computes D1/D2 and mint_amount before transfers), exchange() (computes dy via _exchange() before transferFrom), and exchange_underlying() (computes dy before transferFrom and deposit). This is a real security issue if any listed token deviates from standard ERC20 semantics (fee-on-transfer, rebasing on transfer, or malicious balanceOf behavior) and can lead to loss of funds for LPs and protocol imbalance.",
      "vulnerability_type": "token-standards-assumption / accounting mismatch",
      "severity": "high",
      "confidence": 0.85,
      "location": "add_liquidity(), exchange(), exchange_underlying()",
      "file": "SwapTemplateA.vy",
      "id": "b00699a593fe22d2",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Division by zero in get_virtual_price when LP supply is zero",
      "description": "get_virtual_price() returns D * 1e18 / totalSupply(). If the LP token totalSupply is zero (e.g., before the initial deposit), this will revert due to division by zero. While this does not directly lose funds, it can cause denial of service for external integrations relying on this view, and may break UIs or on-chain consumers that expect a value at all times.",
      "vulnerability_type": "denial of service (view function)",
      "severity": "low",
      "confidence": 0.9,
      "location": "get_virtual_price()",
      "file": "SwapTemplateA.vy",
      "id": "5ee026a55510a3b0",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Slippage check bypass when output token is fee-on-transfer (USDT) in exchange_underlying",
      "description": "In exchange_underlying, the function asserts dy >= _min_dy before transferring the output token to the user. However, when the output token is a fee-on-transfer token like USDT (FEE_ASSET), the actual amount the user receives after transfer may be less than dy due to the token\u2019s transfer fee, while the transaction still succeeds. The code only adjusts for fee-on-transfer on the input side (dx_w_fee) but not on the output side. This occurs in exchange_underlying() where dy is computed and checked (assert dy >= _min_dy) and then transferred via raw_call(transfer) without adjusting for or validating post-transfer balance deltas. As a result, users can receive less than the specified _min_dy and cannot protect themselves with the slippage parameter.",
      "vulnerability_type": "slippage protection bypass / fee-on-transfer handling",
      "severity": "high",
      "confidence": 0.85,
      "location": "exchange_underlying() function: slippage check before transfer and final transfer of output_coin (near the end of exchange_underlying)",
      "file": "StableSwapUSDP.vy",
      "id": "dc1afa5e5bbb3ca1",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Unchecked return values from ERC20.transfer in withdrawal paths",
      "description": "Several functions use ERC20(self.coins[i]).transfer(...) without verifying the boolean return value. If a token returns false instead of reverting on failure (a known pattern for some non-compliant ERC20s), the function will continue as if the transfer succeeded. The contract state (balances and LP burns) will update, but the user may not actually receive tokens, leading to loss of funds or accounting inconsistencies. Affected locations: remove_liquidity (transfers coin amounts before burning LP), remove_liquidity_imbalance (transfers requested amounts), remove_liquidity_one_coin (transfers dy), and withdraw_admin_fees (transfers admin fees). In contrast, other paths use raw_call with return checks. Not checking here introduces a real risk if any listed coin is a token that returns false on failure.",
      "vulnerability_type": "token standard noncompliance handling / unchecked external call result",
      "severity": "medium",
      "confidence": 0.7,
      "location": "remove_liquidity(), remove_liquidity_imbalance(), remove_liquidity_one_coin(), withdraw_admin_fees() \u2014 ERC20(...).transfer calls without checking the return value",
      "file": "StableSwapUSDP.vy",
      "id": "081b9e7f7d1051d6",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Division by zero in get_virtual_price before initial deposits",
      "description": "get_virtual_price divides by the LP token total supply without checking for zero supply. Before any liquidity is added, totalSupply() can be zero, causing a division-by-zero revert. While this does not directly risk funds, it can cause denial-of-service for integrators relying on this view function to read the pool\u2019s price prior to the first deposit.",
      "vulnerability_type": "denial of service (view function revert)",
      "severity": "low",
      "confidence": 0.6,
      "location": "get_virtual_price() \u2014 division by token_supply without zero check",
      "file": "StableSwapUSDP.vy",
      "id": "3fc5e2602bce07ec",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Unprotected reentrancy combined with full-balance transfers can drain funds",
      "description": "Both remove_liquidity and remove_liquidity_one_coin transfer the contract's entire token balances to msg.sender after interacting with external contracts, and there is no reentrancy guard. If any involved token (pool LP token or underlying coins) is malicious or has a callback mechanism (e.g., ERC777-like behavior), a reentrant call during token transfer/transferFrom or during pool interactions could invoke these withdrawal functions while the contract is temporarily holding another user's funds (e.g., mid add_liquidity). Because these functions transfer the full balance of each coin (not just the amount attributable to the current call), the reentrant caller could receive funds belonging to another in-flight operation.\n\nWhere it occurs:\n- remove_liquidity(): after withdrawing from pools, it sets amounts[i] = ERC20(coin).balanceOf(self) and then transfers that full balance to msg.sender for each coin.\n- remove_liquidity_one_coin(): computes coin_amount = ERC20(coin).balanceOf(self) and transfers the full balance to msg.sender.\n\nWhy it's a security issue: Without a reentrancy guard, an external token/pool can reenter these functions while the contract holds transient balances from another user, causing unintended transfer of those balances to the reentrant caller.\n\nPotential impact: Theft of users\u2019 deposited tokens waiting to be zapped, or of tokens withdrawn in other concurrent operations, leading to loss of funds.",
      "vulnerability_type": "reentrancy",
      "severity": "high",
      "confidence": 0.7,
      "location": "remove_liquidity() and remove_liquidity_one_coin()",
      "file": "DepositDUSD.vy",
      "id": "31b129770e49e026",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Unlimited approvals to external pool contracts enable token drain if pools are malicious or compromised",
      "description": "In the constructor, the contract grants infinite allowances of all meta coins to the metapool (_pool) and of all base coins to the base pool (_base_pool). There is no ability to revoke or limit these approvals. If the specified pool or base pool is malicious, compromised, or later upgraded to malicious behavior, it can call transferFrom to pull any amount of approved tokens from this contract at any time. Because user funds reside in the contract temporarily during zap operations, a malicious pool could front-run/interrupt a call and siphon those tokens before they are added to the pool.\n\nWhere it occurs: __init__(): approves MAX_UINT256 for each coin to _pool and for each base coin to _base_pool.\n\nWhy it's a security issue: It gives broad spending power over the contract\u2019s token balances to external addresses that are only assumed to be trustworthy. Misconfiguration or compromise of these addresses allows arbitrary withdrawal of tokens held by the contract.\n\nPotential impact: Theft of tokens held by the contract during user operations, leading to loss of funds.",
      "vulnerability_type": "access control / external trust",
      "severity": "high",
      "confidence": 0.8,
      "location": "__init__() approvals to _pool and _base_pool",
      "file": "DepositDUSD.vy",
      "id": "7b1fbe559f9c25f9",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Division-by-zero in get_virtual_price when LP supply is zero",
      "description": "The function get_virtual_price computes D * PRECISION / token_supply without checking that token_supply > 0. When the pool has no liquidity yet (token_supply == 0), D will also be 0 and the division by zero will revert. While this does not lead to loss of funds, it causes the view to revert until the first deposit, which can break integrators or monitoring systems relying on this function.\n- Where: get_virtual_price() function\n- Why: Missing guard for zero totalSupply before division\n- Impact: Denial of service on this read function until first mint; could break frontends/integrations that expect a safe return",
      "vulnerability_type": "denial of service",
      "severity": "low",
      "confidence": 0.9,
      "location": "get_virtual_price() function",
      "file": "StableSwapAETH.vy",
      "id": "416f81d07e221169",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Unvalidated external rate (aETH.ratio) can cause pool-wide reverts",
      "description": "The pool relies on aETH(self.coins[1]).ratio() inside _stored_rates without sanity checks. If ratio() returns 0, _stored_rates will divide by zero and revert. If ratio() returns an extremely small value, rate computations (e.g., PRECISION * LENDING_PRECISION / ratio) can become very large and subsequently cause arithmetic overflow in later multiplications such as rate * balance within _xp/_get_D paths. In Vyper 0.2.8 arithmetic overflow reverts, leading to a denial of service for core functions (add_liquidity, exchange, remove_liquidity_imbalance, remove_liquidity_one_coin, pricing views) that call _stored_rates.\n- Where: _stored_rates(), and all functions that use it: get_virtual_price, calc_token_amount, add_liquidity, get_dy, get_dx, exchange, remove_liquidity_imbalance, _calc_withdraw_one_coin, remove_liquidity_one_coin\n- Why: No validation/sanity bounds on external rate; division by zero and potential overflow conditions are unchecked\n- Impact: Protocol-wide DoS (reverts) if the aETH token returns 0 or pathologically small ratio; could freeze users' ability to trade or add/remove liquidity until the dependency is corrected",
      "vulnerability_type": "external dependency risk / denial of service",
      "severity": "medium",
      "confidence": 0.75,
      "location": "_stored_rates() and all callers",
      "file": "StableSwapAETH.vy",
      "id": "839b3f7130463d7f",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Unchecked return values for LP token mint/burn allow undetected failure and potential fund loss",
      "description": "The contract calls the external LP token's mint and burnFrom functions but does not check their boolean return values. If the LP token implementation returns false on failure instead of reverting, these calls will silently fail while the pool proceeds as if they succeeded. Where it occurs: - add_liquidity(): self.token.mint(msg.sender, mint_amount) (no result check) - remove_liquidity(): self.token.burnFrom(msg.sender, _amount) (no result check) - remove_liquidity_imbalance(): self.token.burnFrom(msg.sender, token_amount) (no result check) - remove_liquidity_one_coin(): self.token.burnFrom(msg.sender, _token_amount) (no result check). Why it's a security issue: If mint returns false, a user\u2019s deposit updates pool balances and transfers in coins but the user may not receive LP tokens, causing loss of funds. If burnFrom returns false, a user can receive withdrawals of underlying without actually burning their LP tokens, enabling repeated withdrawals and draining the pool. Potential impact: Loss of funds for depositors; pool draining if burnFrom silently fails.",
      "vulnerability_type": "unchecked return value / external call handling",
      "severity": "high",
      "confidence": 0.7,
      "location": "add_liquidity(), remove_liquidity(), remove_liquidity_imbalance(), remove_liquidity_one_coin()",
      "file": "StableSwapUSDN.vy",
      "id": "454832179d6364d9",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Division-by-zero in get_virtual_price when totalSupply is zero",
      "description": "The get_virtual_price() view function divides by the LP token total supply without checking for zero. Where it occurs: get_virtual_price(): return D * PRECISION / token_supply. Why it's a security issue: When the pool is uninitialized (token_supply == 0), the function reverts, which can break integrations or monitoring systems relying on this view and cause a denial of service for off-chain or on-chain consumers expecting a price. Potential impact: Denial of service for callers of get_virtual_price() before initial liquidity is added.",
      "vulnerability_type": "denial of service",
      "severity": "low",
      "confidence": 0.9,
      "location": "get_virtual_price()",
      "file": "StableSwapUSDN.vy",
      "id": "4ca079be214e14db",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Privileged minter can arbitrarily transfer tokens from any account (allowance bypass)",
      "description": "In transferFrom(), the code explicitly exempts the minter from allowance checks: `if msg.sender != self.minter: ... self.allowances[_from][msg.sender] -= _value`. This means the address stored in `minter` can move tokens from any holder without prior approval. If the minter key/contract is compromised or becomes malicious, it can seize user funds. This occurs in transferFrom() and set_minter() (which allows the current minter to hand over this power to any address). Impact: loss of user funds via unauthorized transfers by the minter.",
      "vulnerability_type": "access control / privileged functionality",
      "severity": "high",
      "confidence": 0.9,
      "location": "transferFrom() function; set_minter() function",
      "file": "CurveTokenV1.vy",
      "id": "5ec2e897776b1ea5",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Uncapped minting by minter enables arbitrary supply inflation",
      "description": "The mint() function allows the `minter` to increase `total_supply` and any account balance by any `_value` with no cap or constraints beyond `msg.sender == self.minter` and `_to != ZERO_ADDRESS`. If the minter is compromised or malicious, it can mint unlimited tokens, diluting all holders and manipulating protocol accounting. This occurs in mint(). Impact: severe dilution of existing holders, potential protocol manipulation wherever LP token balances are trusted.",
      "vulnerability_type": "access control / centralization risk",
      "severity": "high",
      "confidence": 0.95,
      "location": "mint() function",
      "file": "CurveTokenV1.vy",
      "id": "9348e14c29804920",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Burning power centralized in minter; burnFrom allows destroying others\u2019 balances",
      "description": "Only the `minter` may call burn() and burnFrom(). Through burnFrom(), the minter can reduce any user\u2019s balance and total supply without the user\u2019s consent. If the minter is compromised or turns malicious, this can arbitrarily destroy user funds. This occurs in burn() and burnFrom() enforcing `assert msg.sender == self.minter` and calling _burn(). Impact: loss of funds for targeted users and potential manipulation of supply-dependent mechanisms.",
      "vulnerability_type": "access control / privileged functionality",
      "severity": "high",
      "confidence": 0.85,
      "location": "burn() and burnFrom() functions",
      "file": "CurveTokenV1.vy",
      "id": "f5378fc734cfacd0",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Transfers to the zero address are allowed without reducing total supply",
      "description": "transfer() and transferFrom() do not prevent `_to == ZERO_ADDRESS`. Sending tokens to the zero address irrecoverably locks them, but unlike the internal _burn(), total_supply is not reduced. This can lead to accidental permanent loss of user funds and potential accounting inconsistencies for integrations that assume zero-address transfers are burns reducing total supply. Impact: loss of user funds and possible downstream protocol assumptions being broken.",
      "vulnerability_type": "logic / token accounting edge case",
      "severity": "medium",
      "confidence": 0.6,
      "location": "transfer() and transferFrom() functions",
      "file": "CurveTokenV1.vy",
      "id": "7c4eaa816c03f0ad",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Missing reentrancy guard in withdraw_admin_fees can enable owner-driven reentrancy to drain LP funds with malicious tokens",
      "description": "The function withdraw_admin_fees performs external calls to arbitrary ERC20 tokens via raw_call(transfer) without any nonreentrant guard. If one of the pool tokens is malicious (or non-standard) and its transfer implementation invokes a reentrant call back into this contract while withdraw_admin_fees is executing, the owner (who is authorized to call withdraw_admin_fees) could reenter and manipulate state or re-invoke withdraw_admin_fees to transfer more than the intended admin fees. Because the amount to transfer (value = balanceOf(this) - balances[i]) is computed before the transfer and not recomputed after reentrancy, multiple nested executions can cause multiple transfers based on the same pre-transfer balance, potentially pushing the pool\u2019s on-chain token balance below self.balances[i]. This breaks the accounting invariant (actual token balances < recorded balances), which can lead to failures in subsequent user withdrawals or exchanges (DoS) and potential loss of funds for LPs. While this requires a malicious or compromised owner in combination with a token that can reenter during transfer, the absence of a reentrancy guard on an external-calling admin function exposes unnecessary risk.",
      "vulnerability_type": "reentrancy",
      "severity": "medium",
      "confidence": 0.7,
      "location": "withdraw_admin_fees() function, around raw_call transfers to owner",
      "file": "StableSwapLINK.vy",
      "id": "1776d8f4d71fb313",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Assumes standard ERC20 behavior; fee-on-transfer or reentrant tokens can break accounting and enable value extraction",
      "description": "Several core functions assume that ERC20 tokens are standard (no transfer fees, no deflation/inflation on transfer, no callbacks). In add_liquidity and exchange, the contract updates internal balances based on user-supplied _amounts/_dx before actually receiving the tokens via transferFrom. If a token is fee-on-transfer or otherwise deflationary, the contract will record receiving the full amount while actually receiving less, resulting in over-minting LP tokens on deposit or overpaying users on swaps, effectively extracting value from LPs. Similarly, a malicious token that performs reentrant behavior during transferFrom/transfer could interfere with state between balance updates and token movements in ways not anticipated by the invariant math (nonreentrancy guards do protect user functions, but they do not correct for deflationary transfers). Given this pool targets LINK/sLINK (which are standard ERC20s), this is less likely in this specific deployment, but the code itself is vulnerable if ever used with non-standard tokens.",
      "vulnerability_type": "ERC20 compatibility / accounting mismatch",
      "severity": "medium",
      "confidence": 0.65,
      "location": "add_liquidity() loop transferring tokens; exchange() token transfers",
      "file": "StableSwapLINK.vy",
      "id": "3ffa3687c72f1304",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Unchecked return values from LP token mint/burn enable silent failures and potential fund theft",
      "description": "The contract calls the LP token's mint and burnFrom functions without checking their boolean return values. Specifically: (1) In add_liquidity, CurveToken(lp_token).mint(msg.sender, mint_amount) is invoked without asserting success. If the LP token returns false without reverting, user assets are accepted but LP tokens may not be minted, causing loss for the depositor. (2) In remove_liquidity, remove_liquidity_imbalance, and remove_liquidity_one_coin, CurveToken(lp_token).burnFrom(msg.sender, ...) is called without checking the return value. If burnFrom returns false without reverting, the function proceeds to transfer out pool assets to the caller without burning their LP tokens, enabling withdrawals without reducing LP supply and leading to theft of pool funds. While Curve\u2019s own LP token implementations typically revert on failure and return true on success, this contract does not enforce it, and lp_token is an external address provided at construction, so a misconfigured or malicious token would exploit this.",
      "vulnerability_type": "unchecked return value / token interaction",
      "severity": "high",
      "confidence": 0.78,
      "location": "add_liquidity() near CurveToken(lp_token).mint(...); remove_liquidity(), remove_liquidity_imbalance(), remove_liquidity_one_coin() at CurveToken(lp_token).burnFrom(...)",
      "file": "StableSwapAave.vy",
      "id": "b422346be2376f1e",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Unchecked return values for USDT transfer/transferFrom can lead to silent failures and loss of funds",
      "description": "The contract uses a special USDT interface without return values and does not verify success when calling transfer and transferFrom for the tethered coin (index 2). This occurs in add_liquidity (USDT.transferFrom) and in _send_all (USDT.transfer). If a non-standard token (or upgraded USDT implementation) returns false instead of reverting on failure, these calls will appear successful to this contract. In add_liquidity, a failing transferFrom would later cause deposit to revert, reverting the transaction. More critically, in withdrawals (_send_all), a failing transfer could cause the function to continue without actually sending funds to the user, resulting in users not receiving their assets while the transaction appears successful. This risk is specific to tokens that do not revert on failure. Locations: add_liquidity(): USDT(self.underlying_coins[i]).transferFrom(msg.sender, self, uamount); _send_all(): USDT(_ucoin).transfer(_addr, _uamount). Impact: users may not receive withdrawn funds or operations may proceed under false assumptions, causing loss or inconsistent state.",
      "vulnerability_type": "unchecked return value / non-standard ERC20 handling",
      "severity": "high",
      "confidence": 0.55,
      "location": "add_liquidity() tethered branch; _send_all() tethered branch",
      "file": "DepositBUSD.vy",
      "id": "1b8e7ca2bdf3d476",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Leftover allowances to external contracts could enable unintended token pull if balances later appear",
      "description": "The contract sets allowances to external contracts (yERC20 vaults and the Curve pool) without resetting them to zero and without ensuring they are fully consumed. In add_liquidity, it approves the yERC20 vault to spend underlying (approve(self.coins[i], uamount)) and later approves the Curve pool to spend yTokens (approve(self.curve, amounts[i])). If, for any reason, the external contract does not spend the full approved amount, or this contract later receives additional tokens of the approved type (e.g., via airdrop or mistaken transfer), the existing allowance could be used by the spender to pull tokens from this contract without an explicit new approval. While typical flows consume the allowances immediately, any leftover approvals combined with subsequently received tokens could be drained. Impact: potential loss of tokens unintentionally sent to this contract or residual balances. This does not typically affect user funds in normal operation but can affect donated/mistaken tokens.",
      "vulnerability_type": "improper allowance management",
      "severity": "low",
      "confidence": 0.6,
      "location": "add_liquidity(): approvals to yERC20 and Curve",
      "file": "DepositBUSD.vy",
      "id": "73f19f0b6dd735ed",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Unchecked return values for LP token mint/burn enable fund theft",
      "description": "The contract calls the LP token's mint and burnFrom functions but does not check their boolean return values. If the CurveToken implementation returns false instead of reverting on failure, state changes proceed as if the operations succeeded. In remove_liquidity, remove_liquidity_one_coin, and remove_liquidity_imbalance, the contract transfers out underlying assets to the caller before attempting to burn LP tokens, and then calls burnFrom without asserting the return value. A malicious or non-conforming LP token that returns false would allow the caller to keep their LP tokens while receiving withdrawals, enabling repeated drains of pool liquidity. Similarly, in add_liquidity, the lack of checking the mint return can cause depositor loss (they deposit assets but do not receive LP tokens) if mint returns false.\n\nWhere:\n- add_liquidity(): self.token.mint(msg.sender, mint_amount) \u2014 return value ignored\n- remove_liquidity(): self.token.burnFrom(msg.sender, _amount) \u2014 return value ignored\n- remove_liquidity_one_coin(): self.token.burnFrom(msg.sender, _token_amount) \u2014 return value ignored\n- remove_liquidity_imbalance(): self.token.burnFrom(msg.sender, token_amount) \u2014 return value ignored\n\nWhy it's a security issue: ERC20-like tokens often signal failure by returning false. Ignoring these results assumes success. In the withdrawal paths, assets are sent out before the LP burn is enforced; if burnFrom silently fails, the user receives funds and retains LP tokens, enabling repeated withdrawals and full pool drain.\n\nPotential impact: Critical loss of funds from the pool through repeated, costless withdrawals; depositor fund loss on deposits if mint returns false.\n\nRemediation: Assert the return values of mint and burnFrom (e.g., assert self.token.mint(...), assert self.token.burnFrom(...)) or require that the LP token implementation reverts on failure (and still assert for safety).",
      "vulnerability_type": "unchecked return value / authorization bypass on accounting",
      "severity": "critical",
      "confidence": 0.95,
      "location": "add_liquidity(), remove_liquidity(), remove_liquidity_one_coin(), remove_liquidity_imbalance()",
      "file": "StableSwapOBTC.vy",
      "id": "119e73e94d17d41e",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Unchecked return value for tethered (USDT-like) token transfers can cause silent failure and loss of funds",
      "description": "In exchange_underlying(), the contract uses a special USDT-like ABI that does not return a boolean and does not check transfer success. Specifically, it calls USDT(self.underlying_coins[i]).transferFrom(msg.sender, self, dx) and USDT(self.underlying_coins[j]).transfer(msg.sender, dy) without asserting success. If the tethered token returns false instead of reverting on failure (a known non-standard behavior in some tokens), the function will proceed without reverting. In the output path, this can cause the pool to update internal balances and consider the swap successful while the user does not actually receive the underlying tokens, leaving funds stuck in the contract and the user underpaid. This issue occurs in exchange_underlying() when TETHERED[i] or TETHERED[j] is true (USDT path). Potential impact: user receives no tokens or fewer tokens than expected with no revert; funds get stuck in the contract or accounting diverges from actual transfers.",
      "vulnerability_type": "unchecked return value / token standard non-compliance",
      "severity": "high",
      "confidence": 0.65,
      "location": "exchange_underlying() function: tethered branches for USDT transferFrom and transfer",
      "file": "StableSwapY.vy",
      "id": "bc363023a422fd18",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Approval pattern incompatible with non-compliant ERC20s can DoS underlying exchanges",
      "description": "In exchange_underlying(), the contract approves the yToken to spend underlying via ERC20(self.underlying_coins[i]).approve(self.coins[i], dx) without first resetting allowance to zero. Many non-standard tokens (notably older USDT implementations) require an allowance to be set to zero before being changed to a new non-zero value. Repeated calls that set a new non-zero allowance over an existing non-zero allowance will revert. Because this contract does not reset to zero or use an infinite allowance pattern, exchange_underlying() can revert and become unusable for affected underlying tokens, effectively causing a denial of service for swaps involving those assets. This occurs on every run of exchange_underlying() before calling yERC20(self.coins[i]).deposit(dx). Potential impact: users cannot perform underlying exchanges for affected tokens; protocol functionality degraded/blocked.",
      "vulnerability_type": "denial of service (ERC20 approve incompatibility)",
      "severity": "medium",
      "confidence": 0.8,
      "location": "exchange_underlying() function: approve(self.coins[i], dx) before yERC20 deposit",
      "file": "StableSwapY.vy",
      "id": "267c393e8e8a0e0b",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Fee-on-transfer handling uses total balance instead of delta, allowing capture of pre-existing token balances",
      "description": "In add_liquidity, when handling a fee-on-transfer asset (FEE_ASSET, e.g., USDT), the code sets 'amount' to ERC20(FEE_ASSET).balanceOf(self) after transferFrom, and then uses that value as the deposit amount. This occurs in add_liquidity() within the for-loop over N_ALL_COINS where 'coin == FEE_ASSET'. Because it uses the contract's total balance rather than the delta received in this call, any pre-existing balance of the fee-on-transfer token held by the contract (e.g., dust sent directly to the contract by mistake or leftover balances) will be included in the amount deposited and the resulting LP tokens will be transferred to the current caller. As a result, a caller can capture tokens previously and accidentally sent to the contract by third parties, or any residual balance, by making a minimal transfer for the FEE_ASSET to trigger the branch. While Curve zaps are generally not intended to custody tokens between calls, this behavior constitutes a value leakage across users if any tokens end up stranded in the contract.\n- What: Using total balance as 'amount' for fee-on-transfer tokens instead of the delta received in the current call.\n- Where: add_liquidity(), inside the loop handling transfers; specifically the block:\n  'if coin == FEE_ASSET: amount = ERC20(FEE_ASSET).balanceOf(self); ...'\n- Why: Over-assigns the amount to include pre-existing balances not provided by the current caller.\n- Impact: A user can appropriate any pre-existing FEE_ASSET balance in the contract when depositing, minting LP tokens against funds they did not supply.",
      "vulnerability_type": "asset misaccounting / value leakage",
      "severity": "low",
      "confidence": 0.55,
      "location": "add_liquidity() function, within the transfer loop handling FEE_ASSET",
      "file": "DepositUST.vy",
      "id": "69724752a8182edc",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Division-by-zero in get_virtual_price when pool supply is zero",
      "description": "The get_virtual_price() view computes D * PRECISION / token_supply without guarding against token_supply == 0. At deployment or before any liquidity is added, the invariant D is also 0, resulting in 0 / 0 which raises a division-by-zero exception. Where: get_virtual_price() function. Why it's a security issue: While no funds are at risk, this causes the view to revert, which can break or stall external integrations (price oracles, UIs, monitoring) that expect a callable virtual price at all times. Potential impact: Denial of service for read-only consumers until the first liquidity is added.",
      "vulnerability_type": "denial of service",
      "severity": "low",
      "confidence": 0.9,
      "location": "get_virtual_price() function",
      "file": "StableSwapBUSD.vy",
      "id": "a0008c5780f54e6b",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Approval without zeroing allowance may cause DoS with non-standard ERC20 (e.g., USDT-like tokens)",
      "description": "In exchange_underlying(), the contract calls ERC20(self.underlying_coins[i]).approve(self.coins[i], dx) directly before minting into the lending token. Some ERC20 implementations (notably USDT and certain stablecoins) require setting the allowance to 0 before changing it to a new non-zero value. On such tokens, approve(new_amount) when an existing non-zero allowance is present can revert or return false. Because the code does not first reset the allowance to 0 nor check for that token-specific behavior, exchange_underlying() can revert, resulting in a denial of service for swaps involving that underlying asset. This occurs in the exchange_underlying() function at the approval step prior to cERC20(self.coins[i]).mint(dx). The impact is that users may be unable to perform underlying exchanges for affected tokens, halting a core function of the pool for those assets.",
      "vulnerability_type": "denial of service",
      "severity": "medium",
      "confidence": 0.6,
      "location": "exchange_underlying() function, at the line approving underlying to the cToken: ERC20(self.underlying_coins[i]).approve(self.coins[i], dx)",
      "file": "StableSwapCompound.vy",
      "id": "5e8fde3851428453",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Unchecked return values from LP token mint/burn allow accounting desync and potential fund loss",
      "description": "The contract calls the LP token's mint and burnFrom functions without checking their boolean return values. If the LP token contract returns false (instead of reverting) on failure, state changes and asset transfers within this pool can proceed while the LP token mint/burn does not occur, causing serious accounting inconsistencies. Impact examples:\n- In add_liquidity, balances are updated and user assets are transferred in before calling token.mint(msg.sender, mint_amount). If mint returns false silently, the user\u2019s coins are taken but no LP tokens are minted, effectively trapping funds or enabling misaccounting.\n- In remove_liquidity, remove_liquidity_imbalance, and remove_liquidity_one_coin, the pool reduces balances and transfers out coins to the user before calling token.burnFrom(msg.sender, amount). If burnFrom returns false silently, the user keeps their LP tokens and can withdraw again, draining the pool.\nWhere it occurs:\n- add_liquidity(): self.token.mint(msg.sender, mint_amount)\n- remove_liquidity(): self.token.burnFrom(msg.sender, _amount)\n- remove_liquidity_imbalance(): self.token.burnFrom(msg.sender, token_amount)\n- remove_liquidity_one_coin(): self.token.burnFrom(msg.sender, _token_amount)\nWhy it's a security issue: ERC20-like tokens may signal failure via return false rather than revert. Not asserting the return value assumes correct behavior and opens the door to malicious or non-compliant LP tokens causing loss of funds or pool insolvency.\nPotential impact: Loss of user funds on deposit (no LP minted) and/or total pool drain via repeated withdrawals without burning LP tokens.",
      "vulnerability_type": "unchecked return value / external dependency trust",
      "severity": "high",
      "confidence": 0.8,
      "location": "add_liquidity(), remove_liquidity(), remove_liquidity_imbalance(), remove_liquidity_one_coin()",
      "file": "StableSwapBBTC.vy",
      "id": "b5bf24ce6bb550a1",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Division-by-zero in get_virtual_price when LP supply is zero",
      "description": "The function get_virtual_price computes D * PRECISION / token_supply without checking if token_supply is zero. If called before any liquidity is added (totalSupply == 0), this division reverts. This can cause a denial of service for integrators or off-chain systems relying on this view to function during the pool's initial state.\n- Where: get_virtual_price() function\n- Why: Missing guard for token_supply == 0 prior to division\n- Impact: Read-only DoS for frontends/integrations (e.g., price oracles, dashboards) until first deposit; no direct fund loss but operational disruption.",
      "vulnerability_type": "denial of service",
      "severity": "low",
      "confidence": 0.85,
      "location": "get_virtual_price()",
      "file": "StableSwapTBTC.vy",
      "id": "5157057d28179bf2",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Min-received guarantees can be bypassed for fee-on-transfer output tokens",
      "description": "Several functions check slippage/min-received conditions before transferring tokens out, but do not verify the actually received amount by the user afterwards. If an output token takes a transfer fee (fee-on-transfer), the user can receive less than the asserted amount, violating slippage protections.\n- Where: exchange_underlying(), remove_liquidity(), remove_liquidity_one_coin(), remove_liquidity_imbalance()\n  - exchange_underlying: dy is checked against min_dy before transferring output_coin via raw_call(transfer). If output_coin charges a fee on transfer to the user, the actual received amount < dy, but no post-transfer check exists.\n  - remove_liquidity / remove_liquidity_one_coin: amounts are computed and asserted (min_amounts / _min_amount) before transfer; fee-on-transfer on the outgoing token reduces what the user actually receives.\n  - remove_liquidity_imbalance: user requests exact amounts; a fee-on-transfer token will send less than requested, with no compensation or detection.\n- Why: The contract only accounts for transfer-fee behavior on the input side for a single hardcoded asset (FEE_ASSET) in exchange_underlying. It assumes zero fees when sending tokens out.\n- Impact: Users can receive less than their specified minimum amounts, breaking slippage guarantees and causing unexpected loss relative to expectations. An output token with malicious or dynamic transfer fees can systematically skim value from users.",
      "vulnerability_type": "slippage check bypass / fee-on-transfer token handling",
      "severity": "medium",
      "confidence": 0.7,
      "location": "exchange_underlying(), remove_liquidity(), remove_liquidity_one_coin(), remove_liquidity_imbalance()",
      "file": "StableSwapTBTC.vy",
      "id": "df8829cb99c31269",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Constructor does not validate fee and admin_fee bounds",
      "description": "In __init__, the contract sets self.fee and self.admin_fee directly from _fee and _admin_fee without any validation against MAX_FEE, MAX_ADMIN_FEE, or FEE_DENOMINATOR. Later logic assumes fee < FEE_DENOMINATOR (e.g., get_dx/get_dx_underlying divide by FEE_DENOMINATOR - self.fee) and that dy_fee <= dy (e.g., _exchange subtracts fees). If an out-of-bounds fee is configured at deployment, exchanges can revert due to division by zero (when fee == FEE_DENOMINATOR) or underflow when dy_fee > dy, effectively causing a denial of service for swaps and potentially other fee-dependent paths. This is inconsistent with commit_new_fee, which enforces bounds.",
      "vulnerability_type": "input validation / configuration error leading to DoS",
      "severity": "high",
      "confidence": 0.9,
      "location": "__init__ constructor: assignments to self.fee and self.admin_fee; impact observed in get_dx(), get_dx_underlying(), and _exchange()",
      "file": "SwapTemplateY.vy",
      "id": "9b501e86d71a7d56",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Accounting assumes non-deflationary tokens; fee-on-transfer tokens can break invariants and be exploited",
      "description": "Multiple functions credit/debit internal balances and compute pricing using the user-supplied _amounts/_dx without verifying the actual tokens received by the pool. For example:\n- exchange(): updates balances via _exchange using _dx, then performs transferFrom of _dx of coin[i]. If coin[i] is fee-on-transfer or otherwise delivers less than _dx, the pool's internal balances will be overstated and the user still receives dy based on the higher credited amount, causing loss to liquidity providers.\n- exchange_underlying(): computes dx from _dx and updates balances via _exchange, then transferFrom underlying _dx and deposits _dx into yToken. If the underlying token is deflationary, the actual amount deposited (and thus backing assets) is less than assumed, again leading to accounting divergence and potential draining of the pool over repeated trades.\n- add_liquidity(): mints LP based on _amounts and updates self.balances before pulling tokens; deflationary behavior would mint excess LP relative to value actually received.\nCurve pools typically assume standard ERC20s (no transfer fees), but if deployed with tokens that take transfer fees or otherwise transfer less than requested, this creates a concrete path to loss of funds.",
      "vulnerability_type": "asset accounting mismatch / incompatible token assumption",
      "severity": "medium",
      "confidence": 0.85,
      "location": "exchange(), exchange_underlying(), add_liquidity()",
      "file": "SwapTemplateY.vy",
      "id": "d3ea26a360f7fb1f",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Division by zero in get_virtual_price when LP token supply is zero",
      "description": "get_virtual_price returns D * PRECISION / token_supply without guarding against token_supply == 0. Before the initial deposit (or if totalSupply becomes zero due to token behavior), this function reverts due to division by zero. While this is a view function and does not directly risk funds, it can break or DoS integrations that rely on a callable virtual price at all times.",
      "vulnerability_type": "denial of service (view) / missing zero-check",
      "severity": "low",
      "confidence": 0.9,
      "location": "get_virtual_price()",
      "file": "SwapTemplateY.vy",
      "id": "d287890f50e66ffb",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Unsafe approve pattern with USDT-like tokens can cause Denial of Service",
      "description": "The contract sets ERC20 allowances to non-zero values without first resetting them to zero. Some widely used nonstandard tokens (notably USDT) require the allowance to be set to 0 before changing it to a new non-zero value. In add_liquidity, when handling the tethered coin (index 2, USDT), the code calls ERC20(self.underlying_coins[i]).approve(self.curve, uamount) directly. If a prior non-zero allowance exists, USDT may revert or return false, causing the entire call to fail and preventing deposits for all users until the allowance state aligns. This manifests as a persistent DoS for the affected path.\n\nWhere:\n- add_liquidity() function: the approve to Curve for underlying tokens (specifically for tethered[i] == True, i.e., USDT path)\n- Code: within add_liquidity, in the non-lending branch: `ERC20(self.underlying_coins[i]).approve(self.curve, uamount)`\n\nWhy it's a security issue:\n- If the token enforces the \"set to 0 before changing\" rule, subsequent calls that attempt to change an existing non-zero allowance will fail. This can permanently block deposits via this zap for that coin until someone manually resets the allowance to 0 or circumstances change.\n\nPotential impact:\n- Denial of service for deposits involving the tethered coin (USDT), preventing users from adding liquidity via this zap.\n\nRecommended mitigation:\n- Use the safe approve pattern: set allowance to 0 before setting a new non-zero allowance, or use increaseAllowance/decreaseAllowance where supported.\n- Example: if current allowance != 0, first approve 0, then approve desired amount.",
      "vulnerability_type": "denial of service (unsafe ERC20 approve pattern)",
      "severity": "medium",
      "confidence": 0.7,
      "location": "add_liquidity() function, approval to Curve for underlying tokens (USDT path)",
      "file": "DepositSUSD.vy",
      "id": "c364fce69fc23fb8",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Min slippage check bypass when output token charges a transfer fee in exchange_underlying",
      "description": "In exchange_underlying, the contract computes dy (the amount to send) and checks dy >= min_dy before performing the final ERC20 transfer to the user. However, if the output token (output_coin) charges a transfer fee (fee-on-transfer), the actual amount received by the user will be less than dy, but the function does not re-check the received amount after the transfer. This allows min_dy to be effectively bypassed for fee-on-transfer output tokens. Where: exchange_underlying() function, in the branch where tokens are transferred to the user (final safeTransfer block). Why it's a security issue: Users may receive less than their specified minimum output, enabling value loss relative to their slippage protection. Potential impact: Users can be underpaid compared to min_dy when swapping to a token with a transfer fee (e.g., if an underlying coin levies a fee on transfer, such as a non-standard asset).",
      "vulnerability_type": "slippage bypass / fee-on-transfer handling",
      "severity": "medium",
      "confidence": 0.7,
      "location": "exchange_underlying()",
      "file": "StableSwapPBTC.vy",
      "id": "a42b0c39c89251a8",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Division by zero in get_virtual_price when totalSupply is zero",
      "description": "get_virtual_price computes D * PRECISION / token_supply without guarding for the case where token_supply == 0. If called before any liquidity is minted (or after complete burn), this will revert due to division by zero. Where: get_virtual_price() function. Why it's a security issue: While it does not directly lead to loss of funds, it can cause denial of service for integrators or monitoring tools relying on this view function, and could break upstream logic expecting a graceful response. Potential impact: DoS for consumers of the view, potential off-chain system instability.",
      "vulnerability_type": "denial of service",
      "severity": "low",
      "confidence": 0.9,
      "location": "get_virtual_price()",
      "file": "StableSwapPBTC.vy",
      "id": "fac733413076ce32",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Minter has unrestricted privileges to mint, burn from arbitrary accounts, and transfer without allowance",
      "description": "The contract grants the address stored in `minter` sweeping control over token supply and user balances. Specifically: (1) `mint()` allows the minter to create unlimited tokens to any address; (2) `burnFrom()` allows the minter to burn tokens from any address without allowance; (3) `transferFrom()` includes a bypass that permits the minter to transfer tokens from any address to any address without checking or consuming allowance. These occur in `mint()` (assert msg.sender == self.minter), `burnFrom()` (assert msg.sender == self.minter), and `transferFrom()` (if msg.sender != self.minter: ... else bypass). This design means that if the minter is malicious or compromised, it can arbitrarily seize user funds, dilute holders by minting, or destroy user balances. Even if intentional for protocol mechanics, it represents a centralized trust assumption and a single point of failure that can lead to total loss of funds.",
      "vulnerability_type": "access control / centralization risk",
      "severity": "high",
      "confidence": 0.95,
      "location": "mint(), burnFrom(), transferFrom() functions",
      "file": "CurveTokenV2.vy",
      "id": "2085f7129f211987",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Potential denial of service in set_name due to external call to minter.owner()",
      "description": "The `set_name` function authorizes updates by calling `Curve(self.minter).owner()` and requiring it equals `msg.sender`. If `self.minter` is set to an EOA or any contract that does not implement `owner()` (or intentionally reverts), this external call will revert and permanently block metadata updates via `set_name`. Additionally, changing `minter` to an incompatible address via `set_minter()` can introduce this DoS condition. While it does not impact balances, it can disrupt governance/UX operations that rely on updating token name/symbol.",
      "vulnerability_type": "denial of service",
      "severity": "low",
      "confidence": 0.7,
      "location": "set_name() function; dependency on set_minter()",
      "file": "CurveTokenV2.vy",
      "id": "6f451dc633b29138",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Division-by-zero in get_virtual_price can cause read-function DoS",
      "description": "The function get_virtual_price computes D * 1e18 / totalSupply without checking that the LP token total supply is non-zero. If called before any liquidity is added, or after all LP tokens have been burned, ERC20(self.lp_token).totalSupply() may be 0, causing a division-by-zero revert. This can break integrators relying on this view for pricing or accounting and create a denial of service on read paths.\n- Where: get_virtual_price() function\n- Why it's a security issue: A revert in a commonly used view function can break dependent protocols (e.g., oracles, strategy accounting) and monitoring systems.\n- Potential impact: Denial of service for external systems calling get_virtual_price; inability to obtain virtual price when supply is zero.",
      "vulnerability_type": "denial of service",
      "severity": "low",
      "confidence": 0.7,
      "location": "get_virtual_price()",
      "file": "StableSwapEURS.vy",
      "id": "a5f8bd24d9b42e0e",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "No verification of actual token amounts received allows exploitation with non-standard/deflationary tokens",
      "description": "Functions that accept tokens via transferFrom assume the full dx amount is received and update internal balances accordingly (e.g., self.balances[i] += dx). There is no verification via balance differentials to confirm the actual amount received. With fee-on-transfer or otherwise non-standard ERC20 tokens, an attacker could pay less than dx while receiving full dy of the other token, leading to loss of funds for the pool. Curve pools are intended for standard tokens, but the contract does not enforce this assumption.\n- Where: exchange() (updates balances and computes dy based on dx without actual received check), add_liquidity() (assumes amounts[i] received), remove_liquidity_imbalance()/remove_liquidity_one_coin() rely on expected accounting vs actual balances.\n- Why it's a security issue: If a pool lists a token that charges transfer fees, rebases on transfer, or otherwise manipulates transfer amounts, the pool's accounting becomes inconsistent and can be drained.\n- Potential impact: Loss of funds from the pool due to attackers exploiting the mismatch between expected and actual token transfers.",
      "vulnerability_type": "protocol manipulation / ERC20 compatibility",
      "severity": "medium",
      "confidence": 0.85,
      "location": "exchange(), add_liquidity(), and other paths using raw_call transferFrom without post-transfer balance checks",
      "file": "StableSwapEURS.vy",
      "id": "59e3c75b0abfc980",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Unchecked return values for LP token mint/burn allow accounting desync and fund loss with non-standard tokens",
      "description": "The contract calls CurveToken.mint and CurveToken.burnFrom but does not check their boolean return values. If the LP token contract returns false instead of reverting on failure, these functions will continue execution as if the mint/burn succeeded, causing the pool's internal accounting (balances and token_supply assumptions) to diverge from reality. This could lead to loss of user funds or allow withdrawals without burning LP tokens.\n\nWhere it occurs:\n- add_liquidity(): calls self.token.mint(msg.sender, mint_amount) without asserting the return value.\n- remove_liquidity(): calls self.token.burnFrom(msg.sender, _amount) without asserting the return value.\n- remove_liquidity_imbalance(): calls self.token.burnFrom(msg.sender, token_amount) without asserting the return value.\n- remove_liquidity_one_coin(): calls self.token.burnFrom(msg.sender, _token_amount) without asserting the return value.\n\nWhy it's a security issue:\n- If mint returns false, users' deposits are accepted (balances updated and underlying transferred in) but no LP tokens are issued, effectively locking or stealing deposits.\n- If burnFrom returns false, underlying assets are transferred out to the user but their LP tokens are not burned. The user could repeatedly withdraw using the same LP tokens, draining the pool.\n\nPotential impact:\n- Catastrophic loss of funds if a non-standard/malicious LP token is used or misconfigured.\n- Stuck funds or permanent imbalance due to accounting mismatch.\n\nWhile the official Curve LP token implementation reverts on failure, the contract accepts any _pool_token address in the constructor and does not enforce behavior. Forks or misconfigurations can therefore introduce this risk.",
      "vulnerability_type": "improper error handling / unchecked return value",
      "severity": "high",
      "confidence": 0.65,
      "location": "add_liquidity(), remove_liquidity(), remove_liquidity_imbalance(), remove_liquidity_one_coin()",
      "file": "StableSwapRSV.vy",
      "id": "29c7da0a66fd6b87",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Incompatible (fee-on-transfer/deflationary) tokens can drain pool due to unchecked received amounts",
      "description": "The contract assumes ERC20 tokens are standard and do not take fees on transfer. In exchange() and add_liquidity(), the pool computes pricing and mint/burn amounts based on the provided dx/_amounts before actually receiving the tokens, and it never verifies how many tokens were actually received. If any coin is fee-on-transfer/deflationary, transferFrom(msg.sender, self, dx) will deliver less than dx to the pool, but dy/mint_amount are still calculated using dx, causing the pool to overpay the user or mint excess LP tokens. This leads to loss of funds from the pool. This occurs in: - exchange(): after computing dy with _exchange, it transfers dx in and dy out without checking the actual received amount of coin i. - add_liquidity(): invariant and fees are computed using the user-supplied _amounts, and after that the tokens are transferred, again with no check of actual amounts received. Why it's a security issue: An attacker can repeatedly exploit fee-on-transfer behavior (or any token that doesn't strictly transfer the requested amount) to extract value. Potential impact: Loss of pool funds and dilution of existing LPs. Note: Curve deployments typically restrict listed assets to well-behaved ERC20s, but this code does not enforce it at the contract level.",
      "vulnerability_type": "incompatible token assumptions / value-inconsistency",
      "severity": "high",
      "confidence": 0.6,
      "location": "exchange() and add_liquidity() functions",
      "file": "StableSwapSAAVE.vy",
      "id": "8272fea60431e392",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Aave deposit raw_call lacks explicit success verification, enabling misconfiguration/malicious pool to mis-account deposits",
      "description": "In add_liquidity(_use_underlying=True) and exchange_underlying(), the contract performs Aave deposits using raw_call to aave_lending_pool with manually-encoded calldata, and does not inspect the return data. While raw_call will revert on failure by default, if a malicious or non-standard aave_lending_pool address (set at deployment) accepts the call via a permissive fallback and does nothing, the call will appear successful. In add_liquidity(_use_underlying=True), underlying tokens are first transferred from the user to this contract and then 'deposited'. If the deposit is a no-op that does not mint aTokens, the pool will still mint LP tokens based on the precomputed invariant (using _amounts), causing LP tokens to be minted without the pool actually receiving the aTokens backing, leading to accounting inconsistencies and potential loss to future LPs. Impact relies on a malicious/misconfigured aave_lending_pool address; with a correct Aave LendingPool this does not occur, but the code does not defend against misconfiguration.",
      "vulnerability_type": "external call misuse / protocol integration assumption",
      "severity": "medium",
      "confidence": 0.5,
      "location": "add_liquidity() with _use_underlying=True; exchange_underlying()",
      "file": "StableSwapSAAVE.vy",
      "id": "d0eca2f11fe4dfb1",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Accounting mismatch with fee-on-transfer/rebasing tokens allows value extraction",
      "description": "The pool assumes ERC20 tokens are standard (no transfer fees, no rebasing) and updates its internal balances and mints/burns LP tokens based on the nominal amounts provided by the caller, without verifying the actual tokens received/sent. This occurs in multiple functions:\n- add_liquidity(): internal balances are updated (and LP tokens minted) using the provided 'amounts' and computed invariants before performing transferFrom calls to pull tokens from the user. If a token is deflationary (fee-on-transfer) or otherwise transfers less than requested, the pool's internal balances become overstated while fewer tokens are actually received, allowing the depositor to mint more LP tokens than backed by assets. (Function add_liquidity)\n- exchange(): pool state (balances) is updated and output dy is computed using the input dx, then it pulls dx via transferFrom and sends dy to the trader. If the input token charges a transfer fee or underdelivers, the user sends less than dx but still receives dy based on the larger assumed dx, extracting value from the pool. (Functions _exchange and exchange)\n- remove_liquidity and remove_liquidity_imbalance: the pool transfers out exact amounts to users based on internal accounting; if the output token charges a transfer fee on send, the user receives less than expected despite internal balances decreasing by the full amount, leading to user loss and potential disputes/DoS, and further desynchronizing internal vs actual balances. (Functions remove_liquidity, remove_liquidity_imbalance)\nThis is a security issue because malicious or non-standard tokens (or tokens that later change behavior) can cause loss of funds via under-collateralized LP minting or profitable trades where the pool gives out more value than it receives. Potential impact includes draining pool reserves and corrupting accounting, harming LPs.\nLocations:\n- add_liquidity(): state/invariant and self.balances updated before transfers; no verification of received amounts.\n- _exchange()/exchange(): self.balances[i] increased by dx before pulling tokens; dy sent regardless of actual received.\n- remove_liquidity()/remove_liquidity_imbalance(): transfers performed without adjusting for or checking transfer-side fees.",
      "vulnerability_type": "asset accounting/assumption violation (non-standard ERC20 handling)",
      "severity": "high",
      "confidence": 0.78,
      "location": "add_liquidity(), _exchange(), exchange(), remove_liquidity(), remove_liquidity_imbalance()",
      "file": "StableSwapSBTC.vy",
      "id": "154f3a43faf05119",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Full-balance LP token transfers let callers steal any pre-existing LP tokens",
      "description": "The contract transfers the entire LP token balance of the contract to the caller instead of only the amount just minted or the unused portion from the current operation. If any LP tokens are accidentally sent to this contract (or left over for any reason), the next caller of these functions will receive those tokens.\n\nWhere:\n- add_liquidity(): after minting, the contract computes `lp_amount = ERC20(lp_token).balanceOf(self)` and transfers the full balance to `msg.sender`.\n- remove_liquidity_imbalance(): after the pool operation, it computes `_lp_amount = ERC20(lp_token).balanceOf(self)` and transfers the entire balance to `msg.sender` as \"unused\" tokens.\n\nWhy it\u2019s a security issue: Anyone can trigger these functions and receive any stray LP tokens held by the contract, effectively stealing tokens mistakenly sent to the contract.\n\nPotential impact: Loss of funds for users who accidentally transfer LP tokens directly to the contract or for any scenario where LP tokens remain in the contract balance.",
      "vulnerability_type": "improper accounting / unintended token sweep",
      "severity": "medium",
      "confidence": 0.9,
      "location": "add_liquidity() and remove_liquidity_imbalance() functions",
      "file": "DepositTemplateY.vy",
      "id": "1345eca610604139",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Full-balance underlying token transfers let callers steal pre-existing underlying balances",
      "description": "The internal helper `_unwrap_and_transfer` transfers the entire underlying token balance of the contract for each coin to the caller, not just the amount obtained from the current withdrawal. If underlying tokens of the same type are accidentally sent to the contract or otherwise present, a caller can withdraw them.\n\nWhere:\n- _unwrap_and_transfer(): for each coin, it reads `_uamount = ERC20(_ucoin).balanceOf(self)` and transfers the full balance to the provided address.\n- This helper is used by remove_liquidity() and remove_liquidity_imbalance(), enabling callers to sweep any pre-existing underlying balances during a withdrawal.\n\nWhy it\u2019s a security issue: Any underlying tokens residing in the contract (e.g., accidental transfers) can be claimed by the next user calling a withdrawal path.\n\nPotential impact: Loss of funds for anyone who mistakenly sent underlying tokens to the contract address.",
      "vulnerability_type": "improper accounting / unintended token sweep",
      "severity": "medium",
      "confidence": 0.85,
      "location": "_unwrap_and_transfer() used by remove_liquidity() and remove_liquidity_imbalance()",
      "file": "DepositTemplateY.vy",
      "id": "3118339c1288e1e7",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Incorrect fee-on-transfer handling uses total balance instead of delta, allowing theft of stray USDT held by the contract",
      "description": "In add_liquidity, when handling the special-case FEE_ASSET (USDT), the code sets the per-coin amount to the contract's entire current USDT balance after transfer instead of the delta received in this call. Specifically, after a transferFrom, it executes:\n\n- amount = ERC20(FEE_ASSET).balanceOf(self)\n- Then assigns this 'amount' into meta_amounts[i] or base_amounts[i - MAX_COIN]\n\nThis occurs in add_liquidity(...) within the loop over N_ALL_COINS when coin == FEE_ASSET. Because it uses the total balance, any pre-existing USDT balance (leftover dust, accidental transfers, or prior residues) is merged into the current user's deposit, and the LP tokens minted from depositing that extra USDT are transferred entirely to msg.sender at the end of the function. As a result, any third party can intentionally or unintentionally sweep arbitrary USDT that resides on the contract by making a deposit that touches the USDT path, effectively expropriating funds from the contract.\n\nWhy it's a security issue: Funds unexpectedly held by the contract (e.g., accidental transfers, airdrops, or operational dust) can be taken by any caller. While this is a stateless zap and not expected to custody funds, the behavior still constitutes an unintended fund loss vector for tokens at this address.\n\nPotential impact: Loss of any USDT balance inadvertently or temporarily held by the contract to an arbitrary caller who triggers add_liquidity with the USDT branch.\n\nRecommended fix: Compute the received amount as a delta:\n- Pre: prev = ERC20(FEE_ASSET).balanceOf(self)\n- Do transferFrom\n- Post: received = ERC20(FEE_ASSET).balanceOf(self) - prev\n- Use 'received' in meta_amounts/base_amounts for the current index only.\n\nAlternatively, snapshot balances for all coins before the loop and use per-coin deltas after transfers.",
      "vulnerability_type": "funds theft via incorrect balance accounting",
      "severity": "medium",
      "confidence": 0.8,
      "location": "add_liquidity() function, within the per-coin transfer loop when coin == FEE_ASSET (USDT)",
      "file": "DepositUSDP.vy",
      "id": "9f791cd67348c5fd",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Non-zero-to-non-zero approve causes DoS with non-standard tokens (e.g., USDT) in exchange_underlying",
      "description": "The function exchange_underlying approves the underlying token to the yToken contract using ERC20.approve(self.coins[i], dx) without first resetting the allowance to 0. Many non-standard ERC20 tokens (notably USDT) require setting allowance to 0 before updating it to a new non-zero value. After the first successful call (when allowance becomes non-zero), subsequent calls attempting to change the allowance from non-zero to non-zero will revert, causing a persistent denial of service for paths where USE_LENDING[i] is true. This occurs in exchange_underlying(), where for use_lending[i] the code does: ERC20(self.underlying_coins[i]).approve(self.coins[i], dx) followed by yERC20(self.coins[i]).deposit(dx). If the underlying token enforces the zero-first approval rule, future exchanges using that coin as input will revert, breaking swaps for that asset.",
      "vulnerability_type": "denial of service",
      "severity": "high",
      "confidence": 0.85,
      "location": "exchange_underlying() function: approving underlying to yToken without zeroing allowance",
      "file": "StableSwapPax.vy",
      "id": "49bee5199966d6d7",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Division by zero in get_virtual_price before any liquidity is minted",
      "description": "get_virtual_price computes D * 1e18 / token_supply without checking that token_supply > 0. If called before any LP tokens are minted (token_supply == 0), this division reverts. While this is a view function and does not cause fund loss, it can break integrations that assume the function never reverts, leading to operational issues or halted UI/automation flows.",
      "vulnerability_type": "denial of service",
      "severity": "low",
      "confidence": 0.9,
      "location": "get_virtual_price() function: division by token.totalSupply() without zero check",
      "file": "StableSwapPax.vy",
      "id": "017147e4b8d8d708",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Division-by-zero in get_virtual_price when totalSupply is zero",
      "description": "The view function get_virtual_price computes D * 1e18 / token_supply without checking that token_supply > 0. If called before any liquidity is minted (i.e., LP totalSupply == 0), this division will revert. While this does not lead to loss of funds, it can cause denial of service for integrators or UIs that query this function pre-initialization.\n- What: Division by zero on token_supply\n- Where: get_virtual_price() function\n- Why: No guard for zero total supply before division\n- Impact: View call reverts, potentially breaking off-chain integrations or on-chain contracts that rely on this value before pool initialization",
      "vulnerability_type": "denial of service",
      "severity": "low",
      "confidence": 0.85,
      "location": "get_virtual_price()",
      "file": "StableSwap3Pool.vy",
      "id": "17926ea0fc8b8d82",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Potential underflow and revert in admin fee accounting if actual token balance < recorded balance",
      "description": "admin_balances and withdraw_admin_fees compute value = ERC20(c).balanceOf(self) - self.balances[i]. If for any reason the actual token balance becomes less than the internal accounting (e.g., due to unexpected token behavior like external confiscation/blacklisting, or non-standard fee mechanics not fully captured), this subtraction underflows and reverts. As a result, admin_balances view calls would revert, and withdraw_admin_fees would become unusable, preventing the owner from withdrawing any admin fees for all coins in that call.\n- What: Unsafeguarded subtraction between external balance and internal accounting\n- Where: admin_balances(i) and withdraw_admin_fees()\n- Why: Vyper reverts on uint underflow; no min check before subtraction\n- Impact: Denial of service for admin fee queries and withdrawals; no direct loss of user funds, but blocks protocol revenue collection and may affect operational tooling",
      "vulnerability_type": "denial of service",
      "severity": "low",
      "confidence": 0.6,
      "location": "admin_balances(i), withdraw_admin_fees()",
      "file": "StableSwap3Pool.vy",
      "id": "a95643bf1854b0a6",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Transfer to zero address allows irreversible token lock without reducing totalSupply",
      "description": "The transfer and transferFrom functions do not prevent sending tokens to the zero address (0x000...0000). When tokens are sent to the zero address, the tokens become irrecoverable, but totalSupply is not reduced (only balanceOf[ZERO_ADDRESS] increases). This breaks the common expectation that burning reduces totalSupply and can confuse downstream accounting that does not exclude the zero address. It can result in accidental permanent loss of user funds if they mistakenly transfer to the zero address. Occurs in: transfer(_to, _value) and transferFrom(_from, _to, _value).",
      "vulnerability_type": "token accounting / blackhole",
      "severity": "medium",
      "confidence": 0.7,
      "location": "transfer() and transferFrom()",
      "file": "CurveTokenV3.vy",
      "id": "08fd4f2ab9f022d6",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "set_name can be permanently unusable depending on minter address (external call to owner())",
      "description": "The set_name function authorizes metadata changes by requiring Curve(self.minter).owner() == msg.sender. If the current minter is an EOA or a contract that does not implement owner(), this external call will revert, making set_name unusable (permanent DoS for metadata updates). Additionally, if minter is later set to a contract that intentionally reverts on owner() or changes behavior, it can also block metadata changes. While this does not affect token transfers or balances, it is a denial-of-service vector for administrative metadata operations. Occurs in: set_name(_name, _symbol), on the call to Curve(self.minter).owner().",
      "vulnerability_type": "denial of service",
      "severity": "low",
      "confidence": 0.8,
      "location": "set_name()",
      "file": "CurveTokenV3.vy",
      "id": "93401b7ee5a92eac",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Unchecked ERC20 transfer return values in withdrawal paths can cause loss of user funds",
      "description": "Several user-withdrawal functions call ERC20.transfer without verifying the return value. If a token returns false (instead of reverting) to signal failure, the contract proceeds as if the transfer succeeded: pool accounting is updated and/or LP tokens are burned, but the user does not actually receive the tokens. This can permanently lock or steal user funds from the user\u2019s perspective.\n\nWhere it occurs:\n- remove_liquidity(): uses ERC20(self.coins[i]).transfer(msg.sender, value) without checking the boolean return (function remove_liquidity)\n- remove_liquidity_imbalance(): uses ERC20(self.coins[i]).transfer(msg.sender, _amounts[i]) without checking (function remove_liquidity_imbalance)\n- remove_liquidity_one_coin(): uses ERC20(self.coins[i]).transfer(msg.sender, dy) without checking (function remove_liquidity_one_coin)\n- withdraw_admin_fees(): uses ERC20(coin).transfer(msg.sender, value) without checking (owner-only; less critical for users but still unsafe)\n\nWhy it\u2019s a security issue:\n- The ERC20 standard allows transfer to return false to indicate failure. Without checking, the contract cannot detect failures and will update internal balances and/or burn LP tokens, resulting in users losing LP tokens while not receiving the expected asset.\n- Curve uses raw_call with explicit return checks elsewhere (e.g., exchange paths) to handle non-standard tokens, but these withdrawal functions do not, creating inconsistency and risk.\n\nPotential impact:\n- Users can lose funds when withdrawing if any pool coin returns false on transfer (or behaves non-standard), as state changes and LP burns will not revert to reflect the failed transfer.\n- Admin fee withdrawals could silently fail to deliver tokens to the owner while the function reports success (less critical, owner-only).\n\nRecommended fix:\n- Use the same \"safeTransfer\" pattern via raw_call with return-value checking as used in exchange/exchange_underlying, or explicitly assert on the boolean return from ERC20.transfer. This ensures a revert on failed transfer and prevents accounting state from diverging from token balances.",
      "vulnerability_type": "unchecked return value / token transfer handling",
      "severity": "high",
      "confidence": 0.75,
      "location": "remove_liquidity(), remove_liquidity_imbalance(), remove_liquidity_one_coin(), withdraw_admin_fees()",
      "file": "SwapTemplateMeta.vy",
      "id": "6edcfda488c80673",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "LP token mint/burn return values are not checked",
      "description": "The contract calls the external LP token functions mint() and burnFrom() but does not check their return values. Specifically: add_liquidity calls token.mint(msg.sender, mint_amount) without asserting the returned bool; remove_liquidity, remove_liquidity_imbalance, and remove_liquidity_one_coin call token.burnFrom(msg.sender, ...) without asserting the returned bool. If the LP token implementation returns false on failure instead of reverting (e.g., due to insufficient allowance or an internal condition), the pool will proceed as if the operation succeeded. This can lead to serious inconsistencies: in withdrawals, users could receive underlying tokens without actually burning their LP tokens, enabling draining of the pool; in deposits, users could deposit assets but receive no LP tokens. While Curve deployments use a trusted LP token that reverts on failure, the contract does not enforce this assumption and accepts any _pool_token in the constructor, making this a practical risk if misconfigured or if the token behaves non-standardly.",
      "vulnerability_type": "external call return value unchecked / access control assumption",
      "severity": "critical",
      "confidence": 0.7,
      "location": "add_liquidity(), remove_liquidity(), remove_liquidity_imbalance(), remove_liquidity_one_coin()",
      "file": "StableSwapHUSD.vy",
      "id": "2fdf27af45d953f6",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Division by zero in get_virtual_price when totalSupply is zero",
      "description": "get_virtual_price computes D * PRECISION / token_supply without checking whether token_supply is zero. If called before any liquidity is added (token_supply == 0), this will revert due to division by zero. This allows denial of service on a commonly-used view function, potentially breaking integrators or monitoring tools that expect a value at all times.",
      "vulnerability_type": "denial of service (division by zero)",
      "severity": "low",
      "confidence": 0.95,
      "location": "get_virtual_price()",
      "file": "StableSwapHUSD.vy",
      "id": "ac8174ff306ef92d",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Unsafe default: get_rate always returns 0",
      "description": "The get_rate function unconditionally returns 0 instead of computing a rate. Location: get_rate(_coin) function, lines 13-14. If this template is deployed or integrated without adding the intended pool-specific logic, any component relying on this rate (e.g., pricing, swaps, collateral valuation, or interest calculations) will treat the asset value as zero. This can enable protocol manipulation (e.g., draining funds via arbitrage against a 0 price, bypassing value checks) or cause denial of service (operations failing due to zero valuations) and data corruption in accounting. The docstring notes it's a template, but the contract as-is is unsafe for production integration.",
      "vulnerability_type": "logic flaw / protocol manipulation (unsafe default)",
      "severity": "critical",
      "confidence": 0.7,
      "location": "get_rate(_coin) function, lines 13-14",
      "file": "RateCalculatorTemplateMeta.vy",
      "id": "1bd9e15ffd259301",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Underflow risk in withdraw_admin_fees can DoS fee withdrawals",
      "description": "The function computes the withdrawable admin fee per coin as balanceOf(this) - balances[i]. If the actual token balance held by the pool is less than the internally accounted balance (e.g., due to fee-on-transfer tokens, deflationary tokens, or unexpected external token behavior), the subtraction underflows and reverts, causing withdraw_admin_fees to fail entirely. This can permanently prevent the owner from withdrawing accrued admin fees for all coins.\n\nWhere: withdraw_admin_fees(), statement `value: uint256 = cERC20(c).balanceOf(self) - self.balances[i]`.\n\nWhy it's a security issue: An attacker cannot generally force standard tokens to underflow, but if any pool asset is non-standard or changes behavior (e.g., fee-on-transfer or malicious token), or if funds are siphoned from the contract by the token contract itself (rebasing/deflation mechanics), this calculation underflows. Even without an attacker, a token with such mechanics would brick fee withdrawal.\n\nPotential impact: Denial of service on the admin-fee withdrawal path; owner cannot collect admin fees.",
      "vulnerability_type": "arithmetic underflow / denial of service",
      "severity": "medium",
      "confidence": 0.6,
      "location": "withdraw_admin_fees()",
      "file": "StableSwapRen.vy",
      "id": "32d07ec6a4498ee5",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Reliance on external exchangeRateCurrent as constant can brick core functions",
      "description": "The pool calls `exchangeRateCurrent()` via `_rates()` and declares it as a constant (view) in the cERC20 interface. In many lending tokens (e.g., Compound cTokens), `exchangeRateCurrent()` is non-view and updates state; when called via a STATICCALL (as a constant), it reverts. If any coin at `coins[i]` implements a non-view `exchangeRateCurrent()` or changes its implementation (e.g., via proxy upgrade) to be non-view, every function using `_rates()` will revert, including get_dy, exchange, add_liquidity, remove_liquidity_imbalance, remove_liquidity_one_coin, and calc_withdraw_one_coin. This results in a denial of service of critical functionality.\n\nWhere: `_rates()` uses `cERC20(self.coins[i]).exchangeRateCurrent()` declared as `constant`; propagated to pricing and liquidity functions.\n\nWhy it's a security issue: Misdeclaring a state-changing external function as constant forces a STATICCALL, which will revert if the callee writes state. Because this call is embedded in core paths, the pool can be bricked if the external token does not conform to the assumed signature.\n\nPotential impact: Denial of service of swaps and (some) liquidity operations if a coin\u2019s `exchangeRateCurrent()` is non-view.",
      "vulnerability_type": "external dependency misuse / denial of service",
      "severity": "medium",
      "confidence": 0.5,
      "location": "_rates(), and all callers using rates (get_dy, get_dy_underlying, exchange, add_liquidity, remove_liquidity_imbalance, remove_liquidity_one_coin, calc_withdraw_one_coin)",
      "file": "StableSwapRen.vy",
      "id": "0bc34e4bb3b95744",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Division by zero in get_virtual_price when token_supply is zero",
      "description": "get_virtual_price returns `D * PRECISION / token_supply` without checking that `token_supply > 0`. If called before any LP tokens exist (i.e., the pool is not yet seeded), `token_supply` is zero and the function reverts.\n\nWhere: get_virtual_price()\n\nWhy it's a security issue: Integrations or off-chain systems expecting this call to always succeed may encounter unexpected reverts, potentially disrupting monitoring or dependent on-chain logic that probes virtual price.\n\nPotential impact: Read-function denial of service until initial liquidity is added. No funds at risk, but may break integrations.",
      "vulnerability_type": "denial of service",
      "severity": "low",
      "confidence": 0.8,
      "location": "get_virtual_price()",
      "file": "StableSwapRen.vy",
      "id": "dacbdad4b7ba6aa2",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Division by zero in get_rate when aETH.ratio() returns 0",
      "description": "The get_rate function computes 10**36 / result, where result is obtained from aETH(_coin).ratio(). If the ratio() function returns 0 (e.g., due to a misconfigured or malicious _coin, or an edge state in the aETH contract), this will cause a division-by-zero and revert. This can lead to denial of service for any on-chain logic that depends on this calculator to proceed.\n- Where: get_rate() function, line 22 (division), result sourced at line 21\n- Why it's a security issue: A revert can halt higher-level protocol operations that depend on this rate (e.g., pricing, quoting, or rebalancing) leading to DoS.\n- Potential impact: Transactions calling this function (directly or indirectly) revert, potentially blocking protocol operations if this calculator is integrated on-chain.",
      "vulnerability_type": "denial of service",
      "severity": "medium",
      "confidence": 0.8,
      "location": "get_rate() function, lines 21-22",
      "file": "RateCalculatorAETH.vy",
      "id": "b59595961f1cb43f",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Unvalidated external call to arbitrary _coin address",
      "description": "The contract accepts any _coin address and directly invokes ratio() on it. A malicious contract could revert, consume excessive gas, or return unexpected values, potentially causing upstream reverts or misleading outputs if the result is consumed without validation.\n- Where: get_rate() function, line 21 (aETH(_coin).ratio())\n- Why it's a security issue: Calling into an arbitrary, potentially untrusted contract without validation allows griefing via reverts or abnormal behavior. While this function is view and has no state changes, protocols that integrate it on-chain may become susceptible to DoS if user-controlled inputs are forwarded.\n- Potential impact: Reverts/DoS in integrators that pass untrusted inputs; off-chain consumers may read manipulated rates if they trust outputs from arbitrary _coin addresses.",
      "vulnerability_type": "input validation / untrusted external call",
      "severity": "low",
      "confidence": 0.6,
      "location": "get_rate() function, line 21",
      "file": "RateCalculatorAETH.vy",
      "id": "037f15c17a180e3a",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Assumes non-deflationary, standard ERC20 behavior leading to accounting mismatch",
      "description": "The pool updates internal balances and mints/burns LP tokens based on the user-provided 'amounts' and 'dx' before verifying the actual number of tokens transferred in. If a coin is fee-on-transfer, rebasing, or otherwise non-standard (transfers less/more than requested, or has callbacks), the contract will over-credit balances and/or mint too many LP tokens relative to assets actually received. This can drain value from the pool/LPs.\n\nWhere it occurs:\n- add_liquidity(): internal balances are updated (and LP minted) based on provided amounts, then ERC20 transferFrom is performed. If the token transfers less than '_amount', internal accounting is still increased by '_amount'.\n- exchange(): self.balances[i] is increased by 'dx' before calling transferFrom. If token transfers less than 'dx', pool accounting is incorrect while user still receives 'dy', causing loss to LPs.\n\nWhy it's a security issue: Malicious or non-standard tokens can manipulate accounting to extract value (e.g., deposit deflationary token to mint disproportionate LP, then withdraw more of the other asset), leading to loss of funds for the pool.\n\nPotential impact: Loss of funds/insolvency if the 'coins' array includes a fee-on-transfer/malicious ERC20. Even if intended for sETH/ETH, the code does not enforce token behavior at runtime.",
      "vulnerability_type": "token compatibility / accounting manipulation",
      "severity": "high",
      "confidence": 0.7,
      "location": "add_liquidity() and exchange() functions",
      "file": "StableSwapSETH.vy",
      "id": "005c150c14469a13",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Division by zero risk in get_virtual_price when LP supply is zero",
      "description": "get_virtual_price() divides by the LP token's totalSupply without checking if it's zero. If called before any liquidity is minted (or if totalSupply becomes zero due to external token behavior), this will revert due to division by zero. While this is a view, it can cause dependent contracts or UIs to revert unexpectedly.\n\nWhere it occurs: get_virtual_price(): 'return D * PRECISION / token_supply' without a zero-supply check.\n\nWhy it's a security issue: Can cause denial-of-service for integrators relying on this view function to not revert.\n\nPotential impact: DoS of off-chain/on-chain consumers calling get_virtual_price() when supply is zero.",
      "vulnerability_type": "denial of service",
      "severity": "low",
      "confidence": 0.9,
      "location": "get_virtual_price() function",
      "file": "StableSwapSETH.vy",
      "id": "b8c18ef2f5c0553b",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Unconditional zero-value transfers can revert and block withdrawals",
      "description": "In the _send_all function, the contract always attempts to transfer the full balance of each underlying token to the recipient, guarded only by the condition `_uamount >= 0`, which is always true for uint256. This means it will call transfer with amount 0 when the contract holds no balance for a given coin. Some ERC20 tokens are non-compliant and revert on zero-amount transfers. If any underlying token (notably non-standard tokens) reverts on `transfer(0)`, this will cause remove_liquidity, remove_liquidity_imbalance, or remove_liquidity_one_coin to revert, resulting in a denial of service for users attempting to withdraw. Occurs in: `_send_all(_addr, min_uamounts, one)` when `_uamount == 0` after any of the withdrawal flows (particularly for the non-lending coin path where no explicit zero-balance continue exists). Impact: A pool configuration that includes a token that reverts on zero transfers could intermittently block withdrawals whenever a particular coin's computed balance is zero due to rounding or pool state.",
      "vulnerability_type": "denial of service",
      "severity": "low",
      "confidence": 0.55,
      "location": "_send_all() function",
      "file": "DepositUSDT.vy",
      "id": "9b3738226a3dfc9e",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Unchecked return values for LP token mint and burnFrom enable loss of funds or theft",
      "description": "The contract calls the LP token's mint and burnFrom functions but does not check their boolean return values. If the LP token implementation returns false instead of reverting on failure, state transitions within this contract will proceed as if the operations succeeded.\n\nWhere it occurs:\n- add_liquidity(): self.token.mint(msg.sender, mint_amount) is called without checking the returned bool (around the end of the function).\n- remove_liquidity(): self.token.burnFrom(msg.sender, _amount) is called without checking the returned bool (after transferring out coins to the user).\n- remove_liquidity_imbalance(): self.token.burnFrom(msg.sender, token_amount) is called without checking the returned bool (after updating balances and before transferring coins).\n- remove_liquidity_one_coin(): self.token.burnFrom(msg.sender, _token_amount) is called without checking the returned bool (after reducing balances and before transferring the coin).\n\nWhy it's a security issue:\n- In remove_liquidity*, the function transfers underlying coins to the user before calling burnFrom. If burnFrom returns false (without reverting), the user receives assets but keeps their LP tokens, enabling repeated withdrawals and draining the pool.\n- In add_liquidity, if mint returns false (without reverting), the user\u2019s coins are transferred into the pool but the user receives no LP tokens, effectively locking their funds.\n\nPotential impact:\n- Pool drain via repeated withdrawals without burning LP tokens (theft / loss of funds).\n- Users losing funds on deposit due to receiving no LP tokens.\n\nNote: While the intended Curve LP token implementation reverts on failure, the current contract trusts an external _pool_token provided at deployment. Any deviation (buggy or malicious token) that returns false instead of reverting would break safety assumptions.",
      "vulnerability_type": "unchecked return value / external call trust",
      "severity": "critical",
      "confidence": 0.85,
      "location": "add_liquidity(), remove_liquidity(), remove_liquidity_imbalance(), remove_liquidity_one_coin()",
      "file": "StableSwapLinkUSD.vy",
      "id": "0c12539162524271",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Division by zero in get_virtual_price before initial liquidity",
      "description": "The get_virtual_price view function divides by token_supply without checking if it is zero. Before any liquidity is added, totalSupply() may be zero, causing a division-by-zero revert.\n\nWhere it occurs:\n- get_virtual_price(): return D * PRECISION / token_supply\n\nWhy it's a security issue:\n- While it does not directly cause loss of funds, it can cause denial of service for integrators or protocols that call get_virtual_price pre-initialization, potentially disrupting dependent systems.\n\nPotential impact:\n- Read-only DoS for external callers relying on this view during bootstrapping.",
      "vulnerability_type": "denial of service (read-only)",
      "severity": "low",
      "confidence": 0.6,
      "location": "get_virtual_price() function",
      "file": "StableSwapLinkUSD.vy",
      "id": "aef9120ec81f4a7e",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Unchecked return values for LP token mint/burn enable loss of funds or pool drain",
      "description": "The contract calls the LP token's mint and burnFrom functions without verifying their boolean return values. If the CurveToken implementation (or a misconfigured/malicious token passed at deployment) returns false without reverting, state changes within this contract will still succeed, leading to serious inconsistencies.\n\nWhere it occurs:\n- add_liquidity(): self.token.mint(msg.sender, mint_amount)\n- remove_liquidity(): self.token.burnFrom(msg.sender, _amount)\n- remove_liquidity_imbalance(): self.token.burnFrom(msg.sender, token_amount)\n- remove_liquidity_one_coin(): self.token.burnFrom(msg.sender, _token_amount)\n\nWhy it's a security issue:\n- On deposit (add_liquidity), if mint returns false, user transfers assets into the pool but does not receive LP tokens, causing a direct loss of funds.\n- On withdrawals (all remove_* paths), if burnFrom returns false, the function will still transfer out underlying coins to the user while failing to burn their LP tokens. This allows withdrawal without reducing LP balance, enabling repeated draining of the pool.\n\nPotential impact:\n- Complete loss of user funds on deposits if mint silently fails.\n- Unlimited draining of the pool by withdrawing without burning if burnFrom silently fails.",
      "vulnerability_type": "unchecked return value / external call",
      "severity": "critical",
      "confidence": 0.8,
      "location": "add_liquidity(), remove_liquidity(), remove_liquidity_imbalance(), remove_liquidity_one_coin()",
      "file": "StableSwapUSDK.vy",
      "id": "316cdaf1373ec26b",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Unrestricted sweeping of contract-held tokens via remove_liquidity",
      "description": "The remove_liquidity function transfers the entire balance of each underlying token held by the contract to the caller, regardless of how those tokens were obtained. If called with _amount = 0, the function still proceeds to: (1) withdraw from the base pool using any existing base LP token balance held by the contract, and (2) transfer the full balances of all meta and base coins to msg.sender. This occurs in remove_liquidity() lines where it sets _base_amount = ERC20(self.coins[MAX_COIN]).balanceOf(self) and later loops over all coins to transfer ERC20(coin).balanceOf(self) to the caller. As a result, any tokens accidentally sent to this contract or left over due to external interactions can be taken by anyone calling remove_liquidity with zero burn, leading to loss of stranded funds.",
      "vulnerability_type": "improper fund handling / unintended token sweep",
      "severity": "low",
      "confidence": 0.8,
      "location": "remove_liquidity(_amount, min_amounts) function: setting _base_amount from contract balance and transferring full balances in the final loop",
      "file": "DepositUSDK.vy",
      "id": "048fb12537cb23bb",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Fee-token (USDT) amount calculation uses total contract balance, enabling capture of previously stuck funds",
      "description": "In add_liquidity, when handling the fee-on-transfer asset FEE_ASSET (USDT), the code sets the deposit amount to the contract's entire USDT balance after transferFrom rather than the delta received for the current call. Specifically, after each transferFrom, it does `amount = ERC20(FEE_ASSET).balanceOf(self)` and assigns it to meta_amounts/base_amounts for that index. This means any pre-existing USDT in the contract (e.g., accidentally sent or left over) will be included in the deposit and result in additional LP tokens minted and returned to the current caller, effectively allowing them to capture previously stuck USDT. While normal operation should avoid leftover balances, this behavior can lead to loss of funds that were mistakenly sent to the contract.",
      "vulnerability_type": "improper accounting / unintended token sweep",
      "severity": "low",
      "confidence": 0.75,
      "location": "add_liquidity(amounts, min_mint_amount) function: post-transfer FEE_ASSET handling within the for-loop over N_ALL_COINS",
      "file": "DepositUSDK.vy",
      "id": "33c8ec55d045e0ce",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Unbounded fee parameter allows denial-of-service via division by zero",
      "description": "The contract does not enforce an upper bound on the trading fee (self.fee). In commit_new_parameters/apply_new_parameters the owner can set future_fee to any value, and apply_new_parameters assigns it to self.fee without validation. Several functions (e.g., get_dx and get_dx_underlying) divide by (FEE_DENOMINATOR - self.fee). If self.fee >= FEE_DENOMINATOR, this results in a division by zero and reverts, breaking price quote functions and potentially swaps that depend on this math. While only the owner can set the parameter, a compromised or negligent admin can render quoting and some swap-related calculations unusable, causing protocol-level DoS.",
      "vulnerability_type": "improper input validation / denial of service",
      "severity": "medium",
      "confidence": 0.95,
      "location": "apply_new_parameters(), commit_new_parameters(); division in get_dx() and get_dx_underlying() where (FEE_DENOMINATOR - self.fee) is used",
      "file": "StableSwapUSDT.vy",
      "id": "caf206fc2a3cc740",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Division by zero in get_virtual_price when total supply is zero",
      "description": "get_virtual_price returns D * PRECISION / token_supply without checking that token_supply > 0. When the pool has not been initialized (no liquidity minted), token_supply is zero and this function will revert. This can cause read-time DoS for integrators that expect a view call to succeed during early deployment or in edge cases where supply becomes zero.",
      "vulnerability_type": "denial of service (read-time)",
      "severity": "low",
      "confidence": 0.9,
      "location": "get_virtual_price()",
      "file": "StableSwapUSDT.vy",
      "id": "97ba0dd81e280734",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Full underlying token balance is transferred to caller (can sweep donated/stray underlying)",
      "description": "Several functions transfer the entire contract balance of an underlying token to the caller instead of only the amount produced by the current action. Specifically:\n\n- exchange_underlying(): after redeeming cyTokens, it sets `dy = ERC20(underlying).balanceOf(self)` and transfers that full balance to the caller.\n- remove_liquidity(): for each coin when `_use_underlying` is true, after redeeming, it sets `value = ERC20(underlying).balanceOf(self)` and transfers the full balance.\n- remove_liquidity_imbalance(): when `_use_underlying` is true, after redeeming, it transfers `ERC20(underlying).balanceOf(self)`.\n- remove_liquidity_one_coin(): when `_use_underlying` is true, after redeeming, it sets `amount = ERC20(underlying).balanceOf(self)` and transfers that.\n\nWhat: This pattern forwards any pre-existing underlying token balance held by the contract (e.g., accidental donations, airdrops, or dust) to the next caller who triggers one of these flows, instead of only sending the delta created by the current redeem operation.\n\nWhere: \n- exchange_underlying() around the lines where `dy` is set from `balanceOf(self)` and transferred.\n- remove_liquidity() in the `_use_underlying` branch where `value = ERC20(underlying).balanceOf(self)` is used.\n- remove_liquidity_imbalance() in the `_use_underlying` branch where `ERC20(underlying).balanceOf(self)` is transferred.\n- remove_liquidity_one_coin() in the `_use_underlying` branch where `amount = ERC20(underlying).balanceOf(self)` is used.\n\nWhy it's a security issue: Any underlying tokens held by the contract for reasons other than the current redemption (e.g., external transfers, rounding leftovers from prior operations, or mis-sent funds) can be drained by an arbitrary user calling these functions, effectively causing loss of those tokens from the protocol/admin and giving an unearned windfall to callers.\n\nPotential impact: Loss of any stray/donated underlying tokens from the contract. While the normal flow aims to keep underlying balances at zero, any unexpected underlying balance will be swept to the next caller. This can also complicate accounting or incident recovery if funds are accidentally sent to the contract.\n\nRecommended fix: For each function, measure the delta by taking the underlying token balance before and after the redeem operation and transfer only the difference attributable to the current action (i.e., `amount_out = after - before`).",
      "vulnerability_type": "improper accounting / funds misdirection",
      "severity": "low",
      "confidence": 0.95,
      "location": "exchange_underlying(), remove_liquidity() (_use_underlying branch), remove_liquidity_imbalance() (_use_underlying branch), remove_liquidity_one_coin() (_use_underlying branch)",
      "file": "StableSwapIB.vy",
      "id": "1a4379224b509efb",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Use of full token balances in add_liquidity enables unauthorized capture of stray cTokens",
      "description": "In add_liquidity, when USE_LENDING is true, the contract sets amounts[i] = cERC20(self.coins[i]).balanceOf(self) after minting for a non-zero uamount. This uses the contract's entire cToken balance for coin i (including any pre-existing cTokens sent to the contract outside of the current call), not just the delta minted from the caller's uamount. Curve.add_liquidity is then called with these amounts and the resulting LP tokens are transferred entirely to msg.sender. As a result, any cTokens that were previously in the contract (e.g., accidentally sent by others or left due to unexpected behavior) are effectively deposited for the benefit of the current caller, who receives the LP tokens for the full deposit. This occurs in add_liquidity(), within the loop over coins: after minting, the code sets amounts[i] = cERC20(self.coins[i]).balanceOf(self) and approves the curve, instead of tracking only the newly minted amount. Impact: an attacker can scoop up any pre-existing cTokens sitting in the contract by supplying a minimal uamount > 0 for that coin, causing the contract to include the entire balance (including the stray tokens) into the Curve deposit and then transfer all LP tokens to the attacker. This can lead to unauthorized capture of assets that should not be attributed to the current user.",
      "vulnerability_type": "asset misattribution / funds theft via balance accounting",
      "severity": "medium",
      "confidence": 0.7,
      "location": "add_liquidity() function; inside the per-coin branch when use_lending[i] is true, where amounts[i] is set to cERC20(self.coins[i]).balanceOf(self)",
      "file": "DepositCompound.vy",
      "id": "2f7ccb7342d14a29",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Division-by-zero in get_virtual_price when LP supply is zero",
      "description": "The get_virtual_price view function computes D * 1e18 / token_supply without checking that totalSupply() > 0. If called before any liquidity is minted (token_supply == 0), it will revert due to division by zero. While it does not endanger funds, it can cause denial of service for integrators or UIs that query this function on newly deployed or emptied pools.",
      "vulnerability_type": "denial of service",
      "severity": "low",
      "confidence": 0.9,
      "location": "get_virtual_price() function",
      "file": "StableSwapSTETH.vy",
      "id": "de7bf64d840c5e8c",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Virtual price and on-chain metrics can be manipulated via free donations",
      "description": "The pool\u2019s balance accounting uses raw token/ETH balances minus admin_balances, and there is no mechanism preventing third parties from directly transferring stETH (ERC20) or sending ETH via payable entrypoints in a way that increases the pool balances without minting LP tokens. This can artificially increase the invariant D and, therefore, the reported virtual price returned by get_virtual_price, as well as influence outputs of calc_token_amount and calc_withdraw_one_coin. While this does not allow theft of funds from the pool, it can manipulate on-chain metrics relied upon by external protocols, potentially enabling oracle or protocol manipulation if those protocols use virtual price or similar read-only outputs for economic decisions.",
      "vulnerability_type": "protocol manipulation",
      "severity": "medium",
      "confidence": 0.7,
      "location": "get_virtual_price(), calc_token_amount(), calc_withdraw_one_coin(), and any logic using self._balances()",
      "file": "StableSwapSTETH.vy",
      "id": "e2b35b317f264f6e",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Owner can transfer ownership to the zero address, bricking admin control",
      "description": "commit_transfer_ownership and apply_transfer_ownership do not validate future_owner against ZERO_ADDRESS. If the current owner commits and applies a transfer to the zero address, the contract\u2019s admin functions (fee updates, kill/unkill, withdrawing admin fees) become permanently inaccessible. This is a footgun that can lead to loss of admin control and inability to respond to emergencies, indirectly increasing risk to users (e.g., inability to pause/kill swaps within the allowed window or to withdraw admin fees).",
      "vulnerability_type": "access control",
      "severity": "low",
      "confidence": 0.8,
      "location": "commit_transfer_ownership() and apply_transfer_ownership()",
      "file": "StableSwapSTETH.vy",
      "id": "355c666da7250bd5",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Accounting mismatch due to unsupported deflationary/rebasing tokens (no actual-received check)",
      "description": "The contract assumes ERC20 tokens transfer the exact amount requested and that balances remain constant unless changed by the contract. In add_liquidity and exchange, internal accounting is updated using the user-supplied amount (_amounts[i] or _dx) before or without verifying how much the contract actually received. For fee-on-transfer/deflationary tokens (which transfer less than requested) or rebasing tokens (whose balances change asynchronously), this creates a mismatch between self.balances and the real token balances. Attackers can exploit this by depositing or swapping with such a token to inflate credited balances and drain other assets at favorable rates.\n\nWhere it occurs:\n- add_liquidity(): balances are updated based on _amounts[i] (lines within the for-loop setting new_balances and later self.balances), and ERC20 transferFrom is called afterward without reconciling actual received amounts.\n- exchange(): self.balances[i] is immediately increased by _dx (\"self.balances[i] = old_balances[i] + _dx\") before performing transferFrom of the input token, with no check that the contract actually received _dx. If the token transfers less (fee-on-transfer), dy is still paid out as if full _dx was received.\n\nWhy it's a security issue:\n- For fee-on-transfer tokens, the pool credits the full amount while receiving less, allowing users to mint excess LP tokens or receive outsized swap outputs, effectively draining other coins from the pool.\n- For rebasing tokens, external balance changes break the invariant relative to recorded balances, enabling price manipulation and potential loss for liquidity providers.\n\nPotential impact:\n- Loss of funds from the pool as attackers swap in deflationary tokens and withdraw more of the other assets than they should.\n- Invariant and pricing corruption leading to LP losses and potential insolvency of the pool.\n\nThis template assumes standard ERC20 behavior (no transfer fees, no rebasing). However, the contract does not enforce or validate this assumption, leaving deployments vulnerable if a non-standard token is included.",
      "vulnerability_type": "token standard assumption / accounting mismatch (unsupported fee-on-transfer/rebasing tokens)",
      "severity": "high",
      "confidence": 0.9,
      "location": "add_liquidity() for-loop updating balances and subsequent raw_call transferFrom; exchange() before transferFrom where balances[i] is incremented",
      "file": "SwapTemplateEth.vy",
      "id": "cf0879ea7f8a323b",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Division by zero in get_virtual_price when LP total supply is zero",
      "description": "get_virtual_price computes D * 1e18 / token_supply without checking whether token_supply is zero. If called before any LP tokens are minted, ERC20(self.lp_token).totalSupply() returns 0, causing a division-by-zero revert.\n\nWhere it occurs:\n- get_virtual_price() returns D * PRECISION / token_supply without a zero-supply guard.\n\nWhy it's a security issue:\n- While this is a view function and does not directly cause fund loss, integrations relying on this view may experience failures or denial of service before pool initialization.\n\nPotential impact:\n- DoS for off-chain or on-chain components that call get_virtual_price pre-initialization.",
      "vulnerability_type": "denial of service (view function division by zero)",
      "severity": "low",
      "confidence": 0.8,
      "location": "get_virtual_price() function",
      "file": "SwapTemplateEth.vy",
      "id": "3382e29ef80e1ff8",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    }
  ],
  "token_usage": {
    "input_tokens": 430372,
    "output_tokens": 207399,
    "total_tokens": 637771
  }
}