{
  "project": "code4rena_starknet-perpetual_2025_06",
  "timestamp": "2025-09-02T06:03:10.540461",
  "files_analyzed": 34,
  "files_skipped": 0,
  "total_findings": 19,
  "findings": [
    {
      "title": "Incorrect implementation of is_non_one leads to wrong branching on Price == 1",
      "description": "The method PriceOneImpl::is_non_one is implemented as `!self.value.is_one()`, which calls the u64 primitive's is_one() (checks if value == 1), not the Price-level notion of one (value == PRICE_SCALE). As a result, when Price == 1 (i.e., internal value == PRICE_SCALE), is_non_one incorrectly returns true. This breaks invariants and can cause logic that should only execute for prices != 1 to run when price is exactly 1.\n- Where: PriceOneImpl::is_non_one(), near the end of the file\n- Why it's a security issue: If other parts of the protocol rely on Price::is_non_one to guard fee-free or special-case logic for a price of 1, this bug may bypass checks or misroute execution.\n- Potential impact: Logic/invariant bypass, leading to incorrect fee application, pricing branches, or other condition-based behavior being executed under the wrong condition.",
      "vulnerability_type": "logic error",
      "severity": "medium",
      "confidence": 0.95,
      "location": "PriceOneImpl::is_non_one()",
      "file": "price.cairo",
      "id": "2ca60c0faabaf3ad",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Division by zero in convert_oracle_to_perps_price can cause DoS",
      "description": "convert_oracle_to_perps_price divides by the supplied resolution_factor without checking it is non-zero: `converted_price /= resolution_factor.into();`. Passing resolution_factor == 0 will cause a panic/revert.\n- Where: convert_oracle_to_perps_price(), line with `converted_price /= resolution_factor.into();`\n- Why it's a security issue: If resolution_factor is derived from external input or can be misconfigured, an attacker or misconfiguration can cause pricing operations to revert, leading to a denial of service for any flow that computes prices.\n- Potential impact: Transaction reverts/DoS of functions that rely on price conversion.",
      "vulnerability_type": "arithmetic error (division by zero) / denial of service",
      "severity": "high",
      "confidence": 0.85,
      "location": "convert_oracle_to_perps_price()",
      "file": "price.cairo",
      "id": "338a8658d3676615",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Unchecked large oracle_price can overflow during conversion and revert",
      "description": "In convert_oracle_to_perps_price, the code multiplies `oracle_price * PRICE_SCALE` using u128 arithmetic without bounding oracle_price first. Extremely large oracle_price values can overflow u128 and cause a panic before any bounds assertions: `let mut converted_price = oracle_price * PRICE_SCALE.into();`.\n- Where: convert_oracle_to_perps_price(), line with `oracle_price * PRICE_SCALE.into()`\n- Why it's a security issue: If untrusted or unvalidated oracle_price values can reach this function (e.g., before signature/range checks), an attacker can cause consistent reverts by submitting oversized values, leading to DoS of price-dependent functionality.\n- Potential impact: Denial of service (transaction reverts) in any code path that invokes this conversion with unbounded input.",
      "vulnerability_type": "integer overflow / denial of service",
      "severity": "medium",
      "confidence": 0.7,
      "location": "convert_oracle_to_perps_price()",
      "file": "price.cairo",
      "id": "615d00a82c1311aa",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Oracle whitelist bypass in price_tick",
      "description": "The contract verifies signatures from provided SignedPrice entries but never checks that the signer_public_key belongs to a registered oracle for the asset. In _validate_price_tick (called by price_tick), each signature is validated via _validate_oracle_signature, which reads the per-asset oracle entry and uses its packed value only to build the message hash. If the oracle key is not registered (or was removed), the storage read returns 0, but no check is performed to reject unregistered/removed oracles. As a result, any party controlling arbitrary keys can produce valid signatures over the contract-computed message and meet the quorum with their own keys. Where: _validate_price_tick() and _validate_oracle_signature() (also duplicated as validate_oracle_signature()), invoked by price_tick(). Why: There is no assertion that the oracle key exists (non-zero entry) before accepting a signature. remove_oracle_from_asset() sets the mapping to zero, but the signature path never rejects zero entries. Impact: An attacker (or compromised operator) can set arbitrary prices by submitting enough signatures from self-controlled keys to satisfy the quorum, leading to price manipulation, forced liquidations, or other loss-of-funds scenarios.",
      "vulnerability_type": "access control / signature validation flaw",
      "severity": "critical",
      "confidence": 0.95,
      "location": "price_tick() -> _validate_price_tick() -> _validate_oracle_signature() / validate_oracle_signature()",
      "file": "assets.cairo",
      "id": "5b354e5be500d300",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Improper validation of risk_factor_tiers ordering allows unsafe configurations",
      "description": "In add_synthetic_asset, the code intends to ensure risk_factor_tiers are strictly increasing, but the variable prev_risk_factor is never updated inside the loop. The assertion assert(prev_risk_factor < *risk_factor, UNSORTED_RISK_FACTOR_TIERS) always compares each tier only to the initial 0, allowing sequences like [5, 3, 2] to pass. Where: add_synthetic_asset(), in the for risk_factor in risk_factor_tiers loop. Why: prev_risk_factor remains 0 for the entire loop, so the tiers are not validated for monotonicity. Impact: Misordered tiers can cause get_synthetic_risk_factor() to return a lower risk factor for larger exposures, underestimating risk and enabling under-collateralization. This can lead to insolvency and loss of funds across the protocol.",
      "vulnerability_type": "logic/validation bug leading to economic risk",
      "severity": "high",
      "confidence": 0.9,
      "location": "add_synthetic_asset() risk_factor_tiers validation loop",
      "file": "assets.cairo",
      "id": "f586535ed0a9bcb9",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Price signature domain separation weak: messages not bound to asset_id/contract",
      "description": "The signature message is pedersen(packed_asset_oracle, packed_price_timestamp), where packed_asset_oracle encodes asset_name and oracle_name but not asset_id or contract address. If two assets share the same asset_name for a given oracle_name, signatures are reusable between assets. Similarly, signatures may be reusable across contracts that configure identical packed values. Where: _validate_oracle_signature() / validate_oracle_signature(). Why: Missing inclusion of asset_id and/or contract address in the signed message enables cross-asset or cross-contract replay when names collide. Impact: If governance configures duplicate asset_name values (or an attacker mirrors configuration in another contract), valid signatures for one asset/contract can be replayed to update prices for another, potentially causing incorrect pricing and economic loss. Note: This is exacerbated by the lack of oracle membership check described above.",
      "vulnerability_type": "signature replay / domain separation",
      "severity": "medium",
      "confidence": 0.6,
      "location": "_validate_oracle_signature() and validate_oracle_signature()",
      "file": "assets.cairo",
      "id": "0c2df9f327be13c8",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Stale approval allows overwriting an existing owner_account in set_owner_account",
      "description": "The set_owner_account function does not re-validate that the position has no owner_account before writing a new one. Although set_owner_account_request enforces that a request can only be registered when the position has no owner_account, an approved request created earlier (when there was no owner) can be consumed later to overwrite an already-set owner_account.\n\nWhere: set_owner_account() function.\n\nWhy it's a security issue: This breaks the intended invariant described in the function's documentation (\"The position has no account owner.\"). It allows an operator to change the owner_account without the current owner_account's involvement, by consuming a previously approved request. This creates a race/ordering vulnerability where multiple approved requests can be registered up-front and executed later to seize or flip control of the position, bypassing the current owner_account's expected control flow (which otherwise requires the owner_account to authorize changes via set_public_key_request).\n\nPotential impact: Unauthorized change of the position's owner_account from the perspective of the current on-chain owner, enabling account takeover, disruption of control, or forced transfer of ownership through stale approvals.",
      "vulnerability_type": "access control / improper state validation",
      "severity": "high",
      "confidence": 0.88,
      "location": "set_owner_account()",
      "file": "positions.cairo",
      "id": "3e52ced12d09ef8e",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Initialization function lacks explicit access control (potentially externally callable)",
      "description": "The initialize function does not enforce any access control beyond a one-time check (ALREADY_INITIALIZED). If this function is exposed externally in the integrating contract, any caller could initialize the component and set arbitrary public keys for the fee and insurance fund positions on a fresh deployment.\n\nWhere: initialize() function.\n\nWhy it's a security issue: If externally callable, an attacker can front-run deployment initialization and set fee_position_owner_public_key and insurance_fund_position_owner_public_key to attacker-controlled keys, potentially redirecting protocol fees/insurance mechanisms.\n\nPotential impact: Seizure of control over special positions (fee/insurance), protocol fund manipulation, and loss of funds tied to these positions.\n\nNote: If initialize is only callable internally during contract deployment and not exposed as a public entry point, this issue does not apply. Verify exposure in the integrating contract.",
      "vulnerability_type": "access control",
      "severity": "critical",
      "confidence": 0.55,
      "location": "initialize()",
      "file": "positions.cairo",
      "id": "d4fe8d84c51ccecf",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Potential division-by-zero/invalid denominator in ratio checks",
      "description": "The function validate_against_actual_amounts constructs Fraction values with denominators derived from |quote_amount| and |actual_amount_quote|. If either quote_amount (from the order) or actual_amount_quote (from execution) is zero, the denominator becomes zero. FractionTrait::new is expected to reject zero denominators, causing a revert/panic before reaching the assertions. This occurs at the points where denominators are built:\n- order_base_to_quote_ratio: denominator = (*self.quote_amount).abs() (validate_against_actual_amounts)\n- actual_base_to_quote_ratio: denominator = actual_amount_quote.abs() (validate_against_actual_amounts)\n- actual_fee_to_quote_ratio: denominator = actual_amount_quote.abs() (validate_against_actual_amounts)\n- order_fee_to_quote_ratio: denominator = (*self.quote_amount).abs() (validate_against_actual_amounts)\nWhy it's a security issue: If untrusted input can reach this function (e.g., orders stored on-chain or adversarial batch data), an attacker can supply an order with quote_amount == 0, or trigger validation with actual_amount_quote == 0, causing a revert. In batch processing or matching routines that iterate over multiple orders within one transaction, a single crafted order can cause the entire transaction to revert, creating a denial-of-service vector.\nPotential impact: Transaction-level DoS of order processing or settlement flows that rely on this validation, preventing other valid orders in the same batch from executing.",
      "vulnerability_type": "denial of service / input validation",
      "severity": "medium",
      "confidence": 0.7,
      "location": "validate_against_actual_amounts(), denominators built from (*self.quote_amount).abs() and actual_amount_quote.abs()",
      "file": "order.cairo",
      "id": "0bf603333194b914",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "i64::MIN absolute value edge-case may overflow or yield invalid denominator",
      "description": "The code uses the Abs trait on signed 64-bit integers for denominators: (*self.quote_amount).abs() and actual_amount_quote.abs(). For i64, the absolute value of INT_MIN (-2^63) is not representable in i64. Depending on the Abs implementation, this can either panic/revert or return a negative value (i64::MIN), leading to a negative/invalid denominator being passed to FractionTrait::new. This occurs in validate_against_actual_amounts at all the same denominator constructions as above.\nWhy it's a security issue: A malicious order with quote_amount == i64::MIN or adversarial execution with actual_amount_quote == i64::MIN can cause a revert (DoS) or, if not guarded, produce an invalid fraction that could make the subsequent ratio comparison behave unexpectedly. While using 64-bit bounds may make this edge case rare, it is a reachable value and should be handled explicitly.\nPotential impact: Denial-of-service due to revert during validation; in the unlikely case the Abs implementation returns a negative value without reverting, it could lead to incorrect ratio comparisons and price checks being bypassed.",
      "vulnerability_type": "integer overflow/edge-case arithmetic",
      "severity": "low",
      "confidence": 0.6,
      "location": "validate_against_actual_amounts(), denominators built from (*self.quote_amount).abs() and actual_amount_quote.abs()",
      "file": "order.cairo",
      "id": "74cb537072f19df1",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Potential u128 overflow in multiplication leading to revert",
      "description": "The mul function multiplies the u128-converted value (<= 100) by an arbitrary u128 input before dividing by 100: ((*self.value).into() * other) / DENOMINATOR.into(). If other is large (>= floor(u128::MAX / 100) + 1), the intermediate product overflows u128, causing a panic and reverting the transaction. This constitutes a denial-of-service vector if other can be influenced by untrusted input or external data. Impact: any call path relying on RiskFactor::mul can be made to revert for certain inputs, potentially blocking operations (e.g., calculations in risk checks, liquidations, or batch operations).\nWhere: mul(self: @RiskFactor, other: u128) function, around lines 24-26.\nWhy it's a security issue: Overflow in Cairo's fixed-size integers triggers a panic, reverting the call. An attacker can supply or manipulate other to induce overflow and force reverts.\nPotential impact: Transaction revert/DoS on affected paths. Depending on integration, could block critical protocol flows that use this computation.\nSuggested fix: Avoid overflow by reordering operations or using wider intermediates. For example: ((other / 100_u128) * value) + (((other % 100_u128) * value) / 100_u128), which preserves truncation semantics without overflowing; or compute in u256 and downcast after division.",
      "vulnerability_type": "integer overflow / denial of service",
      "severity": "medium",
      "confidence": 0.85,
      "location": "mul() function, lines ~24-26",
      "file": "risk_factor.cairo",
      "id": "f9f649feb91818c3",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Arithmetic overflows/underflows in i64 operations can cause panics (DoS)",
      "description": "All arithmetic on Balance.value uses i64 addition/subtraction/negation, which will panic on overflow/underflow in Cairo 1.0. This can be triggered by attacker-controlled inputs or extreme values, causing transaction reverts and potential denial of service. Occurs in: BalanceAdd.add (add operator for Balance), BalanceSub.sub (sub operator for Balance), BalanceAddAssign.add_assign, BalanceSubAssign.sub_assign, BalanceImpl.add (adds i64 to Balance), BalanceImpl.sub (subtracts i64 from Balance), and BalanceNeg.neg (negation), where -(i64::MIN) will also panic. Because these operations are not guarded, any external-facing function that uses them with untrusted inputs can be forced to revert, preventing state updates or making certain account states unusable.",
      "vulnerability_type": "integer overflow/underflow, denial of service",
      "severity": "medium",
      "confidence": 0.9,
      "location": "BalanceAdd.add, BalanceSub.sub, BalanceAddAssign.add_assign, BalanceSubAssign.sub_assign, BalanceImpl.add, BalanceImpl.sub, BalanceNeg.neg",
      "file": "balance.cairo",
      "id": "97dcc26b3e25383f",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "u64 -> i64 conversion uses expect() and can panic on large inputs (DoS)",
      "description": "The U64IntoBalance impl converts u64 to i64 via try_into().expect('Balance value doesn\\'t fit i64'). Any u64 greater than i64::MAX will cause expect() to panic, reverting the call. If an external caller can supply such a value, they can force functions using this conversion path to revert, resulting in a denial of service. This occurs in U64IntoBalance.into.",
      "vulnerability_type": "input validation, denial of service",
      "severity": "medium",
      "confidence": 0.95,
      "location": "U64IntoBalance.into",
      "file": "balance.cairo",
      "id": "a82a334f8111bcad",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Operator-only entrypoints lack authorization; operator nonce is not access control",
      "description": "Multiple functions that are documented as operator-only do not restrict the caller and instead only check a monotonically increasing operator_nonce. An arbitrary account can read/guess the current nonce and successfully call these functions. This allows non-operators to execute privileged flows (e.g., executing trades/liquidations/deleverages, or executing others' approved withdrawals/transfers) and, more critically, to grief the system by continuously consuming the global operator nonce to delay or censor intended operator actions.\n\nWhere: CoreImpl.withdraw(), CoreImpl.transfer(), CoreImpl.trade(), CoreImpl.liquidate(), CoreImpl.deleverage(), CoreImpl.reduce_inactive_asset_position() (all rely on self.operator_nonce.use_checked_nonce but have no caller/role check).\n\nWhy it's a security issue: The operator nonce is a sequencing/replay guard, not an authorization mechanism. Anyone who supplies the correct next nonce can execute these state-changing operations. This enables: (1) front-running and reordering of trades/liquidations by third parties; (2) denial of service by continuously consuming the next nonce with cheap, self-targeted operations (e.g., deleverage/reduce_inactive_asset_position on attacker-controlled positions) to starve the operator; (3) execution of user-approved withdrawals/transfers by any third party (contrary to the stated operator-only intent), impacting protocol control and revenue assumptions.\n\nPotential impact: DoS against the operator pipeline; censorship and ordering manipulation; unexpected execution of operator-only flows by non-operators; potential ecosystem instability.",
      "vulnerability_type": "access control",
      "severity": "high",
      "confidence": 0.9,
      "location": "withdraw(), transfer(), trade(), liquidate(), deleverage(), reduce_inactive_asset_position()",
      "file": "core.cairo",
      "id": "0444a4ce62afe960",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Possible reentrancy via external ERC20 transfer in withdraw",
      "description": "The withdraw function updates internal state (applies position diff and consumes the approval) before performing an external call to the collateral token contract (IERC20DispatcherTrait.transfer). If the collateral token is malicious, it can reenter Core during this external call because there is no reentrancy guard. While consume_approved_request prevents double-use of the same withdrawal approval, a reentrant call could invoke other state-changing entrypoints (e.g., deleverage/reduce_inactive_asset_position) and consume the next operator_nonce, enabling nonce-draining DoS or unexpected interleavings.\n\nWhere: CoreImpl.withdraw(): positions.apply_diff(...) is executed before token_contract.transfer(...), which is an external call.\n\nWhy it's a security issue: External calls to untrusted contracts after state updates allow reentrancy. Without a guard, an attacker controlling the token can reenter and cause unexpected state transitions or systematically consume operator nonces, disrupting protocol operation.\n\nPotential impact: Denial of service and ordering manipulation via nonce draining; unexpected nested state changes during withdraw execution.",
      "vulnerability_type": "reentrancy",
      "severity": "medium",
      "confidence": 0.7,
      "location": "withdraw()",
      "file": "core.cairo",
      "id": "727bd10973e2e6f8",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Unchecked u64 multiplication may overflow in withdraw unquantization",
      "description": "The unquantized token amount is computed as quantum * amount using u64 arithmetic and then sent to the token contract. If this multiplication overflows u64, behavior depends on Cairo semantics: if it wraps, the contract will transfer an incorrect (smaller) amount while still debiting the full collateral in quantized units, causing loss/inconsistency; if it panics, the operation becomes a DoS vector for large amounts.\n\nWhere: CoreImpl.withdraw(): let withdraw_unquantized_amount = quantum * amount; followed by token.transfer(recipient, amount: withdraw_unquantized_amount.into()).\n\nWhy it's a security issue: A silent overflow could lead to incorrect asset transfers relative to the internal accounting, enabling loss of funds or accounting mismatch. Even if it reverts on overflow, an attacker could use boundary values to revert withdrawals (DoS).\n\nPotential impact: Loss of funds due to under-transfer vs. internal debit (if wrapping); revert-based DoS for large values (if checked).\n\nRecommendation: Use a wider integer type for intermediate multiplication or an explicit checked multiplication with a revert on overflow before applying state changes.",
      "vulnerability_type": "integer overflow",
      "severity": "medium",
      "confidence": 0.55,
      "location": "withdraw()",
      "file": "core.cairo",
      "id": "fc164dca66857650",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "process_deposit lacks access control and allows anyone to process deposits",
      "description": "The process_deposit function is externally callable by any address and does not enforce any operator role or signature-based authorization. It only checks that the contract is not paused and that the provided operator_nonce matches the expected value. As a result, any attacker who supplies the correct next nonce can process any pending deposit (for any depositor/position/amount/salt) and mark it as PROCESSED, crediting the position's collateral. This bypasses the intended validations listed in the comments (operator-only, expiration, price/funding checks, fact registration, position ownership checks). It also enables a denial of service by consuming the operator nonce and preventing legitimate operator actions.\n\nWhere: process_deposit(...) function\nWhy it's a security issue: Unauthorized parties can execute privileged flow, bypassing protocol risk checks and operator control. They can process deposits early, prevent user cancellations, manipulate system state, and grief the operator by consuming nonces.\nPotential impact: Protocol manipulation, denial of service against the operator (by racing to consume the next nonce), forced processing of deposits, and potential downstream loss of funds due to bypassed validations.",
      "vulnerability_type": "improper access control / authorization",
      "severity": "critical",
      "confidence": 0.95,
      "location": "process_deposit() function",
      "file": "deposit.cairo",
      "id": "20422f49bb61faa8",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Deposit request hash binds to current collateral token address causing permanent lock if token address changes",
      "description": "The deposit_hash includes token_address and is recomputed at each call. In deposit(), the hash is computed with the collateral token address at deposit time; later, cancel_deposit() and process_deposit() recompute the hash using the current collateral token from Assets. If the collateral token contract address in Assets is ever changed (e.g., governance migration), the recomputed hash will differ from the original, making the existing pending deposit unreachable (status appears NOT_REGISTERED). The user would be unable to cancel or have the deposit processed, effectively locking funds held by the contract.\n\nWhere: deposit_hash(...) and its use in deposit(), cancel_deposit(), process_deposit()\nWhy it's a security issue: A governance or configuration change to the collateral token address breaks access to existing deposits.\nPotential impact: Denial of service and potential permanent loss of user funds trapped in the contract.",
      "vulnerability_type": "denial of service / logic flaw",
      "severity": "high",
      "confidence": 0.75,
      "location": "deposit_hash() and uses in deposit(), cancel_deposit(), process_deposit()",
      "file": "deposit.cairo",
      "id": "a75b162360c95358",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Refund amount on cancellation uses current quantum instead of the deposit-time quantum",
      "description": "In cancel_deposit(), the contract calculates the refund as quantized_amount * current collateral quantum, not the quantum in effect when the deposit was made. If the collateral quantum changes between deposit and cancellation, the user may be refunded a different token amount than originally deposited, resulting in either user loss (if quantum decreased) or protocol loss (if quantum increased).\n\nWhere: cancel_deposit() \u2013 unquantized_amount = quantized_amount * get_collateral_quantum()\nWhy it's a security issue: Value accounting depends on a mutable parameter, leading to incorrect token refunds if configuration changes.\nPotential impact: Loss of funds to users or the protocol due to over/under refunds; creates an attack surface if quantum can be altered maliciously or mistakenly.",
      "vulnerability_type": "business logic / accounting error",
      "severity": "medium",
      "confidence": 0.65,
      "location": "cancel_deposit() function",
      "file": "deposit.cairo",
      "id": "7eba7ccdbca1f170",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    }
  ],
  "token_usage": {
    "input_tokens": 56210,
    "output_tokens": 84745,
    "total_tokens": 140955
  }
}